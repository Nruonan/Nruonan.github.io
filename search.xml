<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Cloud</title>
    <url>/2024/03/16/Cloud%20ALibaba/</url>
    <content><![CDATA[<h2 id="CAP原则"><a href="#CAP原则" class="headerlink" title="CAP原则"></a>CAP原则</h2><p>CAP 原则又称CAP定理，指的是在一个分布式系统中，存在Consistency（一致性）、Availability（可用性）、Partition tolerance（分区容错性），三者不可同时保证，最多只能保证其中的两者。</p>
<p>一致性（C）：在分布式系统中的所有数据备份，在同一时刻都是同样的值（所有的节点无论何时访问都能拿到最新的值）</p>
<p>可用性（A）：系统中非故障节点收到的每个请求都必须得到响应（比如我们之前使用的服务降级和熔断，其实就是一种维持可用性的措施，虽然服务返回的是没有什么意义的数据，但是不至于用户的请求会被服务器忽略）</p>
<p>分区容错性（P）：一个分布式系统里面，节点之间组成的网络本来应该是连通的，然而可能因为一些故障（比如网络丢包等，这是很难避免的），使得有些节点之间不连通了，整个网络就分成了几块区域，数据就散布在了这些不连通的区域中（这样就可能出现某些被分区节点存放的数据访问失败，我们需要来容忍这些不可靠的情况）</p>
<h3 id="AC-可用性-一致性"><a href="#AC-可用性-一致性" class="headerlink" title="AC 可用性+一致性"></a>AC 可用性+一致性</h3><p>要同时保证可用性和一致性，代表着某个节点数据更新之后，需要立即将结果通知给其他节点，并且要尽可能的快，这样才能及时响应保证可用性，这就对网络的稳定性要求非常高，但是实际情况下，网络很容易出现丢包等情况，并不是一个可靠的传输，如果需要避免这种问题，就只能将节点全部放在一起，但是这显然违背了分布式系统的概念，所以对于我们的分布式系统来说，很难接受。</p>
<h3 id="CP-一致性-分区容错性"><a href="#CP-一致性-分区容错性" class="headerlink" title="CP 一致性+分区容错性"></a>CP 一致性+分区容错性</h3><p>为了保证一致性，那么就得将某个节点的最新数据发送给其他节点，并且需要等到所有节点都得到数据才能进行响应，同时有了分区容错性，那么代表我们可以容忍网络的不可靠问题，所以就算网络出现卡顿，那么也必须等待所有节点完成数据同步，才能进行响应，因此就会导致服务在一段时间内完全失效，所以可用性是无法得到保证的。</p>
<h3 id="AP-可用性-分区容错性"><a href="#AP-可用性-分区容错性" class="headerlink" title="AP 可用性+分区容错性"></a>AP 可用性+分区容错性</h3><p>既然CP可能会导致一段时间内服务得不到任何响应，那么要保证可用性，就只能放弃节点之间数据的高度统一，也就是说可以在数据不统一的情况下，进行响应，因此就无法保证一致性了。虽然这样会导致拿不到最新的数据，但是只要数据同步操作在后台继续运行，一定能够在某一时刻完成所有节点数据的同步，那么就能实现<strong>最终一致性</strong>，所以AP实际上是最能接受的一种方案。</p>
<h2 id="openFeign"><a href="#openFeign" class="headerlink" title="openFeign"></a>openFeign</h2><h3 id="远程调用含义"><a href="#远程调用含义" class="headerlink" title="远程调用含义"></a>远程调用含义</h3><p><code>远程调用</code>和<code>本地调用</code>是相对的，那我们先说本地调用更好理解些，本地调用就是同一个 Service 里面的方法 A 调用方法 B。</p>
<p>那远程调用就是不同 Service 之间的方法调用。Service 级的方法调用，我们自己构造请求 URL和请求参数，就可以发起远程调用了。</p>
<p>在服务之间调用的话，我们都是基于 HTTP 协议，一般用到的远程服务框架有 OKHttp3，Netty, HttpURLConnection 等。其调用流程如下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1732590614281-36e2fb2c-c877-4591-8e4d-dadcf48d8288.png"></p>
<p>但是这种虚线方框中的构造请求的过程是很<strong>繁琐</strong>的，有没有更<strong>简便</strong>的方式呢？</p>
<p><strong>Feign</strong> 就是来简化我们发起远程调用的代码的，那简化到什么程度呢？**简化成就像调用本地方法那样简单。</p>
<h3 id="OpenFeign工作流程"><a href="#OpenFeign工作流程" class="headerlink" title="OpenFeign工作流程"></a>OpenFeign工作流程</h3><p>先看下 OpenFeign 的核心流程图：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1732590758302-e6ab47e2-f3da-4a75-ba6b-323e79c1dfbc.png"></p>
<ul>
<li>1、在 Spring 项目启动阶段，服务 A 的OpenFeign 框架会发起一个主动的扫包流程。</li>
<li>2、从指定的目录下扫描并加载所有被 @FeignClient 注解修饰的接口，然后将这些接口转换成 Bean，统一交给 Spring 来管理。</li>
<li>3、根据这些接口会经过 MVC Contract 协议解析，将方法上的注解都解析出来，放到 MethodMetadata 元数据中。</li>
<li>4、基于上面加载的每一个 FeignClient 接口，会生成一个动态代理对象，指向了一个包含对应方法的 MethodHandler 的 HashMap。MethodHandler 对元数据有引用关系。生成的动态代理对象会被添加到 Spring 容器中，并注入到对应的服务里。</li>
<li>5、服务 A 调用接口，准备发起远程调用。</li>
<li>6、从动态代理对象 Proxy 中找到一个 MethodHandler 实例，生成 Request，包含有服务的请求 URL（不包含服务的 IP）。</li>
<li>7、经过负载均衡算法找到一个服务的 IP 地址，拼接出请求的 URL</li>
<li>8、服务 B 处理服务 A 发起的远程调用请求，执行业务逻辑后，返回响应给服务 A。</li>
</ul>
<p><strong>核心思想：</strong></p>
<ul>
<li>OpenFeign 会扫描带有 @FeignClient 注解的接口，然后为其生成一个动态代理。</li>
<li>动态代理里面包含有接口方法的 MethodHandler，MethodHandler 里面又包含经过 MVC Contract 解析注解后的元数据。</li>
<li>发起请求时，MethodHandler 会生成一个 Request。</li>
<li>负载均衡器 Ribbon 会从服务列表中选取一个 Server，拿到对应的 IP 地址后，拼接成最后的 URL，就可以发起远程服务调用了。</li>
</ul>
<h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><p>利用它实现负载均衡，远程调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>接着在启动类添加<code>@EnableFeignClients</code>注解：开启远程调用服务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BorrowApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(BorrowApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到这个 interface 上添加了注解<code>&lt;font style=&quot;color:rgb(44, 62, 80);&quot;&gt;@FeignClient&lt;/font&gt;</code>，而且括号里面指定了服务名：book-service。显示声明这个接口用来远程调用 <code>&lt;font style=&quot;color:rgb(44, 62, 80);&quot;&gt;book&lt;/font&gt;</code>服务。并且方法上添加了控制层响应地址</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;book-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookClient</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/book/&#123;bid&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">getBookById</span><span class="params">(<span class="meta">@PathVariable(&quot;bid&quot;)</span> <span class="type">int</span> bid)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务层Impl注入接口即可使用</p>
<h2 id="Alibaba-Cloud依赖导入"><a href="#Alibaba-Cloud依赖导入" class="headerlink" title="Alibaba Cloud依赖导入"></a>Alibaba Cloud依赖导入</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">2022.0</span><span class="number">.3</span>&lt;/version&gt;</span><br><span class="line">        &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">        &lt;scope&gt;<span class="keyword">import</span>&lt;/scope&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">2022.0</span><span class="number">.0</span><span class="number">.0</span>-RC2&lt;/version&gt;</span><br><span class="line">        &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">        &lt;scope&gt;<span class="keyword">import</span>&lt;/scope&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">  &lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h2><p>Nacos（Naming Configuration Service）是一款阿里巴巴开源的服务注册与发现、配置管理的组件，相当于是Eureka+Config的组合形态。</p>
<p>**启动命令： **<code>** ./startup.cmd -m standalone**</code></p>
<h3 id="服务管理依赖导入"><a href="#服务管理依赖导入" class="headerlink" title="服务管理依赖导入"></a>服务管理依赖导入</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;<span class="number">2022.0</span><span class="number">.0</span><span class="number">.0</span>-RC2&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;/artifactId&gt;  <span class="comment">// 负载均衡配置</span></span><br><span class="line">      &lt;version&gt;<span class="number">4.0</span><span class="number">.3</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="配置管理依赖导入"><a href="#配置管理依赖导入" class="headerlink" title="配置管理依赖导入"></a>配置管理依赖导入</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="yml文件配置"><a href="#yml文件配置" class="headerlink" title="yml文件配置"></a>yml文件配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: borrow-service  <span class="comment">// 程序名</span></span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: localhost:<span class="number">8848</span>	<span class="comment">// nacos运行地址</span></span><br><span class="line">        ephemeral: <span class="literal">false</span>	<span class="comment">// 是否短暂生效， false为持久化，</span></span><br><span class="line">        cluster-name: Guangzhou <span class="comment">// 集群名字</span></span><br><span class="line">        weight： <span class="number">0.2</span>		<span class="comment">// 权重大小，越大越优先调用， 默认为1 使用时建议在一个集群底下</span></span><br><span class="line">    loadbalancer:</span><br><span class="line">      nacos:</span><br><span class="line">        enabled: <span class="literal">true</span>	<span class="comment">// 开启负载均衡</span></span><br></pre></td></tr></table></figure>

<h3 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1732512781202-dbd51330-3f89-4bb5-b5ab-614f19301dd0.png"></p>
<ol>
<li>设置Date ID： 默认为程序名-dev.yml</li>
<li>将需要配置的内容放置下方</li>
<li>删除原程序中yml 的配置内容</li>
<li>导入配置管理依赖</li>
<li>添加bootstrap.yml 添加配置信息</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: user-service</span><br><span class="line">  profiles:</span><br><span class="line">    # 环境与配置文件保持一致</span><br><span class="line">    active: dev</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      config:</span><br><span class="line">        # 配置文件的后缀名</span><br><span class="line">        file-extension: yml</span><br><span class="line">        # nacos配置中心服务器地址</span><br><span class="line">        server-addr: localhost:<span class="number">8848</span></span><br></pre></td></tr></table></figure>

<p>程序会实时监听配置类的信息，判断你是否添加新的配置进去。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1732513012294-76b6a088-adc1-4a44-b8b1-85d2f18402a3.png"></p>
<p>这里我添加了一个zzh的新值进去，idea程序实时监听</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1732513054194-c1f7b7c7-64dc-45fc-974b-9da6faf6ffff.png"></p>
<p>但此时你无法读取到配置的改变，如果想实时刷新配置内容并使用需要添加注解实现热更新</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1732513112573-906217c5-17db-49d1-aef7-5acd35cef806.png"></p>
<p><strong><font style="color:rgb(44, 62, 80);">注意：Nacos的配置项优先级高于application.propertite里面的配置。</font></strong></p>
<h3 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1732512664743-b19eaeea-f1f9-45d0-a84a-418e61a2eada.png"><br>服务管理分集群使用，如果设置了<code> ephemeral: false</code> 临时实例为<code>false</code></p>
<p><strong>集群分区</strong>通过 <code>cluster-name: &#39;集群名字&#39;</code>来实现集群</p>
<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>通过添加命名空间获取ID</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1732515676058-66ce7491-3517-4504-a6cb-7a3846dcaaa5.png"></p>
<p>在application.yml添加此id进去</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cloud:</span><br><span class="line">  nacos:</span><br><span class="line">    discovery:</span><br><span class="line">      server-addr: localhost:<span class="number">8848</span></span><br><span class="line">      cluster-name: Guangzhou</span><br><span class="line">      # 命名空间</span><br><span class="line">      namespace: <span class="number">31989985</span>-d3f3-<span class="number">473f</span>-bb16-ad36c8624be8</span><br><span class="line">      # 分组</span><br><span class="line">      group: info</span><br></pre></td></tr></table></figure>

<p>如果程序之间不在同一个命名空间或者分组下则无法访问，需要两者皆一致</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1732515580279-0380db69-c029-47ec-8fdc-9d37f6c6667a.png"></p>
<h3 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h3><p><a href="https://nacos.io/docs/latest/manual/admin/deployment/deployment-cluster/">集群模式部署</a></p>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ul>
<li><strong>集群环境</strong>：如果是 Nacos 集群环境，那么拓扑结构是什么样的。</li>
<li><strong>组装请求</strong>：客户端组装注册请求，下一步对 Nacos 服务发起远程调用。</li>
<li><strong>随机节点</strong>：客户端随机选择集群中的一个 Nacos 节点发起注册，实现负载均衡。</li>
<li><strong>路由转发</strong>：Nacos 节点收到注册请求后，看下是不是属于自己的，不是的话，就进行路由转发。</li>
<li><strong>处理请求</strong>：转发给指定的节点后，该节点就会将注册请求中的实例信息解析出来，存到自定义的内存结构中。</li>
<li><strong>最终一致性</strong>：通过 Nacos 自研的 Distro 协议执行<code>延迟异步任务</code>，将注册信息同步给集群中的其他节点，保证了数据的最终一致性。</li>
<li><strong>异步重试</strong>：如果注册失败，客户端将会切换 Nacos 节点，再次发起注册请求，保证高可用性。</li>
</ul>
<h2 id="GateWay"><a href="#GateWay" class="headerlink" title="GateWay"></a>GateWay</h2><p>创建新模块，导入依赖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-loadbalancer&lt;/artifactId&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>注册nacos</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:  # 注册nacos</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: localhost:<span class="number">8848</span></span><br><span class="line">        namespace: <span class="number">31989985</span>-d3f3-<span class="number">473f</span>-bb16-ad36c8624be8</span><br><span class="line">    gateway:</span><br><span class="line">      # 配置路由，注意這裡是個列表，每一項都很重要</span><br><span class="line">      routes:</span><br><span class="line">        - id: borrow-service # 路由名稱</span><br><span class="line">          uri: lb:<span class="comment">//borrow-service # 路由地址， lb表示负载均衡到服务器，也可以使用http正常转发</span></span><br><span class="line">          predicates: # 路由规则 规定什么请求会被路由</span><br><span class="line">            - Path=/borrow<span class="comment">/** # 只要访问这个路径下，一律被路由上面指定的服务</span></span><br><span class="line"><span class="comment">        - id: user-service</span></span><br><span class="line"><span class="comment">          uri: lb://user-service</span></span><br><span class="line"><span class="comment">          predicates:</span></span><br><span class="line"><span class="comment">            - Path=/user/**</span></span><br><span class="line"><span class="comment">  application:</span></span><br><span class="line"><span class="comment">    name: gateway-service</span></span><br></pre></td></tr></table></figure>

<p>路由名称是按照当前模块的application.name而定的。</p>
<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><h4 id="局部过滤器"><a href="#局部过滤器" class="headerlink" title="局部过滤器"></a>局部过滤器</h4><p><font style="color:rgb(44, 62, 80);">局部过滤器，应用在单个路由或一组路由上的过滤器。标红色表示比较常用的过滤器。</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1732589561063-f0490508-5fae-4469-92b9-0f286410f3e8.png"></p>
<p>在配置文件中添加filters属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:  # 注册nacos</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: localhost:<span class="number">8848</span></span><br><span class="line">        namespace: <span class="number">31989985</span>-d3f3-<span class="number">473f</span>-bb16-ad36c8624be8</span><br><span class="line">    gateway:</span><br><span class="line">      # 配置路由，注意這裡是個列表，每一項都很重要</span><br><span class="line">      routes:</span><br><span class="line">        - id: borrow-service # 路由名稱</span><br><span class="line">          uri: lb:<span class="comment">//borrow-service # 路由地址， lb表示负载均衡到服务器，也可以使用http正常转发</span></span><br><span class="line">          predicates: # 路由规则 规定什么请求会被路由</span><br><span class="line">            - Path=/borrow<span class="comment">/** # 只要访问这个路径下，一律被路由上面指定的服务</span></span><br><span class="line"><span class="comment">        - id: user-service</span></span><br><span class="line"><span class="comment">          uri: lb://user-service</span></span><br><span class="line"><span class="comment">          predicates:</span></span><br><span class="line"><span class="comment">            - Path=/user/**</span></span><br><span class="line"><span class="comment">          filters:</span></span><br><span class="line"><span class="comment">            - AddRequestHeader=Test, helloworld # 添加请求头</span></span><br><span class="line"><span class="comment">  application:</span></span><br><span class="line"><span class="comment">    name: gateway-service</span></span><br></pre></td></tr></table></figure>

<h4 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h4><p><font style="color:rgb(44, 62, 80);">全局过滤器最常见的用法是进行负载均衡，上图的uri:lb。。。就是全局过滤</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">// 全局过滤</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        ServerHttpRequest request= exchange.getRequest();</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeaders().getFirst(<span class="string">&quot;token&quot;</span>); <span class="comment">// 获取头文件中的token</span></span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.isEmpty(token))&#123; <span class="comment">// 判断token是否存在</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;admin&quot;</span>.equals(token))&#123; <span class="comment">// 判断token是否等于admin</span></span><br><span class="line">                <span class="keyword">return</span> chain.filter(exchange); <span class="comment">// 是就继续执行</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED); <span class="comment">// 设置状态码</span></span><br><span class="line">        <span class="keyword">return</span> exchange.getResponse().setComplete(); <span class="comment">// 不往下执行，直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，过滤器肯定是可以存在很多个的，所以我们可以手动指定过滤器之间的顺序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;   <span class="comment">//实现Ordered接口</span></span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>注意Order的值越小优先级越高，并且无论是在配置文件中编写的单个路由过滤器还是全局路由过滤器，都会受到Order值影响（单个路由的过滤器Order值按从上往下的顺序从1开始递增），最终是按照Order值决定哪个过滤器优先执行，当Order值一样时 全局路由过滤器执行 <code>优于</code> 单独的路由过滤器执行。</p>
<h3 id="设计网关，需要考虑哪些？"><a href="#设计网关，需要考虑哪些？" class="headerlink" title="设计网关，需要考虑哪些？"></a>设计网关，需要考虑哪些？</h3><p>如果让你设计一个 API 网关，你会考虑哪些方面？</p>
<h4 id="路由转发"><a href="#路由转发" class="headerlink" title="路由转发"></a>路由转发</h4><p>请求先到达 API 网关，然后经过断言，匹配到路由后，由路由将请求转发给真正的业务服务。</p>
<h4 id="注册发现"><a href="#注册发现" class="headerlink" title="注册发现"></a>注册发现</h4><p>各个服务实例需要将自己的服务名、IP 地址和 port 注册到注册中心，然后注册中心会存放一份注册表，Gateway 可以从注册中心获取到注册表，然后转发请求时只需要转发到对应的服务名即可。</p>
<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>一个服务可以由多个服务实例组成服务集群，而 Gateway 配置的通常是一个服务名，如 passjava-member 服务，所以需要具备负载均衡功能，将请求分发到不同的服务实例上。</p>
<h4 id="弹力设计"><a href="#弹力设计" class="headerlink" title="弹力设计"></a>弹力设计</h4><p>网关还可以把弹力设计中的那些异步、重试、幂等、流控、熔断、监视等都可以实现进去。这样，同样可以像 Service Mesh 那样，让应用服务只关心自己的业务逻辑（或是说数据面上的事）而不是控制逻辑（控制面）。</p>
<h4 id="安全方面"><a href="#安全方面" class="headerlink" title="安全方面"></a>安全方面</h4><p>SSL 加密及证书管理、Session 验证、授权、数据校验，以及对请求源进行恶意攻击的防范。错误处理越靠前的位置就是越好，所以，网关可以做到一个全站的接入组件来对后端的服务进行保护。当然，网关还可以做更多更有趣的事情，比如：灰度发布、API聚合、API编排。</p>
<h5 id="灰度发布"><a href="#灰度发布" class="headerlink" title="灰度发布"></a>灰度发布</h5><p>网关完全可以做到对相同服务不同版本的实例进行导流，还可以收集相关的数据。这样对于软件质量的提升，甚至产品试错都有非常积极的意义。</p>
<h5 id="API-聚合"><a href="#API-聚合" class="headerlink" title="API 聚合"></a>API 聚合</h5><p>使用网关可以将多个单独请求聚合成一个请求。在微服务体系的架构中，因为服务变小了，所以一个明显的问题是，客户端可能需要多次请求才能得到所有的数据。这样一来，客户端与后端之间的频繁通信会对应用程序的性能和规模产生非常不利的影响。于是，我们可以让网关来帮客户端请求多个后端的服务（有些场景下完全可以并发请求），然后把后端服务的响应结果拼装起来，回传给客户端（当然，这个过程也可以做成异步的，但这需要客户端的配合）。</p>
<h5 id="API-编排"><a href="#API-编排" class="headerlink" title="API 编排"></a>API 编排</h5><p>同样在微服务的架构下，要走完一个完整的业务流程，我们需要调用一系列 API，就像一种工作流一样，这个事完全可以通过网页来编排这个业务流程。我们可能通过一个 DSL 来定义和编排不同的 API，也可以通过像 AWS Lambda 服务那样的方式来串联不同的 API。</p>
<h3 id="网关设计重点"><a href="#网关设计重点" class="headerlink" title="网关设计重点"></a>网关设计重点</h3><h4 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h4><p>在技术设计上，网关不应该也不能成为性能的瓶颈。对于高性能，最好使用高性能的编程语言来实现，如 C、C++、Go 和 Java。网关对后端的请求，以及对前端的请求的服务一定要使用异步非阻塞的 I&#x2F;O 来确保后端延迟不会导致应用程序中出现性能问题。C 和 C++ 可以参看 Linux 下的 epoll 和 Windows 的 I&#x2F;O Completion Port 的异步 IO 模型，Java 下如 Netty、Spring Reactor 的 NIO 框架。</p>
<h4 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h4><p>因为所有的流量或调用经过网关，所以网关必须成为一个高可用的技术组件，它的稳定直接关系到了所有服务的稳定。网关如果没有设计，就会成变一个单点故障。因此，一个好的网关至少要做到以下几点。</p>
<ul>
<li><strong>集群化</strong>。网关要成为一个集群，其最好可以自己组成一个集群，并可以自己同步集群数据，而不需要依赖于一个第三方系统来同步数据。</li>
<li><strong>服务化</strong>。网关还需要做到在不间断的情况下修改配置，一种是像 Nginx reload 配置那样，可以做到不停服务，另一种是最好做到服务化。也就是说，得要有自己的 Admin API 来在运行时修改自己的配置。</li>
<li><strong>持续化</strong>。比如重启，就是像 Nginx 那样优雅地重启。有一个主管请求分发的主进程。当我们需要重启时，新的请求被分配到新的进程中，而老的进程处理完正在处理的请求后就退出。</li>
</ul>
<p>高可用性涵盖了内部和外部的各种不确定因素，这里讲一下网关系统在高可用性方面做的努力。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1732590488499-9411e4b3-e877-4f04-82f4-a4ee3cda2b50.png"></p>
<h4 id="高扩展"><a href="#高扩展" class="headerlink" title="高扩展"></a>高扩展</h4><p>因为网关需要承接所有的业务流量和请求，所以一定会有或多或少的业务逻辑。而我们都知道，业务逻辑是多变和不确定的。比如，需要在网关上加入一些和业务相关的东西。因此，一个好的 Gateway 还需要是可以扩展的，并能进行二次开发的。当然，像 Nginx 那样通过 Module 进行二次开发的固然可以。</p>
<p>另外，在<strong>运维方面</strong>，网关应该有以下几个设计原则。</p>
<ul>
<li><strong>业务松耦合，协议紧耦合</strong>。在业务设计上，网关不应与后面的服务之间形成服务耦合，也不应该有业务逻辑。网关应该是在网络应用层上的组件，不应该处理通讯协议体，只应该解析和处理通讯协议头。另外，除了服务发现外，网关不应该有第三方服务的依赖。</li>
<li><strong>应用监视，提供分析数据</strong>。网关上需要考虑应用性能的监控，除了有相应后端服务的高可用的统计之外，还需要使用 Tracing ID 实施分布式链路跟踪，并统计好一定时间内每个 API 的吞吐量、响应时间和返回码，以便启动弹力设计中的相应策略。</li>
<li><strong>用弹力设计保护后端服务</strong>。网关上一定要实现熔断、限流、重试和超时等弹力设计。如果一个或多个服务调用花费的时间过长，那么可接受超时并返回一部分数据，或是返回一个网关里的缓存的上一次成功请求的数据。你可以考虑一下这样的设计。</li>
<li><strong>DevOps</strong>。因为网关这个组件太关键了，所以需要 DevOps 这样的东西，将其发生故障的概率降到最低。这个软件需要经过精良的测试，包括功能和性能的测试，还有浸泡测试。还需要有一系列自动化运维的管控工具。</li>
</ul>
<h3 id="网关设计注意事项"><a href="#网关设计注意事项" class="headerlink" title="网关设计注意事项"></a>网关设计注意事项</h3><ol>
<li>不要在网关中的代码里内置聚合后端服务的功能，而应考虑将聚合服务放在网关核心代码之外。可以使用 Plugin 的方式，也可以放在网关后面形成一个 Serverless 服务。</li>
<li>网关应该靠近后端服务，并和后端服务使用同一个内网，这样可以保证网关和后端服务调用的低延迟，并可以减少很多网络上的问题。这里多说一句，网关处理的静态内容应该靠近用户（应该放到 CDN 上），而网关和此时的动态服务应该靠近后端服务。</li>
<li>网关也需要做容量扩展，所以需要成为一个集群来分担前端带来的流量。这一点，要么通过 DNS 轮询的方式实现，要么通过 CDN 来做流量调度，或者通过更为底层的性能更高的负载均衡设备。</li>
<li>对于服务发现，可以做一个时间不长的缓存，这样不需要每次请求都去查一下相关的服务所在的地方。当然，如果你的系统不复杂，可以考虑把服务发现的功能直接集成进网关中。</li>
<li>为网关考虑 bulkhead 设计方式。用不同的网关服务不同的后端服务，或是用不同的网关服务前端不同的客户。</li>
</ol>
<p>另外，因为网关是为用户请求和后端服务的桥接装置，所以需要考虑一些安全方面的事宜。具体如下：</p>
<ol>
<li><strong>加密数据</strong>。可以把 SSL 相关的证书放到网关上，由网关做统一的 SSL 传输管理。</li>
<li><strong>校验用户的请求</strong>。一些基本的用户验证可以放在网关上来做，比如用户是否已登录，用户请求中的 token 是否合法等。但是，我们需要权衡一下，网关是否需要校验用户的输入。因为这样一来，网关就需要从只关心协议头，到需要关心协议体。而协议体中的东西一方面不像协议头是标准的，另一方面解析协议体还要耗费大量的运行时间，从而降低网关的性能。对此，我想说的是，看具体需求，一方面如果协议体是标准的，那么可以干；另一方面，对于解析协议所带来的性能问题，需要做相应的隔离。</li>
<li><strong>检测异常访问</strong>。网关需要检测一些异常访问，比如，在一段比较短的时间内请求次数超过一定数值；还比如，同一客户端的 4xx 请求出错率太高……对于这样的一些请求访问，网关一方面要把这样的请求屏蔽掉，另一方面需要发出警告，有可能会是一些比较重大的安全问题，如被黑客攻击。</li>
</ol>
<h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><p><font style="color:#000000;background-color:rgba(255, 255, 255, 0);">随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</font></p>
<p>Sentinel 具有以下特征:</p>
<ul>
<li><strong>丰富的应用场景</strong><font style="color:#000000;background-color:rgba(255, 255, 255, 0);">：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。</font></li>
<li><strong>完备的实时监控</strong><font style="color:#000000;background-color:rgba(255, 255, 255, 0);">：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。</font></li>
<li><strong>广泛的开源生态</strong><font style="color:#000000;background-color:rgba(255, 255, 255, 0);">：Sentinel 提供开箱即用的与其它开源框架&#x2F;库的整合模块，例如与 Spring Cloud、Apache Dubbo、gRPC、Quarkus 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。同时 Sentinel 提供 Java&#x2F;Go&#x2F;C++ 等多语言的原生实现。</font></li>
<li><strong>完善的 SPI 扩展机制</strong><font style="color:#000000;background-color:rgba(255, 255, 255, 0);">：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。</font></li>
</ul>
<p><font style="color:#000000;background-color:rgba(255, 255, 255, 0);"></font></p>
<p><font style="color:#000000;background-color:rgba(255, 255, 255, 0);">Sentinel控制台下载：</font><a href="https://github.com/alibaba/Sentinel/releases">Releases · alibaba&#x2F;Sentinel</a></p>
<h3 id="依赖导入"><a href="#依赖导入" class="headerlink" title="依赖导入"></a>依赖导入</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1732530728726-48da0106-dc1e-4d01-8cc2-d6d18a91c552.png"></p>
<p><strong>yml配置</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: userservice</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: localhost:<span class="number">8848</span></span><br><span class="line">    sentinel:</span><br><span class="line">      transport:</span><br><span class="line">      	# 添加监控页面地址即可</span><br><span class="line">        dashboard: localhost:<span class="number">8858</span></span><br></pre></td></tr></table></figure>

<p>配置完，即可进入控制台。</p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><h4 id="限流策略"><a href="#限流策略" class="headerlink" title="限流策略"></a>限流策略</h4><ul>
<li><font style="color:#000000;background-color:rgba(255, 255, 255, 0);">方案一：</font><strong><font style="color:#000000;background-color:rgba(255, 255, 255, 0);">快速拒绝</font></strong><font style="color:#000000;background-color:rgba(255, 255, 255, 0);">，既然不再接受新的请求，那么我们可以直接返回一个拒绝信息，告诉用户访问频率过高。</font></li>
<li><font style="color:#000000;background-color:rgba(255, 255, 255, 0);">方案二：</font><strong><font style="color:#000000;background-color:rgba(255, 255, 255, 0);">预热</font></strong><font style="color:#000000;background-color:rgba(255, 255, 255, 0);">，依然基于方案一，但是由于某些情况下高并发请求是在某一时刻突然到来，我们可以缓慢地将阈值提高到指定阈值，形成一个缓冲保护。</font></li>
<li><font style="color:#000000;background-color:rgba(255, 255, 255, 0);">方案三：</font><strong><font style="color:#000000;background-color:rgba(255, 255, 255, 0);">排队等待</font></strong><font style="color:#000000;background-color:rgba(255, 255, 255, 0);">，不接受新的请求，但是也不直接拒绝，而是进队列先等一下，如果规定时间内能够执行，那么就执行，要是超时就算了。</font></li>
</ul>
<h4 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a><font style="color:#000000;background-color:rgba(255, 255, 255, 0);">限流算法</font></h4><p><strong>漏桶算法</strong></p>
<p>顾名思义，就像一个桶开了一个小孔，水流进桶中的速度肯定是远大于水流出桶的速度的，这也是最简单的一种限流思路：</p>
<ul>
<li><img src="https://cdn.nlark.com/yuque/0/2024/webp/34596451/1732535005870-30bf134c-5fd7-4bb3-ae40-8fe3af9ec69d.webp"></li>
</ul>
<p>我们知道，桶是有容量的，所以当桶的容量已满时，就装不下水了，这时就只有丢弃请求了。</p>
<p>利用这种思想，我们就可以写出一个简单的限流算法。</p>
<p><strong>令牌桶算法</strong></p>
<p>只能说有点像信号量机制。现在有一个令牌桶，这个桶是专门存放令牌的，每隔一段时间就向桶中丢入一个令牌（速度由我们指定）当新的请求到达时，将从桶中删除令牌，接着请求就可以通过并给到服务，但是如果桶中的令牌数量不足，那么不会删除令牌，而是让此数据包等待。</p>
<ul>
<li><img src="https://cdn.nlark.com/yuque/0/2024/webp/34596451/1732535005889-fde6ba3d-9672-4050-917d-4edc95a7d7fd.webp"></li>
</ul>
<p>可以试想一下，当流量下降时，令牌桶中的令牌会逐渐积累，这样如果突然出现高并发，那么就能在短时间内拿到大量的令牌。</p>
<p><strong>固定时间窗口算法</strong></p>
<p>我们可以对某一个时间段内的请求进行统计和计数，比如在<code>14:15</code>到<code>14:16</code>这一分钟内，请求量不能超过<code>100</code>，也就是一分钟之内不能超过<code>100</code>次请求，那么就可以像下面这样进行划分：</p>
<ul>
<li><img src="https://cdn.nlark.com/yuque/0/2024/webp/34596451/1732535005938-8d860c74-522c-4ea5-a6a6-a564ec831200.webp"></li>
</ul>
<p>虽然这种模式看似比较合理，但是试想一下这种情况：</p>
<ul>
<li>14:15:59的时候来了100个请求</li>
<li>14:16:01的时候又来了100个请求</li>
</ul>
<p>出现上面这种情况，符合固定时间窗口算法的规则，所以这200个请求都能正常接受，但是，如果你反应比较快，应该发现了，我们其实希望的是60秒内只有100个请求，但是这种情况却是在3秒内出现了200个请求，很明显已经违背了我们的初衷。</p>
<p>因此，当遇到临界点时，固定时间窗口算法存在安全隐患。</p>
<p><strong>滑动时间窗口算法</strong></p>
<p>相对于固定窗口算法，滑动时间窗口算法更加灵活，它会动态移动窗口，重新进行计算：</p>
<ul>
<li><img src="https://cdn.nlark.com/yuque/0/2024/webp/34596451/1732535005932-1223c243-f6b9-4435-9d00-63c2d6df51bb.webp"></li>
</ul>
<p>虽然这样能够避免固定时间窗口的临界问题，但是这样显然是比固定窗口更加耗时的。</p>
<h4 id="限流模式"><a href="#限流模式" class="headerlink" title="限流模式"></a>限流模式</h4><ul>
<li><font style="color:#000000;">直接：只针对于当前接口。</font></li>
<li><font style="color:#000000;">关联：当其他接口超过阈值时，会导致当前接口被限流。 绑定某个接口，当其限流时，自身也限流</font></li>
<li><font style="color:#000000;">链路：更细粒度的限流，能精确到具体的方法。</font><ul>
<li><font style="color:#000000;">需要对特定方法进行注入注解SentinelResource(value &#x3D; “方法名”) ，监控当前方法</font></li>
<li><font style="color:#000000;">在yml文件关闭Context收敛， 这样可以进行不同链路的单独控制</font></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: borrowservice</span><br><span class="line">  cloud:</span><br><span class="line">    sentinel:</span><br><span class="line">      transport:</span><br><span class="line">        dashboard: localhost:<span class="number">8858</span></span><br><span class="line">      # 关闭Context收敛，这样被监控方法可以进行不同链路的单独控制</span><br><span class="line">      web-context-unify: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1732535239901-d5e0c042-4ce0-457c-8baa-1209e8115089.png"><br>如上图所示，现在只对borrow2&#x2F;{uid}方法进行限流，borrow&#x2F;{uid}不受限流影响</p>
<p>除了直接对接口进行限流规则控制之外，我们也可以根据当前系统的资源使用情况，决定是否进行限流：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/webp/34596451/1732535301833-63c32b2a-5b5d-452d-82d3-fd530d48e885.webp"></p>
<p>系统规则支持以下的模式：</p>
<ul>
<li><strong>Load 自适应</strong>（仅对 Linux&#x2F;Unix-like 机器生效）：系统的 load1 作为启发指标，进行自适应系统保护。当系统 load1 超过设定的启发值，且系统当前的并发线程数超过估算的系统容量时才会触发系统保护（BBR 阶段）。系统容量由系统的 <code>maxQps * minRt</code> 估算得出。设定参考值一般是 <code>CPU cores * 2.5</code>。</li>
<li><strong>CPU usage</strong>（1.5.0+ 版本）：当系统 CPU 使用率超过阈值即触发系统保护（取值范围 0.0-1.0），比较灵敏。</li>
<li><strong>平均 RT</strong>：当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。</li>
<li><strong>并发线程数</strong>：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。</li>
<li><strong>入口 QPS</strong>：当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护。</li>
</ul>
<h3 id="限流异常处理"><a href="#限流异常处理" class="headerlink" title="限流异常处理"></a>限流异常处理</h3><h4 id="限流页面跳转"><a href="#限流页面跳转" class="headerlink" title="限流页面跳转"></a>限流页面跳转</h4><p>首先需要在控制层添加限流返回的信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/blocked&quot;)</span></span><br><span class="line">    JSONObject <span class="title function_">blocked</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">        jsonObject.put(<span class="string">&quot;code&quot;</span>,<span class="number">403</span>);</span><br><span class="line">        jsonObject.put(<span class="string">&quot;success&quot;</span>,<span class="literal">false</span>);</span><br><span class="line">        jsonObject.put(<span class="string">&quot;message&quot;</span>,<span class="string">&quot;你的请求频率过快，请稍后再试&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> jsonObject;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(93, 93, 93);">接着我们在配置文件中将此页面设定为限流页面：</font></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8858</span></span><br><span class="line">      <span class="comment"># 将刚刚编写的请求映射设定为限流页面</span></span><br><span class="line">      <span class="attr">block-page:</span> <span class="string">/blocked</span></span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(93, 93, 93);">这样，当被限流时，就会被重定向到指定页面：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1732536464828-23e60bc7-fd7f-4ace-b47e-3cbde9382c1c.png"></p>
<h4 id="限流方法处理"><a href="#限流方法处理" class="headerlink" title="限流方法处理"></a>限流方法处理</h4><p>当某个方法被限流时，会直接在后台抛出异常，这个时候我们需要通过注解，利用替代方法返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;getBorrow&quot;, blockHandler = &quot;blocked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> UserBorrowDetail <span class="title function_">getUserBorrowDetailByUid</span><span class="params">(<span class="type">int</span> uid)</span> &#123;</span><br><span class="line">        List&lt;Borrow&gt; borrow = mapper.getBorrowsByUid(uid);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userClient.getUserById(uid);</span><br><span class="line">        <span class="comment">//获取每一本书的详细信息</span></span><br><span class="line">        List&lt;Book&gt; bookList = borrow</span><br><span class="line">                .stream()</span><br><span class="line">                .map(b -&gt; bookClient.getBookById(b.getBid()))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserBorrowDetail</span>(user, bookList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//替代方案，注意参数和返回值需要保持一致，并且参数最后还需要额外添加一个BlockException</span></span><br><span class="line">    <span class="keyword">public</span> UserBorrowDetail <span class="title function_">blocked</span><span class="params">(<span class="type">int</span> uid, BlockException e)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserBorrowDetail</span>(<span class="literal">null</span>, Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;test&quot;,</span></span><br><span class="line"><span class="meta">        fallback = &quot;except&quot;,    //fallback指定出现异常时的替代方案</span></span><br><span class="line"><span class="meta">        blockHandler = &quot;blocked&quot;, // 限流出现的情况</span></span><br><span class="line"><span class="meta">        exceptionsToIgnore = IOException.class)</span>  <span class="comment">//忽略那些异常，也就是说这些异常出现时不使用替代方案</span></span><br></pre></td></tr></table></figure>

<p>通过blockHandler 绑定 blocked方法，当抛出异常时则进行该方法。需要注意参数需要<strong>携带BlockException！！！ 当出现blockedHandler和fallback都存在时，优先执行blockHandler的方法</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1732536740579-ac861fc2-ba48-409b-b337-c02c10b5f162.png" alt="执行结果"></p>
<h3 id="热点参数限流"><a href="#热点参数限流" class="headerlink" title="热点参数限流"></a>热点参数限流</h3><p>创建一个参数多的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="meta">@SentinelResource(&quot;test&quot;)</span>   <span class="comment">//注意这里需要添加@SentinelResource才可以，用户资源名称就使用这里定义的资源名称</span></span><br><span class="line">    String <span class="title function_">findUserBorrows2</span><span class="params">(<span class="meta">@RequestParam(value = &quot;a&quot;, required = false)</span> String a,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;b&quot;, required = false)</span> String b,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;c&quot;,required = false)</span> String c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;请求成功！a = &quot;</span>+a+<span class="string">&quot;, b = &quot;</span>+b+<span class="string">&quot;, c = &quot;</span>+c;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>限流显示<br><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1732538376600-b3b14aa6-69f8-4111-af2c-78073a8bed20.png"></p>
<p>热点规则设置</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1732538343944-a63f8092-1001-44be-a1d8-7e42761ef941.png"></p>
<h3 id="服务熔断和降级"><a href="#服务熔断和降级" class="headerlink" title="服务熔断和降级"></a>服务熔断和降级</h3><p><font style="color:rgb(93, 93, 93);">在整个微服务调用链路出现问题的时候，及时对服务进行降级，以防止问题进一步恶化。</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/webp/34596451/1732541247283-fbc062e9-642e-4e61-9c2b-9c06ca8afa53.webp"></p>
<p><font style="color:rgb(93, 93, 93);">如果在某一时刻，服务B出现故障（可能就卡在那里了），而这时服务A依然有大量的请求，在调用服务B，那么，由于服务A没办法再短时间内完成处理，新来的请求就会导致线程数不断地增加，这样，CPU的资源很快就会被耗尽。</font></p>
<h4 id="隔离方式"><a href="#隔离方式" class="headerlink" title="隔离方式"></a><font style="color:rgb(93, 93, 93);">隔离方式</font></h4><p><strong><font style="color:rgb(93, 93, 93);">1.线程池隔离</font></strong></p>
<p><font style="color:rgb(93, 93, 93);">线程池隔离实际上就是对每个服务的远程调用单独开放线程池，比如服务A要调用服务B，那么只基于固定数量的线程池，这样即使在短时间内出现大量请求，由于没有线程可以分配，所以就不会导致资源耗尽了。</font></p>
<p><strong><font style="color:rgb(93, 93, 93);">2.信号量隔离</font></strong></p>
<p><font style="color:rgb(93, 93, 93);">信号量隔离是使用</font><code>Semaphore</code><font style="color:rgb(93, 93, 93);">类实现的（如果不了解，可以观看本系列 并发编程篇 视频教程），思想基本上与上面是相同的，也是限定指定的线程数量能够同时进行服务调用，但是它相对于线程池隔离，开销会更小一些，使用效果同样优秀，也支持超时等。Sentinel也正是采用的这种方案实现隔离的。</font></p>
<p>因此，<font style="color:rgb(93, 93, 93);">当下游服务因为某种原因变得不可用或响应过慢时，上游服务为了保证自己整体服务的可用性，不再继续调用目标服务而是快速返回或是执行自己的替代方案，这便是服务降级。</font></p>
<h4 id="服务降级状态"><a href="#服务降级状态" class="headerlink" title="服务降级状态"></a><font style="color:rgb(93, 93, 93);">服务降级状态</font></h4><p><font style="color:rgb(93, 93, 93);">整个过程分为三个状态：</font></p>
<ul>
<li><font style="color:rgb(93, 93, 93);">关闭：熔断器不工作，所有请求全部该干嘛干嘛。</font></li>
<li><font style="color:rgb(93, 93, 93);">打开：熔断器工作，所有请求一律降级处理。</font></li>
<li><font style="color:rgb(93, 93, 93);">半开：尝试进行一下下正常流程，要是还不行继续保持打开状态，否则关闭。</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1732541380241-88eb3345-0685-4f4e-9411-9ec3f8be6042.png"></p>
<h4 id="熔断策略"><a href="#熔断策略" class="headerlink" title="熔断策略"></a>熔断策略</h4><h5 id="慢调用比例"><a href="#慢调用比例" class="headerlink" title="慢调用比例"></a>慢调用比例</h5><p><font style="color:rgb(93, 93, 93);"> 如果出现那种半天都处理不完的调用，有可能就是服务出现故障，导致卡顿，这个选项是按照最大响应时间（RT）进行判定，如果一次请求的处理时间超过了指定的RT，那么就被判定为</font><code>慢调用</code><font style="color:rgb(93, 93, 93);">，在一个统计时长内，如果请求数目大于最小请求数目，并且被判定为</font><code>慢调用</code><font style="color:rgb(93, 93, 93);">的请求比例已经超过阈值，将触发熔断。经过熔断时长之后，将会进入到半开状态进行试探</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/borrow2/&#123;uid&#125;&quot;)</span></span><br><span class="line">UserBorrowDetail <span class="title function_">findUserBorrows2</span><span class="params">(<span class="meta">@PathVariable(&quot;uid&quot;)</span> <span class="type">int</span> uid)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1732541540825-53ed86b3-dc14-4260-8ee5-bee14655c6c9.png"></p>
<p><font style="color:rgb(93, 93, 93);">此时超时则会直接触发熔断机制，进入阻止页面。</font></p>
<h5 id="异常比例"><a href="#异常比例" class="headerlink" title="异常比例"></a><font style="color:rgb(93, 93, 93);">异常比例</font></h5><p><font style="color:rgb(93, 93, 93);"> 这个与慢调用比例类似，不过这里判断的是出现异常的次数</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1732541644659-cf4ea51b-b449-414d-9f5b-02b348de6bd9.png"></p>
<h5 id="异常数"><a href="#异常数" class="headerlink" title="异常数"></a>异常数</h5><p><font style="color:rgb(93, 93, 93);">这个和上面的唯一区别就是，只要达到指定的异常数量，就熔断</font></p>
<h4 id="自定义服务降级"><a href="#自定义服务降级" class="headerlink" title="自定义服务降级"></a><font style="color:rgb(93, 93, 93);">自定义服务降级</font></h4><p>和之前限流，出现异常一样，执行替代方案</p>
<p> <strong>我们只需要在</strong><code>**@SentinelResource**</code><strong>中配置</strong><code>**blockHandler**</code><strong>参数</strong>（那这里跟前面那个方法限流的配置不是一毛一样吗？没错，因为如果添加了<code>@SentinelResource</code>注解，那么这里会进行方法级别细粒度的限制，和之前方法级别限流一样，会在降级之后直接抛出异常，如果不添加则返回默认的限流页面，<code>blockHandler</code>的目的就是处理这种Sentinel机制上的异常，所以这里其实和之前的限流配置是一个道理，因此下面熔断配置也应该对<code>value</code>自定义名称的资源进行配置，才能作用到此方法上）：  </p>
<h4 id="整合Feign"><a href="#整合Feign" class="headerlink" title="整合Feign"></a>整合Feign</h4><p><font style="color:rgb(93, 93, 93);">首先需要在配置文件中开启支持：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">feign:</span><br><span class="line">  sentinel:</span><br><span class="line">    enabled: true</span><br></pre></td></tr></table></figure>

<p>然后创建实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookClientImpl</span> <span class="keyword">implements</span> <span class="title class_">BookClient</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">getBookById</span><span class="params">(<span class="type">int</span> bid)</span> &#123;</span><br><span class="line">        <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">        book.setTitle(<span class="string">&quot;替代&quot;</span>);</span><br><span class="line">        book.setDesc(<span class="string">&quot;替代啊&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> book;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现接口添加替代方案实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;book-service&quot;, fallback = BookClientImpl.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookClient</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/book/&#123;bid&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">getBookById</span><span class="params">(<span class="meta">@PathVariable(&quot;bid&quot;)</span> <span class="type">int</span> bid)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后直接启动，中途下线其他服务，就可以看到正常使用替代方案<br><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1732542014329-6cd1ddc1-4c97-4858-a9fe-ea5d2e2b8abf.png"></p>
<h2 id="seata"><a href="#seata" class="headerlink" title="seata"></a>seata</h2><p>单体应用可以通过@<font style="color:rgb(17, 17, 17);">transactional实现回滚，但分布式需要通过Seata实现</font></p>
<p>Seata 对分布式事务的协调和控制，主要是通过 XID 和 3 个核心组件实现的。</p>
<h4 id="XID"><a href="#XID" class="headerlink" title="XID"></a>XID</h4><p><font style="color:rgb(17, 17, 17);">XID 是全局事务的唯一标识，它可以在服务的调用链路中传递，绑定到服务的事务上下文中。</font></p>
<h4 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h4><p><font style="color:rgb(17, 17, 17);">Seata 定义了 3 个核心组件：</font></p>
<ul>
<li><font style="color:rgb(17, 17, 17);">TC（Transaction Coordinator）：事务协调器，它是事务的协调者（这里指的是 Seata 服务器），主要负责维护全局事务和分支事务的状态，驱动全局事务提交或回滚。</font></li>
<li><font style="color:rgb(17, 17, 17);">TM（Transaction Manager）：事务管理器，它是事务的发起者，负责定义全局事务的范围，并根据 TC 维护的全局事务和分支事务状态，做出开始事务、提交事务、回滚事务的决议。</font></li>
<li><font style="color:rgb(17, 17, 17);">RM（Resource Manager）：资源管理器，它是资源的管理者（这里可以将其理解为各服务使用的数据库）。它负责管理分支事务上的资源，向 TC 注册分支事务，汇报分支事务状态，驱动分支事务的提交或回滚。</font></li>
</ul>
<p><font style="color:rgb(17, 17, 17);">以上三个组件相互协作，TC 以 Seata 服务器（Server）形式独立部署，TM 和 RM 则是以 Seata Client 的形式集成在微服务中运行，其整体工作流程如下图。</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1732601959307-9a332c09-ec55-4677-b87e-54991f1af5d9.png"><br>图1：Sentinel 的工作流程</p>
<p>Seata 的整体工作流程如下：</p>
<ol>
<li>TM 向 TC 申请开启一个全局事务，全局事务创建成功后，TC 会针对这个全局事务生成一个全局唯一的 XID；</li>
<li>XID 通过服务的调用链传递到其他服务;</li>
<li>RM 向 TC 注册一个分支事务，并将其纳入 XID 对应全局事务的管辖；</li>
<li>TM 根据 TC 收集的各个分支事务的执行结果，向 TC 发起全局事务提交或回滚决议；</li>
<li>TC 调度 XID 下管辖的所有分支事务完成提交或回滚操作。</li>
</ol>
<h2 id="Seata-AT-模式"><a href="#Seata-AT-模式" class="headerlink" title="Seata AT 模式"></a>Seata AT 模式</h2><hr>
<p>Seata 提供了 AT、TCC、SAGA 和 XA 四种事务模式，可以快速有效地对分布式事务进行控制。</p>
<p>在这四种事务模式中使用最多，最方便的就是 AT 模式。与其他事务模式相比，AT 模式可以应对大多数的业务场景，且基本可以做到无业务入侵，开发人员能够有更多的精力关注于业务逻辑开发。</p>
<h3 id="AT-模式的前提"><a href="#AT-模式的前提" class="headerlink" title="AT 模式的前提"></a>AT 模式的前提</h3><p>任何应用想要使用 Seata 的 AT 模式对分布式事务进行控制，必须满足以下 2 个前提：</p>
<ul>
<li>必须使用支持本地 ACID 事务特性的关系型数据库，例如 MySQL、Oracle 等；</li>
<li>应用程序必须是使用 JDBC 对数据库进行访问的 JAVA 应用。</li>
</ul>
<p>此外，我们还需要针对业务中涉及的各个数据库表，分别创建一个 UNDO_LOG（回滚日志）表。不同数据库在创建 UNDO_LOG 表时会略有不同，以 MySQL 为例，其 UNDO_LOG 表的创表语句如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `undo_log` (</span><br><span class="line">  `id` bigint(<span class="number">20</span>) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `branch_id` bigint(<span class="number">20</span>) NOT NULL,</span><br><span class="line">  `xid` varchar(<span class="number">100</span>) NOT NULL,</span><br><span class="line">  `context` varchar(<span class="number">128</span>) NOT NULL,</span><br><span class="line">  `rollback_info` longblob NOT NULL,</span><br><span class="line">  `log_status` <span class="type">int</span>(<span class="number">11</span>) NOT NULL,</span><br><span class="line">  `log_created` datetime NOT NULL,</span><br><span class="line">  `log_modified` datetime NOT NULL,</span><br><span class="line">  PRIMARY <span class="title function_">KEY</span> <span class="params">(`id`)</span>,</span><br><span class="line">  UNIQUE KEY `ux_undo_log` (`xid`,`branch_id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=<span class="number">1</span> DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>CurrentHashMap</title>
    <url>/2024/11/16/ConcurrentHashMap/</url>
    <content><![CDATA[<h1 id="ConcurrentHashMap-类"><a href="#ConcurrentHashMap-类" class="headerlink" title="ConcurrentHashMap 类"></a>ConcurrentHashMap 类</h1><h2 id="ConcurrentHashMap-1-7"><a href="#ConcurrentHashMap-1-7" class="headerlink" title="ConcurrentHashMap 1.7"></a>ConcurrentHashMap 1.7</h2><p><strong>在 JDK1.7中ConcurrentHashMap采用了数组+分段锁的方式实现</strong>。</p>
<p>Segment(分段锁)-减少锁的粒度</p>
<p>ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表,同时又是一个ReentrantLock（Segment继承了ReentrantLock）。</p>
<h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>Java 7 版本 ConcurrentHashMap 的存储结构如图：</p>
<p><img src="/2024/12/09/hello-world/shMap/image-20220318161208191.png"></p>
<p><img src="/2024/12/09/hello-world/shMap/image-20220318162050021.png"></p>
<p>ConcurrnetHashMap 由很多个 Segment 组合，而每一个 Segment 是一个类似于 HashMap 的结构，所以每一个 HashMap 的内部可以进行扩容。</p>
<p>但是 Segment 的个数一旦初始化就不能改变，默认 Segment 的个数是 16 个，所以可以认为 ConcurrentHashMap 默认支持最多 16 个线程并发。</p>
<hr>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><hr>
<p>通过 ConcurrentHashMap 的无参构造：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Creates a new, empty map with a default initial capacity (16),</span></span><br><span class="line"><span class="comment">* load factor (0.75) and concurrencyLevel (16).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无参构造中调用了有参构造，传入了三个参数的默认值，他们的值是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 默认初始化容量,这个容量指的是Segment 的大小</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 默认负载因子</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 默认并发级别，并发级别指的是Segment桶的个数，默认是16个并发大小</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CONCURRENCY_LEVEL</span> <span class="operator">=</span> <span class="number">16</span>;</span><br></pre></td></tr></table></figure>

<p>Segment 下面 entryset 数组的大小是用 DEFAULT_INITIAL_CAPACITY&#x2F;DEFAULT_CONCURRENCY_LEVEL 求出来的。</p>
<p>接着看下这个有参构造函数的内部实现逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity,<span class="type">float</span> loadFactor, <span class="type">int</span> concurrencyLevel)</span> &#123;</span><br><span class="line">    <span class="comment">// 参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="comment">// 校验并发级别大小，大于 1&lt;&lt;16，重置为 65536</span></span><br><span class="line">    <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">        concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">    <span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line">    <span class="comment">// 2的多少次方</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sshift</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//控制segment数组的大小</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ssize</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 这个循环可以找到 concurrencyLevel 之上最近的 2的次方值</span></span><br><span class="line">    <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">        ++sshift;<span class="comment">//代表ssize左移的次数</span></span><br><span class="line">        ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录段偏移量</span></span><br><span class="line">    <span class="built_in">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">    <span class="comment">// 记录段掩码</span></span><br><span class="line">    <span class="built_in">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 设置容量   判断初始容量是否超过允许的最大容量</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">// c = 容量 / ssize ，默认 16 / 16 = 1，这里是计算每个 Segment 中的类似于 HashMap 的容量</span></span><br><span class="line">    <span class="comment">//求entrySet数组的大小，这个地方需要保证entrySet数组的大小至少可以存储下initialCapacity的容量，假设initialCapacity为33，ssize为16，那么c=2,所以if语句是true，那么c=3,MIN_SEGMENT_TABLE_CAPACITY初始值是2，所以if语句成立，那么cap=4，所以每一个segment的容量初始为4，segment为16，16*4&gt;33成立，entrySet数组的大小也需要是2的幂次方</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> initialCapacity / ssize;</span><br><span class="line">    <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">        ++c;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">    <span class="comment">//Segment 中的类似于 HashMap 的容量至少是2或者2的倍数</span></span><br><span class="line">    <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">        cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// create segments and segments[0]</span></span><br><span class="line">    <span class="comment">// 创建 Segment 数组，设置 segments[0]</span></span><br><span class="line">    Segment&lt;K,V&gt; s0 = <span class="keyword">new</span> <span class="title class_">Segment</span>&lt;K,V&gt;(loadFactor, (<span class="type">int</span>)(cap * loadFactor),</span><br><span class="line">                                       (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">HashEntry</span>[cap]);</span><br><span class="line">    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Segment</span>[ssize];</span><br><span class="line">    UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">    <span class="built_in">this</span>.segments = ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下在 Java 7 中 ConcurrnetHashMap 的初始化逻辑：</p>
<ul>
<li>必要参数校验</li>
<li>校验并发级别 concurrencyLevel 大小，如果大于最大值，重置为最大值。无参构造默认值是 16</li>
<li>寻找并发级别 concurrencyLevel 之上最近的 2 的幂次方值，作为初始化容量大小，默认是 16</li>
<li>记录 segmentShift 偏移量，这个值为【容量 &#x3D; 2 的N次方】中的 N，在后面 Put 时计算位置时会用到，默认是 32 - sshift &#x3D; 28.</li>
<li>记录 segmentMask，默认是 ssize - 1 &#x3D; 16 -1 &#x3D; 15</li>
<li>初始化 segments[0]，默认大小为 2，负载因子 0.75，扩容阀值是 2*0.75&#x3D;1.5，插入第二个值时才会进行扩容。</li>
</ul>
<hr>
<h3 id="put-操作"><a href="#put-操作" class="headerlink" title="put 操作"></a>put 操作</h3><hr>
<p>接着上面的初始化参数继续查看 put 方法源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Maps the specified key to the specified value in this table.</span></span><br><span class="line"><span class="comment"> * Neither the key nor the value can be null.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; The value can be retrieved by calling the &lt;tt&gt;get&lt;/tt&gt; method</span></span><br><span class="line"><span class="comment"> * with a key that is equal to the original key.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment"> *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified key or value is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="comment">// hash 值无符号右移 28位（初始化时获得），然后与 segmentMask=15 做与运算</span></span><br><span class="line">    <span class="comment">// 其实也就是把高4位与segmentMask（1111）做与运算</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// this.segmentMask = ssize - 1;</span></span><br><span class="line">    <span class="comment">//对hash值进行右移segmentShift位，计算元素对应segment中数组下表的位置</span></span><br><span class="line">    <span class="comment">//把hash右移segmentShift，相当于只要hash值的高32-segmentShift位，右移的目的是保留了hash值的高位。然后和segmentMask与操作计算元素在segment数组中的下表</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    <span class="comment">//使用unsafe对象获取数组中第j个位置的值，后面加上的是偏移量</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="literal">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">        <span class="comment">// 如果查找到的 Segment 为空，初始化</span></span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    <span class="comment">//插入segment对象</span></span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the segment for the given index, creating it and</span></span><br><span class="line"><span class="comment"> * recording in segment table (via CAS) if not already present.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k the index</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the segment</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Segment&lt;K,V&gt; <span class="title function_">ensureSegment</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] ss = <span class="built_in">this</span>.segments;</span><br><span class="line">    <span class="type">long</span> <span class="variable">u</span> <span class="operator">=</span> (k &lt;&lt; SSHIFT) + SBASE; <span class="comment">// raw offset</span></span><br><span class="line">    Segment&lt;K,V&gt; seg;</span><br><span class="line">    <span class="comment">// 判断 u 位置的 Segment 是否为null</span></span><br><span class="line">    <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="literal">null</span>) &#123;</span><br><span class="line">        Segment&lt;K,V&gt; proto = ss[<span class="number">0</span>]; <span class="comment">// use segment 0 as prototype</span></span><br><span class="line">        <span class="comment">// 获取0号 segment 里的 HashEntry&lt;K,V&gt; 初始化长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> proto.table.length;</span><br><span class="line">        <span class="comment">// 获取0号 segment 里的 hash 表里的扩容负载因子，所有的 segment 的 loadFactor 是相同的</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">lf</span> <span class="operator">=</span> proto.loadFactor;</span><br><span class="line">        <span class="comment">// 计算扩容阀值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">threshold</span> <span class="operator">=</span> (<span class="type">int</span>)(cap * lf);</span><br><span class="line">        <span class="comment">// 创建一个 cap 容量的 HashEntry 数组</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">HashEntry</span>[cap];</span><br><span class="line">        <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="literal">null</span>) &#123; <span class="comment">// recheck</span></span><br><span class="line">            <span class="comment">// 再次检查 u 位置的 Segment 是否为null，因为这时可能有其他线程进行了操作</span></span><br><span class="line">            Segment&lt;K,V&gt; s = <span class="keyword">new</span> <span class="title class_">Segment</span>&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">            <span class="comment">// 自旋检查 u 位置的 Segment 是否为null</span></span><br><span class="line">            <span class="keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">                   == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 使用CAS 赋值，只会成功一次</span></span><br><span class="line">                <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="literal">null</span>, seg = s))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> seg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的源码分析了 ConcurrentHashMap 在 put 一个数据时的处理流程，下面梳理下具体流程：</p>
<ul>
<li>计算要 put 的 key 的位置，获取指定位置的 Segment。</li>
<li>如果指定位置的 Segment 为空，则初始化这个 Segment.</li>
</ul>
<p>初始化 Segment 流程：</p>
<ul>
<li>检查计算得到的位置的 Segment 是否为null</li>
<li>为 null 继续初始化，使用 Segment[0] 的容量和负载因子创建一个 HashEntry 数组</li>
<li>再次检查计算得到的指定位置的 Segment 是否为null</li>
<li>使用创建的 HashEntry 数组初始化这个 Segment</li>
<li>自旋判断计算得到的指定位置的 Segment 是否为null，使用 CAS 在这个位置赋值为 Segment</li>
<li>Segment.put 插入 key,value 值。</li>
</ul>
<p>上面探究了获取 Segment 段和初始化 Segment 段的操作。</p>
<p>最后一行的 Segment 的 put 方法还没有查看，继续分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">put</span><span class="params">(K key, <span class="type">int</span> hash, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取 ReentrantLock 独占锁，获取不到，scanAndLockForPut 获取。</span></span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="literal">null</span> : scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="comment">// 计算要put的数据位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        <span class="comment">// CAS 获取 index 坐标的值</span></span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 检查是否 key 已经存在，如果存在，则遍历链表寻找位置，找到后替换 value</span></span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// first 有值没说明 index 位置已经有值了，有冲突，链表头插法。</span></span><br><span class="line">                <span class="keyword">if</span> (node != <span class="literal">null</span>)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    node = <span class="keyword">new</span> <span class="title class_">HashEntry</span>&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> count + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 容量大于扩容阀值，小于最大容量，进行扩容</span></span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// index 位置赋值 node，node 可能是一个元素，也可能是一个链表的表头</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 Segment 继承了 ReentrantLock，所以 Segment 内部可以很方便的获取锁，put 流程就用到了这个功能。</p>
<ul>
<li>tryLock() 获取锁，获取不到使用 <code>scanAndLockForPut</code> 方法继续获取</li>
<li>计算 put 的数据要放入的 index 位置，然后获取这个位置上的 HashEntry</li>
<li>遍历 put 新元素，为什么要遍历？因为这里获取的 HashEntry 可能是一个空元素，也可能是链表已存在，所以要区别对待。<ul>
<li>如果这个位置上的 HashEntry 不存在：</li>
<li>如果当前容量大于扩容阀值，小于最大容量，进行扩容</li>
<li>直接头插法插入。</li>
<li>如果这个位置上的 HashEntry 存在：</li>
<li>判断链表当前元素 Key 和 hash 值是否和要 put 的 key 和 hash 值一致。一致则替换值</li>
<li>不一致，获取链表下一个节点，直到发现相同进行值替换，或者链表表里完毕没有相同的。<ul>
<li>如果当前容量大于扩容阀值，小于最大容量，进行扩容</li>
<li>直接链表头插法插入</li>
</ul>
</li>
</ul>
</li>
<li>如果要插入的位置之前已经存在，替换后返回旧值，否则返回 null</li>
</ul>
<p>这里面的第一步中的 <code>scanAndLockForPut</code> 操作这里没有介绍，这个方法做的操作就是不断的自旋 <code>tryLock()</code> 获取锁。</p>
<p>当自旋次数大于指定次数时，使用 <code>lock()</code> 阻塞获取锁。在自旋时顺表获取下 hash 位置的 HashEntry。</p>
<p>下面结合源码查看一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title function_">scanAndLockForPut</span><span class="params">(K key, <span class="type">int</span> hash, V value)</span> &#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; first = entryForHash(<span class="built_in">this</span>, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">    HashEntry&lt;K,V&gt; node = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">retries</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// negative while locating node</span></span><br><span class="line">    <span class="comment">// 自旋获取锁</span></span><br><span class="line">    <span class="keyword">while</span> (!tryLock()) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; f; <span class="comment">// to recheck first below</span></span><br><span class="line">        <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="comment">// speculatively create node</span></span><br><span class="line">                    node = <span class="keyword">new</span> <span class="title class_">HashEntry</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                e = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">            <span class="comment">// 自旋达到指定次数后，阻塞等到只到获取到锁</span></span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                 (f = entryForHash(<span class="built_in">this</span>, hash)) != first) &#123;</span><br><span class="line">            e = first = f; <span class="comment">// re-traverse if entry changed</span></span><br><span class="line">            retries = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="rehash-扩容"><a href="#rehash-扩容" class="headerlink" title="rehash 扩容"></a>rehash 扩容</h3><hr>
<p>ConcurrentHashMap 的扩容只会扩容到原来的两倍。老数组里的数据移动到新的数组时，位置要么不变，要么变为 index+ oldSize，参数里的 node 会在扩容之后使用链表<strong>头插法</strong>插入到指定位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> &#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">    <span class="comment">// 老容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length;</span><br><span class="line">    <span class="comment">// 新容量，扩大两倍</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 新的扩容阀值 </span></span><br><span class="line">    threshold = (<span class="type">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    <span class="comment">// 创建新的数组</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable = (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> <span class="title class_">HashEntry</span>[newCapacity];</span><br><span class="line">    <span class="comment">// 新的掩码，默认2扩容后是4，-1是3，二进制就是11。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sizeMask</span> <span class="operator">=</span> newCapacity - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        <span class="comment">// 遍历老数组</span></span><br><span class="line">        HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="comment">// 计算新的位置，新的位置只可能是不便或者是老的位置+老的容量。</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> e.hash &amp; sizeMask;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="literal">null</span>)   <span class="comment">//  Single node on list</span></span><br><span class="line">                <span class="comment">// 如果当前位置还不是链表，只是一个元素，直接赋值</span></span><br><span class="line">                newTable[idx] = e;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// Reuse consecutive sequence at same slot</span></span><br><span class="line">                <span class="comment">// 如果是链表了</span></span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                <span class="type">int</span> <span class="variable">lastIdx</span> <span class="operator">=</span> idx;</span><br><span class="line">                <span class="comment">// 新的位置只可能是不便或者是老的位置+老的容量。</span></span><br><span class="line">                <span class="comment">// 遍历结束后，lastRun 后面的元素位置都是相同的</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next; last != <span class="literal">null</span>; last = last.next) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> last.hash &amp; sizeMask;</span><br><span class="line">                    <span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                        lastIdx = k;</span><br><span class="line">                        lastRun = last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// ，lastRun 后面的元素位置都是相同的，直接作为链表赋值到新位置。</span></span><br><span class="line">                newTable[lastIdx] = lastRun;</span><br><span class="line">                <span class="comment">// Clone remaining nodes</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                    <span class="comment">// 遍历剩余元素，头插法到指定 k 位置。</span></span><br><span class="line">                    <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> p.value;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> p.hash;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> h &amp; sizeMask;</span><br><span class="line">                    HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                    newTable[k] = <span class="keyword">new</span> <span class="title class_">HashEntry</span>&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 头插法插入新的节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nodeIndex</span> <span class="operator">=</span> node.hash &amp; sizeMask; <span class="comment">// add the new node</span></span><br><span class="line">    node.setNext(newTable[nodeIndex]);</span><br><span class="line">    newTable[nodeIndex] = node;</span><br><span class="line">    table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里第一个 for 是为了寻找这样一个节点，这个节点后面的所有 next 节点的新位置都是相同的，然后把这个作为一个链表赋值到新位置。</p>
<p>第二个 for 循环是为了把剩余的元素通过头插法插入到指定位置链表。</p>
<hr>
<h3 id="get-操作"><a href="#get-操作" class="headerlink" title="get 操作"></a>get 操作</h3><hr>
<p>到这里就很简单了，get 方法只需要两步即可：</p>
<ol>
<li>计算得到 key 的存放位置。</li>
<li>遍历指定位置查找相同 key 的 value 值。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="type">long</span> <span class="variable">u</span> <span class="operator">=</span> (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    <span class="comment">// 计算得到 key 的存放位置</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        (tab = s.table) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">             (tab, ((<span class="type">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">             e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">            <span class="comment">// 如果是链表，遍历查找到相同 key 的 value。</span></span><br><span class="line">            K k;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ConcurrentHashMap-1-8"><a href="#ConcurrentHashMap-1-8" class="headerlink" title="ConcurrentHashMap 1.8"></a>ConcurrentHashMap 1.8</h2><hr>
<h3 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h3><p>可以发现 Java8 的 ConcurrentHashMap 相对于 Java7 来说变化比较大，不再是之前的 Segment 数组 + HashEntry 数组 + 链表，而是 Node 数组 + 链表 &#x2F; 红黑树。</p>
<p>当冲突链表达到一定长度时，链表会转换成红黑树。</p>
<p><img src="/%E9%9D%A2%E7%BB%8F/image-20220318162050021.png"></p>
<hr>
<h3 id="CAS-操作"><a href="#CAS-操作" class="headerlink" title="CAS 操作"></a>CAS 操作</h3><hr>
<p>JDK 1.8 的 ConcurrentHashMap 保证线程安全是依赖于 CAS 操作，因此先来介绍一下这个</p>
<p>CAS（Compare-and-Swap&#x2F;Exchange），即比较并替换，是一种实现并发常用到的技术。</p>
<p>CAS核心算法：</p>
<ul>
<li>执行函数：CAS (V，E，N)</li>
<li>V 表示准备要被更新的变量 （内存的值）</li>
<li>E 表示我们提供的 期望的值 （期望的原值）</li>
<li>N 表示新值 ，准备更新 V 的值 （新值）</li>
</ul>
<p>算法思路：</p>
<ul>
<li>V是共享变量</li>
<li>我们拿着自己准备的这个E，去跟V去比较，<ul>
<li>如果 E &#x3D;&#x3D; V ：说明当前没有其它线程在操作，所以我们把 N 这个值 写入对象的 V 变量中</li>
<li>如果 E !&#x3D; V ：说明我们准备的这个 E 已经过时了，所以我们要重新准备一个最新的E ，去跟V 比较</li>
</ul>
</li>
<li>比较成功后才能更新 V 的值为 N</li>
</ul>
<p><img src="/2024/12/09/hello-world/shMap/image-20220319000316710.png"></p>
<p>如果多个线程同时使用CAS操作一个变量的时候，只有一个线程能够修改成功。</p>
<p>其余的线程提供的期望值已经与共享变量的值不一样了，所以均会失败。</p>
<p>由于CAS操作属于乐观派，它总是认为自己能够操作成功，所以操作失败的线程将会再次发起操作，而不是被OS挂起。</p>
<p>所以说，即使 CAS操作没有使用同步锁，其它线程也能够知道对共享变量的影响。</p>
<p>因为其它线程没有被挂起，并且将会再次发起修改尝试，所以无锁操作即CAS操作天生免疫死锁。</p>
<p>另外一点需要知道的是，CAS是系统原语，CAS操作是一条CPU的原子指令，所以不会有线程安全问题。</p>
<p><strong>注意</strong>：</p>
<ul>
<li>ABA问题：<ul>
<li>E 和 E‘ 对比相同是不能保证百分百保证，其他线程没有在自己线程执行计算的过程里抢锁成功过</li>
<li>有可能其他线程操作后新 E’ 值和旧 E 值一样</li>
</ul>
</li>
<li>解决方案：<ul>
<li>在 E 对象里加个操作次数变量就行，每次判断时对比两个，E和操作次数就OK了</li>
<li>因为 ABA 问题中就算 E 相同操作次数也绝不相同</li>
</ul>
</li>
</ul>
<p>另外，<strong>CAS是靠硬件实现</strong>的，从而在硬件层面提升效率。实现方式是基于硬件平台的汇编指令，在intel的CPU中，使用的是 cmpxchg 指令。</p>
<p>但是在<strong>多核CPU</strong>的情况下，这个指令也不能保证原子性，需要在前面加上 lock 指令。lock 指令可以保证一个 CPU 核心在操作期间<strong>独占一片内存区域</strong>。这个实现方式为：<strong>总线锁和缓存锁</strong>。</p>
<p>在多核处理器的结构中，CPU 核心并不能直接访问内存，而是统一通过一条总线访问。</p>
<p>总线锁就是锁住这条总线，使其他核心无法访问内存。这种方式代价太大了，会导致其他核心停止工作。</p>
<p>而缓存锁并不锁定总线，只是锁定某部分内存区域。当一个 CPU 核心将内存区域的数据读取到自己的缓存区后，它会锁定缓存对应的内存区域。锁住期间，其他核心无法操作这块内存区域。</p>
<hr>
<h3 id="初始化-initTable"><a href="#初始化-initTable" class="headerlink" title="初始化 initTable"></a>初始化 initTable</h3><hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes table, using the size recorded in sizeCtl.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果 sizeCtl &lt; 0 ,说明另外的线程执行CAS 成功，正在进行初始化。</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 让出 CPU 使用权</span></span><br><span class="line">            Thread.<span class="keyword">yield</span>(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中可以发现 ConcurrentHashMap 的初始化是通过自旋和 CAS 操作完成的。里面需要注意的是变量 <code>sizeCtl</code> ，它的值决定着当前的初始化状态。</p>
<ul>
<li>-1 说明正在初始化</li>
<li>-N 说明有N-1个线程正在进行扩容</li>
<li>表示 table 初始化大小，如果 table 没有初始化</li>
<li>表示 table 容量，如果 table　已经初始化</li>
</ul>
<hr>
<h3 id="put-操作-1"><a href="#put-操作-1" class="headerlink" title="put 操作"></a>put 操作</h3><hr>
<p>直接过一遍 put 源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="comment">// key 和 value 不能为空</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        <span class="comment">// f = 目标位置元素</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;<span class="comment">// fh 后面存放目标位置的元素 hash 值</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 数组桶为空，初始化数组桶（自旋+CAS)</span></span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 桶内为空，CAS 放入，不加锁，成功了就直接 break 跳出</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,<span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 使用 synchronized 加锁加入节点</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">// 说明是链表</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 循环加入新的或者覆盖节点</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="literal">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        <span class="comment">// 红黑树</span></span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                              value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>过程概述：</p>
<ul>
<li>根据 key 计算出 hashcode</li>
<li>判断是否需要进行初始化</li>
<li>即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功</li>
<li>如果当前位置的 <code>hashcode == MOVED == -1</code>，则需要进行扩容</li>
<li>如果都不满足，则利用 synchronized 锁写入数据</li>
<li>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要转换为红黑树</li>
</ul>
<hr>
<h3 id="get-操作-1"><a href="#get-操作-1" class="headerlink" title="get 操作"></a>get 操作</h3><hr>
<p>get 流程比较简单，直接来吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="type">int</span> n, eh; K ek;</span><br><span class="line">    <span class="comment">// key 所在的 hash 位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果指定位置元素存在，头结点hash值相同</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="comment">// key hash 值相等，key值相同，直接返回元素 value</span></span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 头结点hash值小于0，说明正在扩容或者是红黑树，find查找</span></span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="literal">null</span> ? p.val : <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 是链表，遍历查找</span></span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下 get 过程：</p>
<ul>
<li>根据 hash 值计算位置</li>
<li>查找到指定位置，如果头节点就是要找的，直接返回它的 value</li>
<li>如果头节点 hash 值小于 0 ，说明正在扩容或者是红黑树，查找之</li>
<li>如果是链表，遍历查找之</li>
</ul>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><hr>
<p>Java7 中 ConcurrentHashMap 使用的<strong>分段锁</strong>，也就是每一个 Segment 上同时只有一个线程可以操作，每一个 Segment 都是一个类似 HashMap 数组的结构，它可以扩容，它的冲突会转化为链表。但是 Segment 的个数一但初始化就不能改变。</p>
<p>Java8 中的 ConcurrentHashMap 使用的 Synchronized 锁加 CAS 的机制。结构也由 Java7 中的 <strong>Segment 数组 + HashEntry 数组 + 链表</strong> 进化成了 <strong>Node 数组 + 链表 &#x2F; 红黑树</strong>，Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。</p>
]]></content>
  </entry>
  <entry>
    <title>Docker 命令</title>
    <url>/2024/05/13/Docker%20%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="Docker-命令"><a href="#Docker-命令" class="headerlink" title="Docker 命令"></a>Docker 命令</h1><h2 id="创建redis"><a href="#创建redis" class="headerlink" title="创建redis"></a>创建redis</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --restart=always -p 6379:6379 --name myredis -d redis:latest  --requirepass Nruonan996</span><br></pre></td></tr></table></figure>



<h2 id="创建rabbitmq"><a href="#创建rabbitmq" class="headerlink" title="创建rabbitmq"></a>创建rabbitmq</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -id --name=rabbitmq -v rabbitmq-home:/var/lib/rabbitmq -p 15672:15672 -p 5672:5672 -e RABBITMQ_DEFAULT_USER=xzn -e RABBITMQ_DEFAULT_PASS=Nruonan996 rabbitmq:management</span><br></pre></td></tr></table></figure>

<h2 id="创建minio"><a href="#创建minio" class="headerlink" title="创建minio"></a>创建minio</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -p 9000:9000 -p 9090:9090 --name minio \</span><br><span class="line">     -d --restart=always \</span><br><span class="line">     -e &quot;MINIO_ACCESS_KEY=minio&quot; \</span><br><span class="line">     -e &quot;MINIO_SECRET_KEY=feiwu996&quot; \</span><br><span class="line">     -v database:/data \</span><br><span class="line">     minio/minio server \</span><br><span class="line">     /data --console-address &quot;:9090&quot; -address &quot;:9000&quot;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>HashMap</title>
    <url>/2024/11/13/HashMap/</url>
    <content><![CDATA[<h1 id="HashMap-类"><a href="#HashMap-类" class="headerlink" title="HashMap 类"></a>HashMap 类</h1><hr>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><hr>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><hr>
<p>Hash 表也称为散列表，也有直接译作哈希表，Hash表是一种根据关键字值（key - value）而直接进行访问的数据结构。</p>
<p>哈希表，它是通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做<strong>散列函数</strong>，存放记录的数组叫做<strong>散列表，</strong>只需要 <strong>O(1)</strong> 的时间级</p>
<p>HashMap的实现不是同步的，这意味着它不是<strong>线程安全</strong>的。它的key、value都可以为null，但 HashMap 中的映射不是有序的。</p>
<p><strong>注意</strong>：</p>
<ul>
<li>散列函数可能存在冲突，解决冲突有两种方法</li>
<li>开放寻址法：从冲突的位置开始，向后查找第一个可以插入的位置</li>
<li>拉链法：在冲突的位置后面追加节点使之成为链表</li>
</ul>
<p>由于开放寻址法可能造成二次冲突，因此大多情况下采用拉链法解决</p>
<hr>
<h3 id="版本对比"><a href="#版本对比" class="headerlink" title="版本对比"></a>版本对比</h3><hr>
<h4 id="JDK1-8-前-HashMap-的数据结构"><a href="#JDK1-8-前-HashMap-的数据结构" class="headerlink" title="JDK1.8 前 HashMap 的数据结构"></a>JDK1.8 前 HashMap 的数据结构</h4><hr>
<ul>
<li>JDK 8 以前 HashMap 的实现是 <strong>数组+链表</strong>，即使哈希函数取得再好，也很难达到元素百分百均匀分布。</li>
<li>当 HashMap 中有大量的元素都存放到同一个桶中时，这个桶下有一条长长的链表，极端情况HashMap 就相当于一个单链表，假如单链表有 n 个元素，遍历的时间复杂度就是 O(n)，完全失去了它的优势。</li>
</ul>
<p><img src="/2024/12/09/hello-world/e-20220221182804565.png" alt="img"></p>
<hr>
<h4 id="JDK1-8-后-HashMap-的数据结构"><a href="#JDK1-8-后-HashMap-的数据结构" class="headerlink" title="JDK1.8 后 HashMap 的数据结构"></a>JDK1.8 后 HashMap 的数据结构</h4><hr>
<ul>
<li>JDK 8 后 HashMap 的实现是 <strong>数组+链表+红黑树</strong></li>
<li>桶中的结构可能是链表，也可能是红黑树，当<strong>链表长度大于阈值</strong>(或者红黑树的边界值，默认为8)并且当前<strong>数组的长度大于64</strong>时，此时此索引位置上的所有数据改为使用红黑树存储。</li>
</ul>
<p><img src="/2024/12/09/hello-world/e-20220224112415112.png" alt="img"></p>
<hr>
<h2 id="类构造器"><a href="#类构造器" class="headerlink" title="类构造器"></a>类构造器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br></pre></td></tr></table></figure>



<p><img src="/2024/12/09/hello-world/e-20220222100327933.png" alt="img"></p>
<p>JDK 为我们提供了一个抽象类 AbstractMap ，该抽象类继承 Map 接口，所以如果我们不想实现所有的 Map 接口方法，就可以选择继承抽象类 AbstractMap 。</p>
<p>HashMap 集合实现了 Cloneable 接口以及 Serializable 接口，分别用来进行对象克隆以及将对象进行序列化。</p>
<p>注意：HashMap 类即继承了 AbstractMap 接口，也实现了 Map 接口，这样做难道不是多此一举？</p>
<blockquote>
<p>据 java 集合框架的创始人 Josh Bloch 描述，这样的写法是一个失误。在java集合框架中，类似这样的写法很多，最开始写java集合框架的时候，他认为这样写，在某些地方可能是有价值的，直到他意识到错了。显然的，JDK 的维护者，后来不认为这个小小的失误值得去修改，所以就这样存在下来了。</p>
</blockquote>
<hr>
<h2 id="字段属性"><a href="#字段属性" class="headerlink" title="字段属性"></a>字段属性</h2><hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//序列化和反序列化时，通过该字段进行版本一致性验证</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">362498820763181265L</span>;</span><br><span class="line"><span class="comment">//默认 HashMap 集合初始容量为16（必须是 2 的倍数）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="comment">//集合的最大容量，如果通过带参构造指定的最大容量超过此数，默认还是使用此数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">//默认的填充因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">//当桶(bucket)上的结点数大于这个值时会转成红黑树(JDK1.8新增)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"><span class="comment">//当桶(bucket)上的节点数小于这个值时会转成链表(JDK1.8新增)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"><span class="comment">/**(JDK1.8新增)</span></span><br><span class="line"><span class="comment">* 当集合中的容量大于这个值时，表中的桶才能进行树形化 ，否则桶内元素太多时会扩容，</span></span><br><span class="line"><span class="comment">* 而不是树形化 为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 初始化使用，长度总是 2的幂</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 保存缓存的entrySet（）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 此映射中包含的键值映射的数量。（集合存储键值对的数量）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 跟前面ArrayList和LinkedList集合中的字段modCount一样，记录集合被修改的次数</span></span><br><span class="line"><span class="comment">* 主要用于迭代器中的快速失败</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 调整大小的下一个大小值（容量*加载因子）。capacity * load factor</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> threshold;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 散列表的加载因子。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br></pre></td></tr></table></figure>

<p>下面我们重点介绍上面几个字段：</p>
<ul>
<li><pre><code>Node&lt;K,V&gt;[] table
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  ：</span><br><span class="line"></span><br><span class="line">  - 我们说 HashMap 是由数组 + 链表 + 红黑树组成，这里的数组就是 table 字段</span><br><span class="line">  - 初始化长度默认是 DEFAULT_INITIAL_CAPACITY= 16，且 JDK 声明数组的长度总是 2的 n 次方(一定是合数)</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  size</span><br></pre></td></tr></table></figure>

：

- 集合中存放 key-value 的实时对数
</code></pre>
</li>
<li><pre><code>loadFactor
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  ：</span><br><span class="line"></span><br><span class="line">  - 装载因子，是用来衡量 HashMap 满的程度</span><br><span class="line">  - 计算HashMap的实时装载因子的方法为：size/capacity，而不是占用桶的数量去除以capacity</span><br><span class="line">  - capacity 是桶的数量，也就是 table 的长度length</span><br><span class="line">  - 默认的负载因子0.75 是对空间和时间效率的一个平衡选择，建议不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以降低负载因子loadFactor 的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子 loadFactor 的值，这个值可以大于1</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  threshold</span><br></pre></td></tr></table></figure>

：

- 计算公式：capacity * loadFactor
- 这个值是当前已占用数组长度的最大值。过这个数目就重新resize(扩容)，扩容后的 HashMap 容量是之前容量的两倍
</code></pre>
</li>
</ul>
<hr>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><hr>
<h3 id="默认无参构造函数"><a href="#默认无参构造函数" class="headerlink" title="默认无参构造函数"></a>默认无参构造函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 默认构造函数，初始化加载因子loadFactor = 0.75</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="指定初始容量的构造函数"><a href="#指定初始容量的构造函数" class="headerlink" title="指定初始容量的构造函数"></a>指定初始容量的构造函数</h3><hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> initialCapacity 指定初始化容量</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> loadFactor 加载因子 0.75</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="comment">//初始化容量不能小于 0 ，否则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="comment">//如果初始化容量大于2的30次方，则初始化容量都为2的30次方</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">//如果加载因子小于0，或者加载因子是一个非数值，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回大于等于initialCapacity的最小的二次幂数值。</span></span><br><span class="line"><span class="comment">// &gt;&gt;&gt; 操作符表示无符号右移，高位取0。</span></span><br><span class="line"><span class="comment">// | 按位或运算</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="确定哈希桶数组索引位置"><a href="#确定哈希桶数组索引位置" class="headerlink" title="确定哈希桶数组索引位置"></a>确定哈希桶数组索引位置</h2><hr>
<p>前面我们讲解哈希表的时候，我们知道是用散列函数来确定索引的位置。</p>
<p>散列函数设计的越好，使得元素分布的越均匀。</p>
<p>HashMap 是数组+链表+红黑树的组合，我们希望在有限个数组位置时，尽量每个位置的元素只有一个，那么当我们用散列函数求得索引位置的时候，我们能马上知道对应位置的元素是不是我们想要的，而不是要进行链表的遍历或者红黑树的遍历，这会大大优化我们的查询效率。</p>
<p>我们看 HashMap 中的哈希算法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">i = (table.length - <span class="number">1</span>) &amp; hash;<span class="comment">//这一步是在后面添加元素putVal()方法中进行位置的确定</span></span><br></pre></td></tr></table></figure>

<p>主要分为三步：</p>
<ul>
<li>取 hashCode 值： key.hashCode()</li>
<li>高位参与运算：h&gt;&gt;&gt;16</li>
<li>取模运算：(n-1) &amp; hash</li>
</ul>
<p>这里获取 hashCode() 方法的值是变量，但是我们知道，对于任意给定的对象，只要它的 hashCode() 返回值相同，那么程序调用 hash(Object key) 所计算得到的 hash码 值总是相同的。</p>
<p>为了让数组元素分布均匀，我们首先想到的是把获得的 hash码对数组长度取模运算( hash % length)，但是计算机都是二进制进行操作，取模运算相对开销还是很大的，那该如何优化呢？</p>
<p>HashMap 使用的方法很巧妙，它通过 hash &amp; (table.length -1) 来得到该对象的保存位，前面说过 HashMap 底层数组的长度总是 2 的 n 次方，这是HashMap在速度上的优化：</p>
<ul>
<li>当 length 总是 2 的 n 次方时，hash &amp; (length-1) 运算等价于对 length 取模，也就是 hash % length</li>
<li>但是 &amp; 比 % 具有更高的效率，比如 n % 32 &#x3D; n &amp; (32 -1)</li>
</ul>
<p>在 JDK 1.8 中还有另一个优化点，高位参与运算，hashCode() 得到的是一个32位 int 类型的值，是通过hashCode()的高16位 <strong>异或</strong> 低16位实现的：</p>
<ul>
<li>(h &#x3D; k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的</li>
<li>这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销</li>
</ul>
<p>最后一点：</p>
<ul>
<li>当 length 为 2 的 n 次方时，参与计算时 length - 1 的最低一位是 0</li>
<li>因此，hashcode 和 length - 1 做 &amp; 运算时，最后一位的结果永远为 0</li>
<li>这就导致永远缺少 1 位参与散列运算，导致散列函数只能映射到数组一半的空间</li>
</ul>
<p>这也解释了为什么要保证数组的长度必须要求是 2 的 n 次方</p>
<hr>
<h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h2><hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//hash(key)就是上面讲的hash方法，对其进行了第一步和第二步处理</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> hash 索引的位置</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> value  值</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> onlyIfAbsent true 表示不要更改现有值</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> evict false表示table处于创建模式</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">//如果table为null或者长度为0，则进行初始化</span></span><br><span class="line">    <span class="comment">//resize()方法本来是用于扩容，由于初始化没有实际分配空间，这里用该方法进行空间分配，后面会详细讲解该方法</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//注意：这里用到了前面讲解获得key的hash码的第三步，取模运算，下面的if-else分别是 tab[i] 为null和不为null</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);<span class="comment">//tab[i] 为null，直接将新的key-value插入到计算的索引i位置</span></span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//tab[i] 不为null，表示该位置已经有值了</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;<span class="comment">//节点key已经有值了，直接用新值覆盖</span></span><br><span class="line">        <span class="comment">//该链是红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">//该链是链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">//链表长度大于8，转换成红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//key已经存在直接覆盖value</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;<span class="comment">//用作修改和新增快速失败</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)<span class="comment">//超过最大容量，进行扩容</span></span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>①、判断键值对数组 table 是否为空或为null，否则执行resize()进行扩容；</p>
<p>②、根据键值key计算hash值得到插入的数组索引i，如果table[i]&#x3D;&#x3D;null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；</p>
<p>③、判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；</p>
<p>④、判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</p>
<p>⑤、遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</p>
<p>⑥、插入成功后，判断实际存在的键值对数量size是否超过了最大容量threshold，如果超过，进行扩容。</p>
<p>⑦、如果新插入的key不存在，则返回null，如果新插入的key存在，则返回原key对应的value值（注意新插入的value会覆盖原value值）</p>
<p><strong>注意</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (++size &gt; threshold)<span class="comment">//超过最大容量，进行扩容</span></span><br><span class="line">    resize();</span><br></pre></td></tr></table></figure>

<p>如果在添加元素时，发生冲突，会将冲突的数放在链表上，当链表长度超过 8 时，会自动转换成红黑树</p>
<hr>
<h2 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h2><hr>
<p>扩容（resize），我们知道集合是由数组+链表+红黑树构成，向 HashMap 中插入元素时，如果HashMap 集合的元素已经大于了最大承载容量threshold（capacity * loadFactor），这里的threshold不是数组的最大长度。那么必须扩大数组的长度，Java中数组是无法自动扩容的，我们采用的方法是用一个更大的数组代替这个小的数组，然后将小数组里面的元素向大数组转移。</p>
<p>JDK1.8融入了红黑树的机制，比较复杂，这里我们先介绍 JDK1.7的扩容源码，便于理解，然后在介绍JDK1.8的源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参数 newCapacity 为新数组的大小</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCapacity)</span> &#123;</span><br><span class="line">    Entry[] oldTable = table;<span class="comment">//引用扩容前的 Entry 数组</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;<span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了</span></span><br><span class="line">        threshold = Integer.MAX_VALUE;<span class="comment">///修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> <span class="title class_">Entry</span>[newCapacity];<span class="comment">//初始化一个新的Entry数组</span></span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));<span class="comment">//将数组元素转移到新数组里面</span></span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="type">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);<span class="comment">//修改阈值</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable, <span class="type">boolean</span> rehash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;<span class="comment">//遍历数组</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="literal">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);<span class="comment">//重新计算每个元素在数组中的索引位置</span></span><br><span class="line">            e.next = newTable[i];<span class="comment">//标记下一个元素，添加是链表头添加</span></span><br><span class="line">            newTable[i] = e;<span class="comment">//将元素放在链上</span></span><br><span class="line">            e = next;<span class="comment">//访问下一个 Entry 链上的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过方法我们可以看到，JDK1.7中首先是创建一个新的大容量数组，然后依次重新计算原集合所有元素的索引，然后重新赋值。如果数组某个位置发生了hash冲突，使用的是单链表的头插入方法，同一位置的新元素总是放在链表的头部，这样与原集合链表对比，扩容之后的可能就是倒序的链表了。</p>
<p>下面我们在看看JDK1.8的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;<span class="comment">//原数组如果为null，则长度赋值0</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;<span class="comment">//如果原数组长度大于0</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<span class="comment">//数组大小如果已经大于等于最大值(2^30)</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;<span class="comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//原数组长度大于等于初始化长度16，并且原数组长度扩大1倍也小于2^30次方</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// 阀值扩大1倍</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">//旧阀值大于0，则将新容量直接等于就阀值</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//阀值等于0，oldCap也等于0（集合未进行初始化）</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;<span class="comment">//数组长度初始化为16</span></span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<span class="comment">//阀值等于16*0.75=12</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算新的阀值上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;<span class="comment">//元数据j位置置为null，便于垃圾回收</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)<span class="comment">//数组没有下一个引用（不是链表）</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)<span class="comment">//红黑树</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">//原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">//原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法分为两部分，首先是计算新桶数组的容量 newCap 和新阈值 newThr，然后将原集合的元素重新映射到新集合中。</p>
<p>相比于JDK1.7，1.8使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动 2 次幂的位置。</p>
<p>我们在扩充 HashMap 的时候，不需要像 JDK1.7 的实现那样重新计算 hash，只需要看看原来的 hash 值新增的那个 bit 是 1 还是 0 就好了，是 0 的话索引没变，是 1 的话索引变成“原索引+oldCap”。</p>
<hr>
<h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><hr>
<p>HashMap 删除元素首先是要找到 桶的位置，之后进行判断：</p>
<ul>
<li>如果是链表，则进行链表遍历，找到需要删除的元素后，进行删除</li>
<li>如果是红黑树，也是进行树的遍历，找到元素删除后，进行平衡调节，注意，当红黑树的节点数小于 6 时，会转化成链表</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//根据key计算的索引检查第一个索引</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">//不是第一个节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)<span class="comment">//遍历树查找元素</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">//遍历链表查找元素</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h2><hr>
<p>通过 key 查找 value：</p>
<ul>
<li>首先通过 key 找到计算索引，找到桶位置</li>
<li>先检查第一个节点，如果是则返回</li>
<li>如果不是，则遍历其后面的链表或者红黑树</li>
<li>其余情况全部返回 null</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//根据key计算的索引检查第一个索引</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">//不是第一个节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)<span class="comment">//遍历树查找元素</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">//遍历链表查找元素</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>jvm</title>
    <url>/2024/04/21/jvm/</url>
    <content><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Java Virtual Machine - java 程序的运行环境 （java 二进制节码的运行环境）</p>
<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ul>
<li>一次编写，到处运行</li>
<li>自动内存管理，垃圾回收功能</li>
<li>数组下标越界检查</li>
<li>多态</li>
</ul>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p><img src="/2024/04/21/jvm/1713706176342.png" alt="1713706176342"></p>
<h2 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h2><h3 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1.程序计数器"></a>1.程序计数器</h3><h4 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h4><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来<strong>选取下一条需要执行的字节码指令</strong>，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。（简单来说， 记住下一条jvm指令的执行地址）</p>
<p>另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有<strong>一个独立的程序计数器</strong>，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p>
<h4 id="1-2-作用"><a href="#1-2-作用" class="headerlink" title="1.2 作用"></a>1.2 作用</h4><ul>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>
</ul>
<p>⚠️ 注意：程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域（不会产生内存 溢出），它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p>
<h3 id="2-栈"><a href="#2-栈" class="headerlink" title="2.栈"></a>2.栈</h3><h4 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h4><ul>
<li>每个线程运行时所需要的内存，称为虚拟机栈</li>
<li>每个栈由多个栈帧(Frame)组成，对应着每次方法调用时所占用的内存</li>
<li>每个线程只能有一个活动栈，对应着当前正在执行的那个方法</li>
</ul>
<p>每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址。和数据结构上的栈类似，两者都是先进后出的数据结构，只支持出栈和入栈两种操作。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/stack-area.png" alt="Java 虚拟机栈"></p>
<p><strong>局部变量表</strong> 主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/local-variables-table.png" alt="局部变量表"></p>
<p><strong>操作数栈</strong> 主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。</p>
<p><strong>动态链接</strong> 主要服务一个方法需要调用其他方法的场景。Class 文件的常量池里保存有大量的符号引用比如方法引用的符号引用。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。动态链接的作用就是为了将符号引用转换为调用方法的直接引用，这个过程也被称为 <strong>动态连接</strong> 。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/jvmimage-20220331175738692.png" alt="img"></p>
<p>栈空间虽然不是无限的，但一般正常调用的情况下是不会出现问题的。不过，如果函数调用陷入无限循环的话，就会导致栈中被压入太多栈帧而占用太多空间，导致栈空间过深。那么当线程请求栈的深度超过当前 Java 虚拟机栈的<strong>最大深度</strong>的时候，就抛出 <code>StackOverFlowError</code> 错误。</p>
<p>Java 方法有两种返回方式，一种是 return 语句正常返回，一种是抛出异常。不管哪种返回方式，都会导致栈帧被弹出。也就是说， <strong>栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。</strong></p>
<p>除了 <code>StackOverFlowError</code> 错误之外，栈还可能会出现<code>OutOfMemoryError</code>错误，这是因为如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出<code>OutOfMemoryError</code>异常。</p>
<p>简单总结一下程序运行中栈可能会出现两种错误：</p>
<ul>
<li><strong><code>StackOverFlowError</code>：</strong> 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 <code>StackOverFlowError</code> 错误。</li>
<li><strong><code>OutOfMemoryError</code>：</strong> 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出<code>OutOfMemoryError</code>异常。</li>
</ul>
<p>问题辨析：</p>
<ol>
<li>垃圾回收是否涉及栈内存？<br>不会。栈内存是方法调用产生的，方法调用结束后会弹出栈。</li>
<li>栈内存分配越大越好吗？<br>不是。因为物理内存是一定的，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。</li>
<li>方法的局部变量是否线程安全<br>如果方法内部的变量没有逃离方法的作用访问，它是线程安全的<br>如果是局部变量引用了对象，并逃离了方法的访问，那就要考虑线程安全问题。</li>
</ol>
<h4 id="2-2-栈内存溢出"><a href="#2-2-栈内存溢出" class="headerlink" title="2.2 栈内存溢出"></a>2.2 栈内存溢出</h4><p>栈帧过大、过多、或者第三方类库操作，都有可能造成栈内存溢出 java.lang.stackOverflowError ，使用 -Xss256k 指定栈内存大小！</p>
]]></content>
  </entry>
  <entry>
    <title>Juc</title>
    <url>/2024/08/09/Juc/</url>
    <content><![CDATA[<h1 id="Juc"><a href="#Juc" class="headerlink" title="Juc"></a>Juc</h1>]]></content>
  </entry>
  <entry>
    <title>双Token解决方案</title>
    <url>/2024/10/05/%E5%8F%8CToken%20%E4%B8%89%E9%AA%8C%E8%AF%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>以往的项目大部分解决方案为单 token：</p>
<ul>
<li>用户登录后，服务端颁发 jwt 令牌作为 token 返回</li>
<li>每次请求，前端携带 token 访问，服务端解析 token 进行校验和鉴权</li>
</ul>
<p>存在的问题：</p>
<ul>
<li>有效期设置问题：有效期设置需要对时间做平衡，不能太短也不能太长</li>
<li>续期问题：一旦过期，用户必须重新登录，很难做无感刷新</li>
<li>无状态问题：token 是无状态的，单 token 颁发后服务端无法主动使其失效</li>
</ul>
<h2 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h2><hr>
<p>这里引入双 token 机制：</p>
<ul>
<li>accessToken：时间较短，一般为 1天</li>
<li>refreshToken：时间较长，一般为 3 天</li>
</ul>
<p>登录过程：</p>
<ul>
<li>用户携带用户名和密码登录</li>
<li>服务端为其颁发 accessToken 和 refreshToken</li>
</ul>
<p>三验证环节：</p>
<ul>
<li>一验证：前端请求携带 accessToken，验证是否过期，不过期放行，过期则进入第二个验证环节</li>
<li>二验证：前端请求携带 refreshToken，验证是否过期，不过期进入第三个验证环节，过期则要求用户重新登录</li>
<li>三验证：对 ip 地址进行限流，对 refreshToken 解析 判断是否存在，存在则颁发新的 accessToken 和 refreshToken 返回前端更新，前端没接收成功或者失败则删除所有token，</li>
</ul>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p> 生成 Token</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据UserDetails生成对应的Jwt令牌</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user 用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 令牌</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">createJwt</span><span class="params">(UserDetails user, String username, <span class="type">int</span> userId)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.frequencyCheck(userId)) &#123;</span><br><span class="line">            <span class="type">Algorithm</span> <span class="variable">algorithm</span> <span class="operator">=</span> Algorithm.HMAC256(key);</span><br><span class="line">            <span class="type">Date</span> <span class="variable">expire</span> <span class="operator">=</span> <span class="built_in">this</span>.expireTime();</span><br><span class="line">            <span class="keyword">return</span> JWT.create()</span><br><span class="line">                .withJWTId(UUID.randomUUID().toString())</span><br><span class="line">                .withClaim(<span class="string">&quot;id&quot;</span>, userId)</span><br><span class="line">                .withClaim(<span class="string">&quot;name&quot;</span>, username)</span><br><span class="line">                .withClaim(<span class="string">&quot;authorities&quot;</span>, user.getAuthorities()</span><br><span class="line">                    .stream()</span><br><span class="line">                    .map(GrantedAuthority::getAuthority).toList())</span><br><span class="line">                .withExpiresAt(expire)</span><br><span class="line">                .withIssuedAt(<span class="keyword">new</span> <span class="title class_">Date</span>())</span><br><span class="line">                .sign(algorithm);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成refreshToken</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">createRefreshJwt</span><span class="params">(UserDetails user, String username, <span class="type">int</span> userId)</span> &#123;</span><br><span class="line">        <span class="type">Algorithm</span> <span class="variable">algorithm</span> <span class="operator">=</span> Algorithm.HMAC256(key);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">expire</span> <span class="operator">=</span> <span class="built_in">this</span>.reExpireTime();</span><br><span class="line">        <span class="keyword">return</span> JWT.create()</span><br><span class="line">            .withJWTId(UUID.randomUUID().toString())</span><br><span class="line">            .withClaim(<span class="string">&quot;id&quot;</span>, userId)</span><br><span class="line">            .withClaim(<span class="string">&quot;name&quot;</span>, username)</span><br><span class="line">            .withExpiresAt(expire)</span><br><span class="line">            .withIssuedAt(<span class="keyword">new</span> <span class="title class_">Date</span>())</span><br><span class="line">            .sign(algorithm);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="校验-Token"><a href="#校验-Token" class="headerlink" title="校验 Token"></a>校验 Token</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line">  JwtUtils utils;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">      HttpServletResponse response,</span></span><br><span class="line"><span class="params">      FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">      <span class="comment">// 获取请求头</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">authorization</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">      <span class="comment">// 从请求头解析jwt</span></span><br><span class="line">      <span class="type">DecodedJWT</span> <span class="variable">jwt</span> <span class="operator">=</span> utils.resolveJwt(authorization);</span><br><span class="line">      <span class="keyword">if</span>(jwt != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">//开始解析成UserDetails对象，如果得到的是null说明解析失败，JWT有问题</span></span><br><span class="line">          <span class="type">UserDetails</span> <span class="variable">user</span> <span class="operator">=</span> utils.toUser(jwt);</span><br><span class="line">          <span class="comment">//验证没有问题，那么就可以开始创建Authentication了，这里我们跟默认情况保持一致</span></span><br><span class="line">          <span class="comment">//使用UsernamePasswordAuthenticationToken作为实体，填写相关用户信息进去</span></span><br><span class="line">          <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authentication</span> <span class="operator">=</span></span><br><span class="line">              <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(user, <span class="literal">null</span>, user.getAuthorities());</span><br><span class="line">          authentication.setDetails(<span class="keyword">new</span> <span class="title class_">WebAuthenticationDetailsSource</span>().buildDetails(request));</span><br><span class="line">          <span class="comment">//然后直接把配置好的Authentication塞给SecurityContext表示已经完成验证</span></span><br><span class="line">          SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line">          <span class="comment">// 将该用户jwt添加到请求头</span></span><br><span class="line">          request.setAttribute(Const.ATTR_USER_ID, utils.toId(jwt));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 触发http请求</span></span><br><span class="line">      filterChain.doFilter(request, response);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="刷新-Token"><a href="#刷新-Token" class="headerlink" title="刷新 Token"></a>刷新 Token</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizeRespDTO</span> &#123;</span><br><span class="line">    String username;</span><br><span class="line">    String role;</span><br><span class="line">    String access_token;</span><br><span class="line">    String refresh_token;</span><br><span class="line">    Date access_expire;</span><br><span class="line">    Date refresh_expire;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AuthorizeRespDTO <span class="title function_">refreshToken</span><span class="params">(String token, HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> request.getRemoteAddr();</span><br><span class="line">        <span class="type">AuthorizeRespDTO</span> <span class="variable">dto</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 进行限流处理</span></span><br><span class="line">        <span class="keyword">if</span> (verifyLimit(ip))&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">refreshToken</span> <span class="operator">=</span> <span class="string">&quot;Bearer &quot;</span> + token;</span><br><span class="line">            <span class="comment">// 如果 Access Token 无效，但存在 Refresh Token，尝试解析 Refresh Token</span></span><br><span class="line">            <span class="type">DecodedJWT</span> <span class="variable">refreshJwt</span> <span class="operator">=</span> utils.resolveJwt(refreshToken);</span><br><span class="line">            <span class="comment">// 如果没有过期进行下一步操作</span></span><br><span class="line">            <span class="keyword">if</span> (refreshJwt != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">UserDetails</span> <span class="variable">user</span> <span class="operator">=</span> utils.toRefreshUser(refreshJwt);</span><br><span class="line">                <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 将新的 Access Token 加到响应头中</span></span><br><span class="line">                    <span class="type">AccountRespDTO</span> <span class="variable">account</span> <span class="operator">=</span> findAccountByNameOrEmail(user.getUsername());</span><br><span class="line">                    <span class="comment">// 如果 Refresh Token 有效，生成新的 Access Token</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">newAccessToken</span> <span class="operator">=</span> utils.createJwt(user, account.getUsername(), account.getId()); <span class="comment">// 你需要实现这个方法</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">newRefreshJwt</span> <span class="operator">=</span> utils.createRefreshJwt(user, account.getUsername(), account.getId());</span><br><span class="line">                    dto = BeanUtil.toBean(account, AuthorizeRespDTO.class);</span><br><span class="line">                    dto.setAccess_token(newAccessToken);</span><br><span class="line">                    dto.setRefresh_token(newRefreshJwt);</span><br><span class="line">                    dto.setAccess_expire(utils.expireTime());</span><br><span class="line">                    dto.setRefresh_expire(utils.reExpireTime());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dto;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>mysql</title>
    <url>/2023/03/17/mysql/</url>
    <content><![CDATA[<h1 id="mysql进阶"><a href="#mysql进阶" class="headerlink" title="mysql进阶"></a>mysql进阶</h1><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p><img src="/2023/03/17/mysql/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="MySQL体系结构1"></p>
<ul>
<li><p>连接层</p>
<p>最上层是一些客户端和链接服务，主要完成一些类似于连接处理、授权认证、及相关的安全方案。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p>
</li>
<li><p>服务层</p>
<p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。</p>
</li>
<li><p>引擎层</p>
<p>存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过AP和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。</p>
</li>
<li><p>存储层</p>
<p>主要是将数据存储在文件系统之上，并完成与存储引擎的交互。</p>
</li>
</ul>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>存储引擎就是存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式。存储引擎是基于表而不是基于库的，所以存储引擎也可以被称为表引擎。<br>mysql5.0以后默认存储引擎是InnoDB。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询建表语句</span><br><span class="line">show create table account;</span><br><span class="line">-- 建表时指定存储引擎</span><br><span class="line">CREATE TABLE 表名(</span><br><span class="line">	...</span><br><span class="line">) ENGINE=INNODB;</span><br><span class="line">-- 查看当前数据库支持的存储引擎</span><br><span class="line">show engines;</span><br></pre></td></tr></table></figure>

<h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>InnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是默认的 MySQL 引擎。</p>
<p>特点：</p>
<ul>
<li>DML 操作遵循 ACID 模型，支持<strong>事务</strong></li>
<li><strong>行级锁</strong>，提高并发访问性能</li>
<li>支持<strong>外键</strong>约束，保证数据的完整性和正确性</li>
</ul>
<p>文件：</p>
<ul>
<li>xxx.ibd: xxx代表表名，InnoDB 引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。</li>
</ul>
<p>参数：innodb_file_per_table，决定多张表共享一个表空间还是每张表对应一个表空间</p>
<h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>MyISAM 是 MySQL 早期的默认存储引擎。</p>
<p>特点：</p>
<ul>
<li>不支持事务，不支持外键</li>
<li>支持表锁，不支持行锁</li>
<li>访问速度快</li>
</ul>
<p>文件：</p>
<ul>
<li>xxx.sdi: 存储表结构信息</li>
<li>xxx.MYD: 存储数据</li>
<li>xxx.MYI: 存储索引</li>
</ul>
<h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>Memory 引擎的表数据是存储在内存中的，受硬件问题、断电问题的影响，只能将这些表作为临时表或缓存使用。</p>
<p>特点：</p>
<ul>
<li>存放在内存中，速度快</li>
<li>hash索引（默认）</li>
</ul>
<p>文件：</p>
<ul>
<li>xxx.sdi: 存储表结构信息</li>
</ul>
<h3 id="存储引擎特点"><a href="#存储引擎特点" class="headerlink" title="存储引擎特点"></a>存储引擎特点</h3><table>
<thead>
<tr>
<th>特点</th>
<th>InnoDB</th>
<th>MyISAM</th>
<th>Memory</th>
</tr>
</thead>
<tbody><tr>
<td>存储限制</td>
<td>64TB</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>事务安全</td>
<td>支持</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>锁机制</td>
<td>行锁</td>
<td>表锁</td>
<td>表锁</td>
</tr>
<tr>
<td>B+tree索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>Hash索引</td>
<td>-</td>
<td>-</td>
<td>支持</td>
</tr>
<tr>
<td>全文索引</td>
<td>支持（5.6版本之后）</td>
<td>支持</td>
<td>-</td>
</tr>
<tr>
<td>空间使用</td>
<td>高</td>
<td>低</td>
<td>N&#x2F;A</td>
</tr>
<tr>
<td>内存使用</td>
<td>高</td>
<td>低</td>
<td>中等</td>
</tr>
<tr>
<td>批量插入速度</td>
<td>低</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>支持外键</td>
<td>支持</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<h3 id="存储引擎的选择"><a href="#存储引擎的选择" class="headerlink" title="存储引擎的选择"></a>存储引擎的选择</h3><p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。</p>
<ul>
<li>InnoDB: 如果应用对事物的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，则 InnoDB 是比较合适的选择</li>
<li>MyISAM: 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不高，那这个存储引擎是非常合适的。</li>
<li>Memory: 将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。Memory 的缺陷是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性</li>
</ul>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h3><p><strong>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。</strong></p>
<p>索引的作用就相当于书的目录。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。</p>
<p>索引底层数据结构存在很多种类型，常见的索引结构有: B 树， B+树 和 Hash、红黑树。在 MySQL 中，无论是 Innodb 还是 MyIsam，都使用了 B+树作为索引结构。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>使用索引可以大大<strong>加快数据的检索速度</strong>（大大减少检索的数据量）, 减少 IO 次数，这也是创建索引的最主要的原因。</li>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>
<li>为用来排序或者是分组的字段添加索引，可以加快分组和排序的速度，降低cpu消耗</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>建立索引需要<strong>占用物理空间</strong></li>
<li>会降低表的增删改的效率，因为每次对表记录进行增删改，需要进行<strong>动态维护索引</strong>，导致增删改时间变长</li>
</ul>
<h3 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h3><p>索引的数据结构主要有<strong>B+树</strong>和<strong>哈希表</strong>，对应的索引分别为B+树索引和哈希索引。InnoDB引擎的索引类型有B+树索引和哈希索引，默认的索引类型为B+树索引。MyISAM支持B+树不支持</p>
<h4 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h4><p><img src="https://jimhackking.github.io/%E8%BF%90%E7%BB%B4/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="二叉树"></p>
<p>二叉树的缺点可以用红黑树来解决：<br><img src="https://learning-logs-1253130399.cos.ap-guangzhou.myqcloud.com/editor/%E7%BA%A2%E9%BB%91%E6%A0%91_20220316163142686602.png" alt="红黑树"><br>红黑树也存在大数据量情况下，层级较深，检索速度慢的问题。</p>
<p>为了解决上述问题，可以使用 B-Tree 结构。<br>B-Tree (多路平衡查找树) 以一棵最大度数（max-degree，指一个节点的子节点个数）为5（5阶）的 b-tree 为例（每个节点最多存储4个key，5个指针）</p>
<p><img src="https://jimhackking.github.io/%E8%BF%90%E7%BB%B4/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/B-Tree%E7%BB%93%E6%9E%84.png" alt="B-Tree结构"></p>
<h4 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h4><p>结构图：</p>
<p><img src="https://jimhackking.github.io/%E8%BF%90%E7%BB%B4/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/B+Tree%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="B+Tree结构图"></p>
<blockquote>
<p>演示地址：<a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</a></p>
</blockquote>
<p>与 B-Tree 的区别：</p>
<ul>
<li>所有的数据都会出现在叶子节点</li>
<li>叶子节点形成一个单向链表</li>
</ul>
<p>MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高区间访问的性能。</p>
<p><img src="https://jimhackking.github.io/%E8%BF%90%E7%BB%B4/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="MySQL B+Tree 结构图"></p>
<h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p>哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。<br>如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。</p>
<p><img src="https://learning-logs-1253130399.cos.ap-guangzhou.myqcloud.com/editor/Hash%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%9B%BE_20220317143226150679.png" alt="Hash索引原理图"></p>
<p>特点：</p>
<ul>
<li>Hash索引只能用于对等比较（&#x3D;、in），不支持范围查询（betwwn、&gt;、&lt;、…）</li>
<li>无法利用索引完成排序操作</li>
<li>查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+Tree 索引</li>
</ul>
<p>存储引擎支持：</p>
<ul>
<li>Memory</li>
<li>InnoDB: 具有自适应hash功能，hash索引是存储引擎根据 B+Tree 索引在指定条件下自动构建的</li>
</ul>
<h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><ol>
<li>为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？</li>
</ol>
<ul>
<li>相对于二叉树，层级更少，搜索效率高</li>
<li>对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低</li>
<li>相对于 Hash 索引，B+Tree 支持范围匹配及排序操作</li>
</ul>
<h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>主键索引</td>
<td>针对于表中主键创建的索引</td>
<td>默认自动创建，只能有一个</td>
<td>PRIMARY</td>
</tr>
<tr>
<td>唯一索引</td>
<td>避免同一个表中某数据列中的值重复</td>
<td>可以有多个</td>
<td>UNIQUE</td>
</tr>
<tr>
<td>常规索引</td>
<td>快速定位特定数据</td>
<td>可以有多个</td>
<td></td>
</tr>
<tr>
<td>全文索引</td>
<td>全文索引查找的是文本中的关键词，而不是比较索引中的值</td>
<td>可以有多个</td>
<td>FULLTEXT</td>
</tr>
</tbody></table>
<p>在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种：</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>聚集索引(Clustered Index)</td>
<td>将数据存储与索引放一块，索引结构的叶子节点保存了行数据</td>
<td>必须有，而且只有一个</td>
</tr>
<tr>
<td>二级索引(Secondary Index)</td>
<td>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td>
<td>可以存在多个</td>
</tr>
</tbody></table>
<p>演示图：</p>
<p><img src="https://jimhackking.github.io/%E8%BF%90%E7%BB%B4/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="大致原理"><br><img src="https://learning-logs-1253130399.cos.ap-guangzhou.myqcloud.com/editor/%E6%BC%94%E7%A4%BA%E5%9B%BE_20220319215403721066.png" alt="演示图"></p>
<p>聚集索引选取规则：</p>
<ul>
<li>如果存在主键，主键索引就是聚集索引</li>
<li>如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引</li>
<li>如果表没有主键或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引</li>
</ul>
<h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><ol>
<li>以下 SQL 语句，哪个执行效率高？为什么？</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from user where id = 10;</span><br><span class="line">select * from user where name = &#x27;Arm&#x27;;</span><br><span class="line">-- 备注：id为主键，name字段创建的有索引</span><br></pre></td></tr></table></figure>

<p>答：第一条语句，因为第二条需要回表查询，相当于两个步骤。</p>
<ol start="2">
<li>InnoDB 主键索引的 B+Tree 高度为多少？</li>
</ol>
<p>答：假设一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB 的指针占用6个字节的空间，主键假设为bigint，占用字节数为8.<br>可得公式：<code>n * 8 + (n + 1) * 6 = 16 * 1024</code>，其中 8 表示 bigint 占用的字节数，n 表示当前节点存储的key的数量，(n + 1) 表示指针数量（比key多一个）。算出n约为1170。</p>
<p>如果树的高度为2，那么他能存储的数据量大概为：<code>1171 * 16 = 18736</code>；<br>如果树的高度为3，那么他能存储的数据量大概为：<code>1171 * 1171 * 16 = 21939856</code>。</p>
<h3 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h3><h4 id="最左前缀法则"><a href="#最左前缀法则" class="headerlink" title="最左前缀法则"></a>最左前缀法则</h4><p>如果索引关联了多列（联合索引），要遵守最左前缀法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。<br>如果跳跃某一列，索引将部分失效（后面的字段索引失效）。</p>
<p>联合索引中，出现范围查询（&lt;, &gt;），范围查询<strong>右侧的列索引失效。</strong>可以用&gt;&#x3D;或者&lt;&#x3D;来规避索引失效问题。</p>
<h4 id="索引失效情况"><a href="#索引失效情况" class="headerlink" title="索引失效情况"></a>索引失效情况</h4><ol>
<li><strong>在索引列上进行运算操作</strong>，索引将失效。如：<code>explain select * from tb_user where substring(phone, 10, 2) = &#39;15&#39;;</code></li>
<li>字符串类型字段使用时，不加<strong>单引号</strong>，索引将失效。如：<code>explain select * from tb_user where phone = 17799990015;</code>，此处phone的值没有加引号</li>
<li>模糊查询中，如果仅仅是尾部模糊匹配，索引不会是失效；如果是头部模糊匹配，索引失效。如：<code>explain select * from tb_user where profession like &#39;%工程&#39;;</code>，前<strong>后都有 % 也会失效</strong>。</li>
<li>用 or 分割开的条件，如果 <strong>or</strong> 其中一个条件的列没有索引，那么涉及的索引都不会被用到。</li>
<li>如果 MySQL 评估使用索引比全表更慢，则不使用索引。</li>
</ol>
<h4 id="SQL-提示"><a href="#SQL-提示" class="headerlink" title="SQL 提示"></a>SQL 提示</h4><p>是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</p>
<p>例如，使用索引：<br><code>explain select * from tb_user use index(idx_user_pro) where profession=&quot;软件工程&quot;;</code><br>不使用哪个索引：<br><code>explain select * from tb_user ignore index(idx_user_pro) where profession=&quot;软件工程&quot;;</code><br>必须使用哪个索引：<br><code>explain select * from tb_user force index(idx_user_pro) where profession=&quot;软件工程&quot;;</code></p>
<p>use 是建议，实际使用哪个索引 MySQL 还会自己权衡运行速度去更改，force就是无论如何都强制使用该索引。</p>
<h4 id="覆盖索引-回表查询"><a href="#覆盖索引-回表查询" class="headerlink" title="覆盖索引&amp;回表查询"></a>覆盖索引&amp;回表查询</h4><p>尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能找到），减少 select *。</p>
<p>explain 中 extra 字段含义：<br><code>using index condition</code>：查找使用了索引，但是需要回表查询数据<br><code>using where; using index;</code>：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询</p>
<p>如果在聚集索引中直接能找到对应的行，则直接返回行数据，只需要一次查询，哪怕是select *；如果在辅助索引中找聚集索引，如<code>select id, name from xxx where name=&#39;xxx&#39;;</code>，也只需要通过辅助索引(name)查找到对应的id，返回name和name索引对应的id即可，只需要一次查询；如果是通过辅助索引查找其他字段，则需要回表查询，如<code>select id, name, gender from xxx where name=&#39;xxx&#39;;</code></p>
<p>所以尽量不要用<code>select *</code>，容易出现回表查询，降低效率，除非有联合索引包含了所有字段</p>
<p>面试题：一张表，有四个字段（id, username, password, status），由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案：<br><code>select id, username, password from tb_user where username=&#39;itcast&#39;;</code></p>
<p>解：给username和password字段建立联合索引，则不需要回表查询，直接覆盖索引</p>
<h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>当字段类型为字符串（varchar, text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率，此时可以只降字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p>
<p>语法：<code>create index idx_xxxx on table_name(columnn(n));</code><br>前缀长度：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。<br>求选择性公式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(distinct email) / count(*) from tb_user;</span><br><span class="line">select count(distinct substring(email, 1, 5)) / count(*) from tb_user;</span><br></pre></td></tr></table></figure>

<p>show index 里面的sub_part可以看到接取的长度</p>
<h4 id="单列索引-联合索引"><a href="#单列索引-联合索引" class="headerlink" title="单列索引&amp;联合索引"></a>单列索引&amp;联合索引</h4><p>单列索引：即一个索引只包含单个列<br>联合索引：即一个索引包含了多个列<br>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。</p>
<p>单列索引情况：<br><code>explain select id, phone, name from tb_user where phone = &#39;17799990010&#39; and name = &#39;韩信&#39;;</code><br>这句只会用到phone索引字段</p>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ul>
<li>多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询</li>
</ul>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><ol>
<li>针对于数据量较大，且查询比较频繁的表建立索引</li>
<li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引</li>
<li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高</li>
<li>如果是字符串类型的字段，字段长度较长，可以针对于字段的特点，建立前缀索引</li>
<li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率</li>
<li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率</li>
<li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询</li>
</ol>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>锁是一种常见的并发事务的控制方式。</p>
<h3 id="表级锁和行级锁了解吗？有什么区别？"><a href="#表级锁和行级锁了解吗？有什么区别？" class="headerlink" title="表级锁和行级锁了解吗？有什么区别？"></a><a href="#%E8%A1%A8%E7%BA%A7%E9%94%81%E5%92%8C%E8%A1%8C%E7%BA%A7%E9%94%81%E4%BA%86%E8%A7%A3%E5%90%97-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">表级锁和行级锁了解吗？有什么区别？</a></h3><p>MyISAM 仅仅支持表级锁(table-level locking)，一锁就锁整张表，这在并发写的情况下性非常差。InnoDB 不光支持表级锁(table-level locking)，还支持行级锁(row-level locking)，默认为行级锁。</p>
<p>行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。</p>
<p><strong>表级锁和行级锁对比</strong>：</p>
<ul>
<li><strong>表级锁：</strong> MySQL 中锁定粒度最大的一种锁（全局锁除外），是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。不过，触发锁冲突的概率最高，高并发下效率极低。表级锁和存储引擎无关，MyISAM 和 InnoDB 引擎都支持表级锁。</li>
<li><strong>行级锁：</strong> MySQL 中锁定粒度最小的一种锁，是 <strong>针对索引字段加的锁</strong> ，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。行级锁和存储引擎有关，是在存储引擎层面实现的。</li>
</ul>
<h3 id="行级锁的使用有什么注意事项？"><a href="#行级锁的使用有什么注意事项？" class="headerlink" title="行级锁的使用有什么注意事项？"></a><a href="#%E8%A1%8C%E7%BA%A7%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">行级锁的使用有什么注意事项？</a></h3><p>InnoDB 的行锁是针对索引字段加的锁，表级锁是针对非索引字段加的锁。当我们执行 <code>UPDATE</code>、<code>DELETE</code> 语句时，如果 <code>WHERE</code>条件中字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁。这个在我们日常工作开发中经常会遇到，一定要多多注意！！！</p>
<p>不过，很多时候即使用了索引也有可能会走全表扫描，这是因为 MySQL 优化器的原因。</p>
<h3 id="InnoDB-有哪几类行锁？"><a href="#InnoDB-有哪几类行锁？" class="headerlink" title="InnoDB 有哪几类行锁？"></a><a href="#innodb-%E6%9C%89%E5%93%AA%E5%87%A0%E7%B1%BB%E8%A1%8C%E9%94%81">InnoDB 有哪几类行锁？</a></h3><p>InnoDB 行锁是通过对索引数据页上的记录加锁实现的，MySQL InnoDB 支持三种行锁定方式：</p>
<ul>
<li><strong>记录锁（Record Lock）</strong>：也被称为记录锁，属于单个行记录上的锁。</li>
<li><strong>间隙锁（Gap Lock）</strong>：锁定一个范围，不包括记录本身。</li>
<li><strong>临键锁（Next-Key Lock）</strong>：Record Lock+Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题（MySQL 事务部分提到过）。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</li>
</ul>
<p>**在 InnoDB 默认的隔离级别 REPEATABLE-READ 下，行锁默认使用的是 Next-Key Lock。但是，如果操作的索引是唯一索引或主键，InnoDB 会对 Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围。</p>
<h3 id="共享锁和排他锁呢？"><a href="#共享锁和排他锁呢？" class="headerlink" title="共享锁和排他锁呢？"></a><a href="#%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8C%E6%8E%92%E4%BB%96%E9%94%81%E5%91%A2">共享锁和排他锁呢？</a></h3><p>不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类：</p>
<ul>
<li><strong>共享锁（S 锁）</strong>：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</li>
<li><strong>排他锁（X 锁）</strong>：又称写锁&#x2F;独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）。</li>
</ul>
<p>排他锁与任何的锁都不兼容，共享锁仅和共享锁兼容。</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">S 锁</th>
<th align="left">X 锁</th>
</tr>
</thead>
<tbody><tr>
<td align="left">S 锁</td>
<td align="left">不冲突</td>
<td align="left">冲突</td>
</tr>
<tr>
<td align="left">X 锁</td>
<td align="left">冲突</td>
<td align="left">冲突</td>
</tr>
</tbody></table>
<p>由于 MVCC 的存在，对于一般的 <code>SELECT</code> 语句，InnoDB 不会加任何锁。不过， 你可以通过以下语句显式加共享锁或排他锁。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 共享锁 可以在 MySQL 5.7 和 MySQL 8.0 中使用</span><br><span class="line">SELECT ... LOCK IN SHARE MODE;</span><br><span class="line"># 共享锁 可以在 MySQL 8.0 中使用</span><br><span class="line">SELECT ... FOR SHARE;</span><br><span class="line"># 排他锁</span><br><span class="line">SELECT ... FOR UPDATE;</span><br><span class="line">------</span><br></pre></td></tr></table></figure>

<h3 id="意向锁有什么作用？"><a href="#意向锁有什么作用？" class="headerlink" title="意向锁有什么作用？"></a><a href="#%E6%84%8F%E5%90%91%E9%94%81%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8">意向锁有什么作用？</a></h3><p>如果需要用到表锁的话，如何判断表中的记录没有行锁呢，一行一行遍历肯定是不行，性能太差。我们需要用到一个叫做意向锁的东东来快速判断是否可以对某个表使用表锁。</p>
<p>意向锁是表级锁，共有两种：</p>
<ul>
<li><strong>意向共享锁（Intention Shared Lock，IS 锁）</strong>：事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。</li>
<li><strong>意向排他锁（Intention Exclusive Lock，IX 锁）</strong>：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。</li>
</ul>
<p><strong>意向锁是由数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享&#x2F;排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。</strong></p>
<p>意向锁之间是互相兼容的。</p>
<table>
<thead>
<tr>
<th></th>
<th>IS 锁</th>
<th>IX 锁</th>
</tr>
</thead>
<tbody><tr>
<td>IS 锁</td>
<td>兼容</td>
<td>兼容</td>
</tr>
<tr>
<td>IX 锁</td>
<td>兼容</td>
<td>兼容</td>
</tr>
</tbody></table>
<p>意向锁和共享锁和排它锁互斥（这里指的是表级别的共享锁和排他锁，意向锁不会与行级的共享锁和排他锁互斥）。</p>
<table>
<thead>
<tr>
<th></th>
<th>IS 锁</th>
<th>IX 锁</th>
</tr>
</thead>
<tbody><tr>
<td>S 锁</td>
<td>兼容</td>
<td>互斥</td>
</tr>
<tr>
<td>X 锁</td>
<td>互斥</td>
<td>互斥</td>
</tr>
</tbody></table>
<h3 id="当前读和快照读有什么区别？"><a href="#当前读和快照读有什么区别？" class="headerlink" title="当前读和快照读有什么区别？"></a><a href="#%E5%BD%93%E5%89%8D%E8%AF%BB%E5%92%8C%E5%BF%AB%E7%85%A7%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">当前读和快照读有什么区别？</a></h3><p><strong>快照读</strong>（一致性非锁定读）就是单纯的 <code>SELECT</code> 语句，但不包括下面这两类 <code>SELECT</code> 语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span></span><br><span class="line"># 共享锁 可以在 MySQL <span class="number">5.7</span> 和 MySQL <span class="number">8.0</span> 中使用</span><br><span class="line"><span class="keyword">SELECT</span> ... LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line"># 共享锁 可以在 MySQL <span class="number">8.0</span> 中使用</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> SHARE;</span><br></pre></td></tr></table></figure>

<p>快照即记录的历史版本，每行记录可能存在多个历史版本（多版本技术）。</p>
<p>快照读的情况下，如果读取的记录正在执行 UPDATE&#x2F;DELETE 操作，读取操作不会因此去等待记录上 X 锁的释放，而是会去读取行的一个快照。</p>
<p>只有在事务隔离级别 RC(读取已提交) 和 RR（可重读）下，InnoDB 才会使用一致性非锁定读：</p>
<ul>
<li>在 RC 级别下，对于快照数据，一致性非锁定读总是读取被锁定行的最新一份快照数据。</li>
<li>在 RR 级别下，对于快照数据，一致性非锁定读总是读取本事务开始时的行数据版本。</li>
</ul>
<p>快照读比较适合对于数据一致性要求不是特别高且追求极致性能的业务场景。</p>
<p><strong>当前读</strong> （一致性锁定读）就是给行记录加 X 锁或 S 锁。</p>
<p>当前读的一些常见 SQL 语句类型如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 对读的记录加一个X锁</span><br><span class="line">SELECT...FOR <span class="keyword">UPDATE</span></span><br><span class="line"># 对读的记录加一个S锁</span><br><span class="line">SELECT...LOCK <span class="keyword">IN</span> SHARE MODE</span><br><span class="line"># 对读的记录加一个S锁</span><br><span class="line">SELECT...FOR SHARE</span><br><span class="line"># 对修改的记录加一个X锁</span><br><span class="line">INSERT...</span><br><span class="line">UPDATE...</span><br><span class="line">DELETE...</span><br></pre></td></tr></table></figure>

<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p>
<h3 id="四大特性ACID"><a href="#四大特性ACID" class="headerlink" title="四大特性ACID"></a>四大特性ACID</h3><ul>
<li>原子性(Atomicity)：事务是不可分割的最小操作但愿，要么全部成功，要么全部失败</li>
<li>一致性(Consistency)：事务完成时，必须使所有数据都保持一致状态</li>
<li>隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li>
<li>持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</li>
</ul>
<h3 id="并发事务"><a href="#并发事务" class="headerlink" title="并发事务"></a>并发事务</h3><table>
<thead>
<tr>
<th>问题</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>脏读</td>
<td>一个事务读到另一个事务还没提交的数据</td>
</tr>
<tr>
<td>不可重复读</td>
<td>一个事务先后读取同一条记录，但两次读取的数据不同</td>
</tr>
<tr>
<td>幻读</td>
<td>一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存在</td>
</tr>
</tbody></table>
<h3 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h3><h4 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h4><p><code>redo log</code>（重做日志）是<code>InnoDB</code>存储引擎独有的，它让<code>MySQL</code>拥有了崩溃恢复能力。</p>
<p>比如 <code>MySQL</code> 实例挂了或宕机了，重启时，<code>InnoDB</code>存储引擎会使用<code>redo log</code>恢复数据，保证数据的持久性与完整性。</p>
<p><img src="/2023/03/17/mysql/02.png"></p>
<p><code>MySQL</code> 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 <code>Buffer Pool</code> 中。</p>
<p>后续的查询都是先从 <code>Buffer Pool</code> 中找，没有命中再去硬盘加载，减少硬盘 <code>IO</code> 开销，提升性能。</p>
<p>更新表数据的时候，也是如此，发现 <code>Buffer Pool</code> 里存在要更新的数据，就直接在 <code>Buffer Pool</code> 里更新。</p>
<p>然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（<code>redo log buffer</code>）里，接着刷盘到 <code>redo log</code> 文件里。</p>
<p><img src="/2023/03/17/mysql/03.png"></p>
<blockquote>
<p>图片笔误提示：第 4 步 “清空 redo log buffe 刷盘到 redo 日志中”这句话中的 buffe 应该是 buffer。</p>
</blockquote>
<p>理想情况，事务一提交就会进行刷盘操作，但实际上，刷盘的时机是根据策略来进行的。</p>
<blockquote>
<p>小贴士：每条 redo 记录由“表空间号+数据页号+偏移量+修改数据长度+具体修改的数据”组成</p>
</blockquote>
<h4 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a><a href="#binlog">binlog</a></h4><p><code>redo log</code> 它是物理日志，记录内容是“在某个数据页上做了什么修改”，属于 <code>InnoDB</code> 存储引擎。</p>
<p>而 <code>binlog</code> 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID&#x3D;2 这一行的 c 字段加 1”，属于<code>MySQL Server</code> 层。</p>
<p>不管用什么存储引擎，只要发生了表数据更新，都会产生 <code>binlog</code> 日志。</p>
<p>那 <code>binlog</code> 到底是用来干嘛的？</p>
<p>可以说<code>MySQL</code>数据库的<strong>数据备份、主备、主主、主从</strong>都离不开<code>binlog</code>，需要依靠<code>binlog</code>来同步数据，保证数据一致性。</p>
<p><img src="/2023/03/17/mysql/04.png" alt="img"></p>
<p><code>binlog</code>会记录所有涉及更新数据的逻辑操作，并且是顺序写。</p>
<h3 id="MVCC-基本概念"><a href="#MVCC-基本概念" class="headerlink" title="MVCC-基本概念"></a>MVCC-基本概念</h3><h4 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h4><p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：<br>select..lock in share mode(共享锁)，select.for update、update、insert、delete(排他锁)都是一种当前读。</p>
<h4 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h4><p>简单的select(不加锁)就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。<br>Read Committed: 每次select,都生成一个快照读。<br>Repeatable Read: 开启事务后第一个select语句才是快照读的地方。<br>Serializable: 快照读会退化为当前读。</p>
<h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><p>全称Multi-Version Concurrency Control,多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现<br>MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log日志、readView。</p>
<h5 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h5><p><img src="/2023/03/17/mysql/%E9%9A%90%E8%97%8F%E5%AD%97%E6%AE%B5.png" alt="隐藏字段作用"></p>
<h4 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h4><p>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。<br>当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。<br>而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即被删除。</p>
<blockquote>
<p>这部分内容为 JavaGuide 的补充：</p>
</blockquote>
<p>我们知道如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行<strong>回滚</strong>，在 MySQL 中，恢复机制是通过 <strong>回滚日志（undo log）</strong> 实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用 <strong>回滚日志</strong> 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。</p>
<h5 id="undo-log版本链"><a href="#undo-log版本链" class="headerlink" title="undo log版本链"></a>undo log版本链</h5><p><img src="/2023/03/17/mysql/%E7%89%88%E6%9C%AC%E9%93%BE.png"></p>
<p>不同事务或相同事务对同一条记录进行修改，会导致该记录的undo log生成一条记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。</p>
<h4 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h4><p>ReadView(读视图)是快照读SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id。<br>ReadView中包含了四个核心字段：</p>
<p><img src="/2023/03/17/mysql/%E5%AD%97%E6%AE%B5.png"></p>
<p><img src="/2023/03/17/mysql/%E8%A7%84%E5%88%99.png"></p>
<h4 id="RC（读取已提交）"><a href="#RC（读取已提交）" class="headerlink" title="RC（读取已提交）"></a>RC（读取已提交）</h4><p>在 RC 隔离级别下的 <strong><code>每次select</code></strong> 查询前都生成一个<code>Read View</code> (m_ids 列表)</p>
<p><img src="/2023/03/17/mysql/RC.png"></p>
<h4 id="RR（可重复读）"><a href="#RR（可重复读）" class="headerlink" title="RR（可重复读）"></a>RR（可重复读）</h4><p>在可重复读级别下，只会在事务开始后第一次读取数据时生成一个 Read View（m_ids 列表）</p>
<p>另外，<code>MVCC</code> 的实现依赖于：<strong>隐藏字段、Read View、undo log</strong>。在内部实现中，<code>InnoDB</code> 通过数据行的 <code>DB_TRX_ID</code> 和 <code>Read View</code> 来判断数据的可见性，如不可见，则通过数据行的 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 <code>Read View</code> 之前已经提交的修改和该事务本身做的修改</p>
]]></content>
  </entry>
  <entry>
    <title>Java八股</title>
    <url>/2023/12/01/Java%E5%85%AB%E8%82%A1/</url>
    <content><![CDATA[<h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="1-Java语言有哪些特点？"><a href="#1-Java语言有哪些特点？" class="headerlink" title="1.Java语言有哪些特点？"></a>1.Java语言有哪些特点？</h3><ol>
<li>简单易学；</li>
<li>面向对象（封装，继承，多态）；</li>
<li>平台无关性（ Java 虚拟机实现平台无关性）；</li>
<li>支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；</li>
<li>可靠性（具备异常处理和自动内存管理机制）；</li>
<li>安全性（Java 语言本身的设计就提供了多重安全防护机制如访问权限修饰符、限制程序直接访问操作系统资源）；</li>
<li>高效性（通过 Just In Time 编译器等技术的优化，Java 语言的运行效率还是非常不错的）；</li>
<li>支持网络编程并且很方便；</li>
</ol>
<h3 id="2-JVM、JDK-和-JRE-有什么区别？"><a href="#2-JVM、JDK-和-JRE-有什么区别？" class="headerlink" title="2.JVM、JDK 和 JRE 有什么区别？"></a>2.JVM、JDK 和 JRE 有什么区别？</h3><p><strong>JVM</strong>：Java Virtual Machine，Java 虚拟机，Java 程序运行在 Java 虚拟机上。针对不同系统的实现（Windows，Linux，macOS）不同的 JVM，因此 Java 语言可以实现跨平台。</p>
<p><strong>JRE</strong>： Java 运⾏时环境。它是运⾏已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，Java 命令和其他的⼀些基础构件。但是，它不能⽤于创建新程序。</p>
<p><strong>JDK</strong>: Java Development Kit，它是功能⻬全的 Java SDK。它拥有 JRE 所拥有的⼀切，还有编译器（javac）和⼯具（如 javadoc 和 jdb）。它能够创建和编译程序。</p>
<p><img src="/2024/12/09/hello-world/e-3.png"></p>
<h3 id="3-什么是字节码？采用字节码的好处是什么"><a href="#3-什么是字节码？采用字节码的好处是什么" class="headerlink" title="3.什么是字节码？采用字节码的好处是什么?"></a>3.什么是字节码？采用字节码的好处是什么?</h3><p>所谓的字节码，就是 Java 程序经过编译之类产生的.class 文件，字节码能够被虚拟机识别，从而实现 Java 程序的跨平台性。</p>
<p><strong>Java</strong> 程序从源代码到运行主要有三步：</p>
<ul>
<li><strong>编译</strong>：将我们的代码（.java）编译成虚拟机可以识别理解的字节码(.class)</li>
<li><strong>解释</strong>：虚拟机执行 Java 字节码，将字节码翻译成机器能识别的机器码</li>
<li><strong>执行</strong>：对应的机器执行二进制机器码</li>
</ul>
<p>Java程序执行过程只需要把 Java 程序编译成 Java 虚拟机能识别的 Java 字节码，不同的平台安装对应的 Java 虚拟机，这样就可以可以实现 Java 语言的平台无关性。</p>
<h3 id="4-为什么说-Java-语言“编译与解释并存”"><a href="#4-为什么说-Java-语言“编译与解释并存”" class="headerlink" title="4.为什么说 Java 语言“编译与解释并存”"></a>4.为什么说 Java 语言“编译与解释并存”</h3><p>其实这个问题我们讲字节码的时候已经提到过，因为比较重要，所以我们这里再提一下。</p>
<p>我们可以将高级编程语言按照程序的执行方式分为两种：</p>
<ul>
<li><p><strong>编译型</strong>：<a href="https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E8%AA%9E%E8%A8%80">编译型语言open in new window</a> 会通过<a href="https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E5%99%A8">编译器open in new window</a>将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。</p>
</li>
<li><p><strong>解释型</strong>：<a href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E8%AA%9E%E8%A8%80">解释型语言open in new window</a>会通过<a href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E5%99%A8">解释器open in new window</a>一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。</p>
<p><img src="/2024/12/09/hello-world/led-and-interpreted-languages.png" alt="compiled-and-interpreted-languages"></p>
<p>根据维基百科介绍：</p>
<blockquote>
<p>为了改善编译语言的效率而发展出的<a href="https://zh.wikipedia.org/wiki/%E5%8D%B3%E6%99%82%E7%B7%A8%E8%AD%AF">即时编译open in new window</a>技术，已经缩小了这两种语言间的差距。这种技术混合了编译语言与解释型语言的优点，它像编译语言一样，先把程序源代码编译成<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E7%A0%81">字节码open in new window</a>。到执行期时，再将字节码直译，之后执行。<a href="https://zh.wikipedia.org/wiki/Java">Javaopen in new window</a>与<a href="https://zh.wikipedia.org/wiki/LLVM">LLVMopen in new window</a>是这种技术的代表产物。</p>
<p>相关阅读：<a href="https://tech.meituan.com/2020/10/22/java-jit-practice-in-meituan.html">基本功 | Java 即时编译器原理解析及实践open in new window</a></p>
</blockquote>
<p><strong>为什么说 Java 语言“编译与解释并存”？</strong></p>
<p>这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>.class</code> 文件），这种字节码必须由 Java 解释器来解释执行。</p>
</li>
</ul>
<h3 id="5-注释有哪几种形式？"><a href="#5-注释有哪几种形式？" class="headerlink" title="5.注释有哪几种形式？"></a>5.注释有哪几种形式？</h3><ol>
<li><strong>单行注释</strong>：通常用于解释方法内某单行代码的作用。</li>
<li><strong>多行注释</strong>：通常用于解释一段代码的作用。</li>
<li><strong>文档注释</strong>：通常用于生成 Java 开发文档。</li>
</ol>
<h3 id="6-标识符和关键字的区别是什么？"><a href="#6-标识符和关键字的区别是什么？" class="headerlink" title="6.标识符和关键字的区别是什么？"></a>6.标识符和关键字的区别是什么？</h3><p>在我们编写程序的时候，需要大量地为程序、类、变量、方法等取名字，于是就有了 <strong>标识符</strong> 。简单来说， <strong>标识符就是一个名字</strong> 。</p>
<p>有一些标识符，Java 语言已经赋予了其特殊的含义，只能用于特定的地方，这些特殊的标识符就是 <strong>关键字</strong> 。简单来说，<strong>关键字是被赋予特殊含义的标识符</strong> 。例如访问控制中 private protected public</p>
<h3 id="7-Java-语言关键字有哪些？"><a href="#7-Java-语言关键字有哪些？" class="headerlink" title="7.Java 语言关键字有哪些？"></a>7.Java 语言关键字有哪些？</h3><p><img src="/2024/12/09/hello-world/45558562.png" alt="1708945558562"></p>
<h3 id="8-自增自减运算符"><a href="#8-自增自减运算符" class="headerlink" title="8.自增自减运算符"></a>8.自增自减运算符</h3><p>在写代码的过程中，常见的一种情况是需要某个整数类型变量增加 1 或减少 1，Java 提供了一种特殊的运算符，用于这种表达式，叫做自增运算符（++)和自减运算符（–）。</p>
<p>++ 和 – 运算符可以放在变量之前，也可以放在变量之后，当运算符放在<strong>变量之前</strong>时(前缀)，<strong>先自增&#x2F;减</strong>，<strong>再赋值</strong>；当运算符放在<strong>变量之后</strong>时(后缀)，<strong>先赋值，再自增&#x2F;减</strong>。例如，当 <code>b = ++a</code> 时，先自增（自己增加 1），再赋值（赋值给 b）；当 <code>b = a++</code> 时，先赋值(赋值给 b)，再自增（自己增加 1）。也就是，++a 输出的是 a+1 的值，a++输出的是 a 值。用一句口诀就是：“<strong>符号在前就先加&#x2F;减，符号在后就后加&#x2F;减</strong>”。</p>
<h3 id="9-移位运算符"><a href="#9-移位运算符" class="headerlink" title="9.移位运算符"></a>9.移位运算符</h3><p>在 Java 代码里使用 <code>&lt;&lt;</code>、 <code>&gt;&gt;</code> 和<code>&gt;&gt;&gt;</code>转换成的指令码运行起来会更高效些。</p>
<p>掌握最基本的移位运算符知识还是很有必要的，这不光可以帮助我们在代码中使用，还可以帮助我们理解源码中涉及到移位运算符的代码。</p>
<p>Java 中有三种移位运算符：</p>
<p><img src="/2024/12/09/hello-world/45587466.png" alt="1708945587466"></p>
<p>Java 移位运算符总结</p>
<ul>
<li><code>&lt;&lt;</code> :左移运算符，向左移若干位，高位丢弃，低位补零。<code>x &lt;&lt; 1</code>,相当于 <strong>x 乘以 2</strong>(不溢出的情况下)。</li>
<li><code>&gt;&gt;</code> :带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。<code>x &gt;&gt; 1</code>,<strong>相当于 x 除以 2。</strong></li>
<li><code>&gt;&gt;&gt;</code> :<strong>无符号右移</strong>，忽略符号位，空位都以 0 补齐。</li>
</ul>
<p>由于 <code>double</code>，<code>float</code> 在二进制中的表现比较特殊，因此不能来进行移位操作。</p>
<p>移位操作符实际上支持的类型只有<code>int</code>和<code>long</code>，编译器在对<code>short</code>、<code>byte</code>、<code>char</code>类型进行移位前，都会将其转换为<code>int</code>类型再操作。</p>
<h3 id="10-continue、break-和-return-的区别是什么？"><a href="#10-continue、break-和-return-的区别是什么？" class="headerlink" title="10.continue、break 和 return 的区别是什么？"></a>10.continue、break 和 return 的区别是什么？</h3><ol>
<li><code>continue</code>：指跳出当前的这一次循环，继续下一次循环。</li>
<li><code>break</code>：指跳出整个循环体，继续执行循环下面的语句。</li>
</ol>
<p><code>return</code> 用于跳出所在方法，结束该方法的运行。return 一般有两种用法：</p>
<ol>
<li><code>return;</code>：直接使用 return 结束方法执行，用于没有返回值函数的方法</li>
<li><code>return value;</code>：return 一个特定值，用于有返回值函数的方法</li>
</ol>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="1-Java-中的几种基本数据类型了解么？"><a href="#1-Java-中的几种基本数据类型了解么？" class="headerlink" title="1.Java 中的几种基本数据类型了解么？"></a>1.Java 中的几种基本数据类型了解么？</h3><p>Java 中有 8 种基本数据类型，分别为：</p>
<ul>
<li>6 种数字类型： <ul>
<li>4 种整数型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li>
<li>2 种浮点型：<code>float</code>、<code>double</code></li>
</ul>
</li>
<li>1 种字符类型：<code>char</code></li>
<li>1 种布尔型：<code>boolean</code></li>
</ul>
<p><img src="/2024/12/09/hello-world/45686646.png" alt="1708945686646"></p>
<p><strong>注意：</strong></p>
<ol>
<li>Java 里使用 <code>long</code> 类型的数据一定要在数值后面加上 <strong>L</strong>，否则将作为整型解析。</li>
<li><code>char a = &#39;h&#39;</code>char :单引号，<code>String a = &quot;hello&quot;</code> :双引号。</li>
</ol>
<p>这八种基本类型都有对应的包装类分别为：<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code> 。</p>
<h3 id="2-switch-是否能作用在-byte-long-String-上？"><a href="#2-switch-是否能作用在-byte-long-String-上？" class="headerlink" title="2.switch 是否能作用在 byte&#x2F;long&#x2F;String 上？"></a>2.switch 是否能作用在 byte&#x2F;long&#x2F;String 上？</h3><p>Java5 以前 switch(expr)中，expr 只能是 byte、short、char、int。</p>
<p>从 Java 5 开始，Java 中引入了枚举类型， expr 也可以是 enum 类型。</p>
<p>从 Java 7 开始，expr 还可以是字符串(String)，但是长整型(long)在目前所有的版本中都是不可以的。</p>
<h3 id="3-和-有什么区别？"><a href="#3-和-有什么区别？" class="headerlink" title="3.&amp;和&amp;&amp;有什么区别？"></a>3.&amp;和&amp;&amp;有什么区别？</h3><p>&amp;运算符有两种用法：<code>短路与</code>、<code>逻辑与</code>。</p>
<p>&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是 true 整个表达式的值才是 true。</p>
<p>&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&amp;&amp;而不是&amp;。</p>
<p>例如在验证用户登录时判定用户名不是 null 而且不是空字符串，应当写为<code>username != null &amp;&amp;!username.equals(&quot;&quot;)</code>，二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的 equals 比较，否则会产生 NullPointerException 异常。</p>
<p><strong>注意</strong>：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。</p>
<h3 id="4-基本类型和包装类型的区别"><a href="#4-基本类型和包装类型的区别" class="headerlink" title="4.基本类型和包装类型的区别"></a>4.基本类型和包装类型的区别</h3><p><img src="/2024/12/09/hello-world/tive-type-vs-packaging-type.png" alt="基本类型 vs 包装类型"></p>
<p><strong>用途</strong>：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不可以。</p>
<p><strong>存储方式</strong>：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。</p>
<p><strong>占用空间</strong>：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。</p>
<p><strong>默认值</strong>：成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</p>
<p><strong>比较方式</strong>：对于基本数据类型来说，<code>==</code> 比较的是值。对于包装数据类型来说，<code>==</code> 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 <code>equals()</code> 方法。</p>
<p>⚠️ 注意：<strong>基本数据类型存放在栈中是一个常见的误区！</strong> 基本数据类型的存储位置取决于它们的作用域和声明方式。如果它们是局部变量，那么它们会存放在栈中；如果它们是成员变量，那么它们会存放在堆中。</p>
<h3 id="5-包装类型的缓存机制了解么？"><a href="#5-包装类型的缓存机制了解么？" class="headerlink" title="5.包装类型的缓存机制了解么？"></a>5.<a href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E4%B9%88">包装类型的缓存机制了解么？</a></h3><p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。</p>
<p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p>
<h3 id="6-自动装箱与拆箱了解吗？原理是什么"><a href="#6-自动装箱与拆箱了解吗？原理是什么" class="headerlink" title="6.自动装箱与拆箱了解吗？原理是什么"></a>6.自动装箱与拆箱了解吗？原理是什么</h3><p><strong>什么是自动拆装箱？</strong></p>
<ul>
<li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li>
<li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li>
</ul>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;  <span class="comment">//装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;   <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure>

<p>根据字节码发现装箱其实就是调用了 包装类的<code>valueOf()</code>方法，拆箱其实就是调用了 <code>xxxValue()</code>方法。</p>
<p>因此，</p>
<ul>
<li><code>Integer i = 10</code> 等价于 <code>Integer i = Integer.valueOf(10)</code></li>
<li><code>int n = i</code> 等价于 <code>int n = i.intValue()</code>;</li>
</ul>
<p>注意：<strong>如果频繁拆装箱的话，也会严重影响系统的性能。应该尽量避免不必要的拆装箱操作。</strong></p>
<h3 id="7-为什么浮点数运算的时候会有精度丢失的风险？"><a href="#7-为什么浮点数运算的时候会有精度丢失的风险？" class="headerlink" title="7.为什么浮点数运算的时候会有精度丢失的风险？"></a>7.为什么浮点数运算的时候会有精度丢失的风险？</h3><p>浮点数运算精度丢失代码演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2.0f</span> - <span class="number">1.9f</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1.8f</span> - <span class="number">1.7f</span>;</span><br><span class="line">System.out.println(a);<span class="comment">// 0.100000024</span></span><br><span class="line">System.out.println(b);<span class="comment">// 0.099999905</span></span><br><span class="line">System.out.println(a == b);<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>这个和计算机保存浮点数的机制有很大关系。我们知道计算机是<strong>二进制</strong>的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被<strong>截断</strong>，所以就会导致小数精度发生损失的情况。</p>
<h3 id="8-如何解决浮点数运算的精度丢失问题？"><a href="#8-如何解决浮点数运算的精度丢失问题？" class="headerlink" title="8.如何解决浮点数运算的精度丢失问题？"></a>8.如何解决浮点数运算的精度丢失问题？</h3><p><code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 <code>BigDecimal</code> 来做的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">x</span> <span class="operator">=</span> a.subtract(b);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">y</span> <span class="operator">=</span> b.subtract(c);</span><br><span class="line"></span><br><span class="line">System.out.println(x); <span class="comment">/* 0.1 */</span></span><br><span class="line">System.out.println(y); <span class="comment">/* 0.1 */</span></span><br><span class="line">System.out.println(Objects.equals(x, y)); <span class="comment">/* true */</span></span><br></pre></td></tr></table></figure>

<h3 id="9-超过-long-整型的数据应该如何表示？"><a href="#9-超过-long-整型的数据应该如何表示？" class="headerlink" title="9.超过 long 整型的数据应该如何表示？"></a>9.超过 long 整型的数据应该如何表示？</h3><p>基本数值类型都有一个表达范围，如果超过这个范围就会有数值溢出的风险。</p>
<p>在 Java 中，64 位 long 整型是最大的整数类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> Long.MAX_VALUE;</span><br><span class="line">System.out.println(l + <span class="number">1</span>); <span class="comment">// -9223372036854775808</span></span><br><span class="line">System.out.println(l + <span class="number">1</span> == Long.MIN_VALUE); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>BigInteger</code> 内部使用 <code>int[]</code> 数组来存储<strong>任意大小</strong>的整形数据。</p>
<p>相对于常规整数类型的运算来说，<code>BigInteger</code> 运算的效率会相对较<strong>低</strong>。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="1-成员变量与局部变量的区别？"><a href="#1-成员变量与局部变量的区别？" class="headerlink" title="1.成员变量与局部变量的区别？"></a>1.成员变量与局部变量的区别？</h3><p><img src="/2024/12/09/hello-world/48797579.png" alt="成员变量 vs 局部变量"></p>
<ul>
<li><strong>语法形式</strong>：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</li>
<li><strong>存储方式</strong>：从变量在内存中的存储方式来看，如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li>
<li><strong>生存时间</strong>：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。</li>
<li><strong>默认值</strong>：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li>
</ul>
<p><strong>为什么成员变量有默认值？</strong></p>
<ol>
<li>先不考虑变量类型，如果没有<strong>默认值</strong>会怎样？变量存储的是内存地址对应的任意随机值，程序读取该值运行会出现<strong>意外</strong>。</li>
<li>默认值有两种设置方式：手动和自动，根据第一点，<strong>没有手动赋值一定要自动赋值</strong>。成员变量在运行时可借助反射等方法手动赋值，而局部变量不行。</li>
<li>对于编译器（javac）来说，局部变量没赋值很好判断，可以直接报错。而成员变量可能是运行时赋值，无法判断，误报“没默认值”又会影响用户体验，所以采用<strong>自动赋默认值</strong>。</li>
</ol>
<h3 id="2-静态变量有什么作用？"><a href="#2-静态变量有什么作用？" class="headerlink" title="2.静态变量有什么作用？"></a>2.静态变量有什么作用？</h3><p>静态变量也就是被 <code>static</code> 关键字修饰的变量。它可以被类的<strong>所有实例共享</strong>，无论一个类创建了多少个对象，它们都共享同一份静态变量。也就是说，静态变量只会被<strong>分配一次内存</strong>，即使创建多个对象，这样可以节省内存。</p>
<p>静态变量是通过类名来访问的，例如<code>StaticVariableExample.staticVar</code>（如果被 <code>private</code>关键字修饰就无法这样访问了）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticVariableExample</span> &#123;</span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">staticVar</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常情况下，静态变量会被 <code>final</code> 关键字修饰成为常量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstantVariableExample</span> &#123;</span><br><span class="line">    <span class="comment">// 常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">constantVar</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符型常量和字符串常量的区别"><a href="#字符型常量和字符串常量的区别" class="headerlink" title="字符型常量和字符串常量的区别?"></a><a href="#%E5%AD%97%E7%AC%A6%E5%9E%8B%E5%B8%B8%E9%87%8F%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB">字符型常量和字符串常量的区别?</a></h3><ul>
<li><strong>形式</strong> : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。</li>
<li><strong>含义</strong> : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)。</li>
<li><strong>占内存大小</strong>：字符常量只占 2 个字节; 字符串常量占若干个字节。</li>
</ul>
<p>字符串常量可通过s.toCharArray()获取char数组，也可以通过s.charAt(位置)获取</p>
<p>⚠️ 注意 <code>char</code> 在 Java 中占两个字节。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="1-什么是方法的返回值-方法有哪几种类型？"><a href="#1-什么是方法的返回值-方法有哪几种类型？" class="headerlink" title="1.什么是方法的返回值?方法有哪几种类型？"></a>1.什么是方法的返回值?方法有哪几种类型？</h3><p><strong>方法的返回值</strong> 是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用是接收出结果，使得它可以用于其他的操作！</p>
<p>我们可以按照方法的返回值和参数类型将方法分为下面这几种：</p>
<p>1、无参数无返回值的方法<br>2、有参数无返回值的方法<br>3、有返回值无参数的方法<br>4、有返回值有参数的方法</p>
<h3 id="2-静态方法为什么不能调用非静态成员"><a href="#2-静态方法为什么不能调用非静态成员" class="headerlink" title="2.静态方法为什么不能调用非静态成员?"></a>2.静态方法为什么不能调用非静态成员?</h3><p>这个需要结合 JVM 的相关知识，主要原因如下：</p>
<ol>
<li>静态方法是属于类的，在<strong>类加载</strong>的时候就会分配内存，可以通过<strong>类名直接访问</strong>。而非静态成员属于实例对象，只有在<strong>对象实例化</strong>之后才存在，需要通过类的实例对象去访问。</li>
<li>在类的非静态成员不存在的时候静态方法就<strong>已经存在</strong>了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个字符型常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">char</span> <span class="variable">LETTER_A</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个字符串常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">GREETING_MESSAGE</span> <span class="operator">=</span> <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 输出字符型常量的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;字符型常量的值为：&quot;</span> + LETTER_A);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出字符串常量的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;字符串常量的值为：&quot;</span> + GREETING_MESSAGE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-静态方法和实例方法有何不同？"><a href="#3-静态方法和实例方法有何不同？" class="headerlink" title="3.静态方法和实例方法有何不同？"></a>3.静态方法和实例方法有何不同？</h3><p><strong>1、调用方式</strong></p>
<p>在外部调用静态方法时，可以使用 <code>类名.方法名</code> 的方式，也可以使用 <code>对象.方法名</code> 的方式，而实例方法只有后面这种方式。也就是说，<strong>调用静态方法可以无需创建对象</strong> 。</p>
<p>不过，需要注意的是一般不建议使用 <code>对象.方法名</code> 的方式来调用静态方法。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。</p>
<p>因此，一般建议使用 <code>类名.方法名</code> 的方式来调用静态方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staicMethod</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="comment">// 调用实例方法</span></span><br><span class="line">        person.method();</span><br><span class="line">        <span class="comment">// 调用静态方法</span></span><br><span class="line">        Person.staicMethod()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、访问类成员是否存在限制</strong></p>
<p>静态方法在访问本类的成员时，<strong>只允许访问静态成员</strong>（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。</p>
<h3 id="4-重载和重写有什么区别？"><a href="#4-重载和重写有什么区别？" class="headerlink" title="4.重载和重写有什么区别？"></a>4.重载和重写有什么区别？</h3><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>发生在同一个类中（或者父类和子类之间），<strong>方法名必须相同</strong>，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p>
<p>综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理</p>
<h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p>
<ol>
<li>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型<strong>更小或相等</strong>，抛出的异常范围<strong>小于</strong>等于父类，访问修饰符范围<strong>大于</strong>等于父类。</li>
<li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</li>
<li>构造方法无法被重写</li>
</ol>
<p>综上：<strong>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</strong></p>
<table>
<thead>
<tr>
<th align="left">区别点</th>
<th align="left">重载方法</th>
<th align="left">重写方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">发生范围</td>
<td align="left">同一个类</td>
<td align="left">子类</td>
</tr>
<tr>
<td align="left">参数列表</td>
<td align="left">必须修改</td>
<td align="left">一定不能修改</td>
</tr>
<tr>
<td align="left">返回类型</td>
<td align="left">可修改</td>
<td align="left">子类方法返回值类型应比父类方法返回值类型更小或相等</td>
</tr>
<tr>
<td align="left">异常</td>
<td align="left">可修改</td>
<td align="left">子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td>
</tr>
<tr>
<td align="left">访问修饰符</td>
<td align="left">可修改</td>
<td align="left">一定不能做更严格的限制（可以降低限制）</td>
</tr>
<tr>
<td align="left">发生阶段</td>
<td align="left">编译期</td>
<td align="left">运行期</td>
</tr>
</tbody></table>
<p><strong>方法的重写要遵循“两同两小一大”</strong>：</p>
<ul>
<li>“两同”即方法名相同、形参列表相同；</li>
<li>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li>
<li>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li>
</ul>
<p>⭐️ 关于 <strong>重写的返回值类型</strong> 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</p>
<h3 id="5-什么是可变长参数？（选）"><a href="#5-什么是可变长参数？（选）" class="headerlink" title="5.什么是可变长参数？（选）"></a>5.什么是可变长参数？（选）</h3><p>从 Java5 开始，Java 支持定义可变长参数，所谓可变长参数就是允许在调用方法时传入不定长度的参数。就比如下面的这个 <code>printVariable</code> 方法就可以接受 0 个或者多个参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">   <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(String arg1, String... args)</span> &#123;</span><br><span class="line">   <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？</strong></p>
<p>答案是会优先匹配固定参数的方法，因为固定参数的方法匹配度更高。</p>
<h2 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h2><h3 id="1-面向对象和面向过程的区别"><a href="#1-面向对象和面向过程的区别" class="headerlink" title="1.面向对象和面向过程的区别"></a>1.面向对象和面向过程的区别</h3><p>两者的主要区别在于解决问题的方式不同：</p>
<ul>
<li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li>
<li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li>
</ul>
<p>另外，面向对象开发的程序一般更易维护、易复用、易扩展。</p>
<h3 id="2-面向对象三大特征"><a href="#2-面向对象三大特征" class="headerlink" title="2.面向对象三大特征"></a>2.面向对象三大特征</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p>
<p><strong>关于继承如下 3 点请记住：</strong></p>
<ol>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li>
</ol>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</p>
<p><strong>多态的特点:</strong></p>
<ul>
<li>对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系；</li>
<li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li>
<li>多态不能调用“只在子类存在但在父类不存在”的方法；</li>
<li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父</li>
</ul>
<h3 id="3-重载（overload）和重写（override）的区别？"><a href="#3-重载（overload）和重写（override）的区别？" class="headerlink" title="3.重载（overload）和重写（override）的区别？"></a>3.重载（overload）和重写（override）的区别？</h3><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</p>
<ul>
<li>重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；</li>
<li>重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。</li>
</ul>
<p>方法重载的规则：</p>
<ol>
<li>方法名一致，参数列表中参数的顺序，类型，个数不同。</li>
<li>重载与方法的返回值无关，存在于父类和子类，同类中。</li>
<li>可以抛出不同的异常，可以有不同修饰符。</li>
</ol>
<h3 id="4-this-关键字有什么作用？"><a href="#4-this-关键字有什么作用？" class="headerlink" title="4.this 关键字有什么作用？"></a>4.this 关键字有什么作用？</h3><p>this 是自身的一个对象，代表对象本身，可以理解为：<strong>指向对象本身的一个指针</strong>。</p>
<p>this 的用法在 Java 中大体可以分为 3 种：</p>
<ol>
<li>普通的直接引用，this 相当于是指向当前对象本身</li>
<li>形参与成员变量名字重名，用 this 来区分：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name=name;</span><br><span class="line">    <span class="built_in">this</span>.age=age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>引用本类的构造函数</li>
</ol>
<h3 id="5-创建一个对象用什么运算符-对象实体与对象引用有何不同"><a href="#5-创建一个对象用什么运算符-对象实体与对象引用有何不同" class="headerlink" title="5.创建一个对象用什么运算符?对象实体与对象引用有何不同?"></a>5.创建一个对象用什么运算符?对象实体与对象引用有何不同?</h3><p>new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。</p>
<ul>
<li>一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）；</li>
<li>一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</li>
</ul>
<h3 id="对象的相等和引用相等的区别"><a href="#对象的相等和引用相等的区别" class="headerlink" title="对象的相等和引用相等的区别"></a>对象的相等和引用相等的区别</h3><ul>
<li>对象的相等一般比较的是内存中存放的内容是否相等。</li>
<li>引用相等一般比较的是他们指向的内存地址是否相等。</li>
</ul>
<h3 id="6-如果一个类没有声明构造方法，该程序能正确执行吗"><a href="#6-如果一个类没有声明构造方法，该程序能正确执行吗" class="headerlink" title="6.如果一个类没有声明构造方法，该程序能正确执行吗?"></a>6.如果一个类没有声明构造方法，该程序能正确执行吗?</h3><p>构造方法是一种特殊的方法，主要作用是完成对象的初始化工作。</p>
<p>如果一个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。</p>
<p><strong>注意：如果我们自己添加了类的构造方法（无论是否有参），Java 就不会添加默认的无参数的构造方法了。</strong></p>
<h3 id="7-构造方法有哪些特点？是否可被-override"><a href="#7-构造方法有哪些特点？是否可被-override" class="headerlink" title="7.构造方法有哪些特点？是否可被 override?"></a>7.构造方法有哪些特点？是否可被 override?</h3><p>构造方法特点如下：</p>
<ul>
<li>名字与类名相同。</li>
<li>没有返回值，但不能用 void 声明构造函数。</li>
<li>生成类的对象时自动执行，无需调用。</li>
</ul>
<p>构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况</p>
<h3 id="8-接口和抽象类有什么共同点和区别？"><a href="#8-接口和抽象类有什么共同点和区别？" class="headerlink" title="8.接口和抽象类有什么共同点和区别？"></a>8.接口和抽象类有什么共同点和区别？</h3><p><strong>共同点</strong>：</p>
<ul>
<li>都不能被实例化。</li>
<li>都可以包含抽象方法。</li>
<li>都可以有默认实现的方法（Java 8 可以用 <code>default</code> 关键字在接口中定义默认方法）。</li>
</ul>
<p><strong>区别</strong>：</p>
<ul>
<li>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。</li>
<li>一个类只能继承一个类，但是可以实现多个接口。</li>
<li>接口中的成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。</li>
</ul>
<h3 id="9-访问修饰符-public、private、protected、以及不写（默认）时的区别？"><a href="#9-访问修饰符-public、private、protected、以及不写（默认）时的区别？" class="headerlink" title="9.访问修饰符 public、private、protected、以及不写（默认）时的区别？"></a>9.访问修饰符 public、private、protected、以及不写（默认）时的区别？</h3><p>Java 中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。</p>
<ul>
<li><strong>default</strong> (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。可以修饰在类、接口、变量、方法。</li>
<li><strong>private</strong> : 在同一类内可见。可以修饰变量、方法。<strong>注意：不能修饰类（外部类）</strong></li>
<li><strong>public</strong> : 对所有类可见。可以修饰类、接口、变量、方法</li>
<li><strong>protected</strong> : 对同一包内的类和所有子类可见。可以修饰变量、方法。<strong>注意：不能修饰类（外部类）</strong>。</li>
</ul>
<p><img src="/2024/12/09/hello-world/e-12.png" alt="访问修饰符和可见性"></p>
<h3 id="10-成员变量与局部变量的区别有哪些？"><a href="#10-成员变量与局部变量的区别有哪些？" class="headerlink" title="10.成员变量与局部变量的区别有哪些？"></a>10.成员变量与局部变量的区别有哪些？</h3><ol>
<li><strong>从语法形式上看</strong>：成员变量是属于类的，⽽局部变量是在⽅法中定义的变量或是⽅法的参数；成员变量可以被 public , private , static 等修饰符所修饰，⽽局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。</li>
<li><strong>从变量在内存中的存储⽅式来看</strong>：如果成员变量是使⽤ static 修饰的，那么这个成员变量是属于类的，如果没有使⽤ static 修饰，这个成员变量是属于实例的。对象存于堆内存，如果局部变量类型为基本数据类型，那么存储在栈内存，如果为引⽤数据类型，那存放的是指向堆内存对象的引⽤或者是指向常量池中的地址。</li>
<li><strong>从变量在内存中的⽣存时间上看</strong>：成员变量是对象的⼀部分，它随着对象的创建⽽存在，⽽局部变量随着⽅法的调⽤⽽⾃动消失。</li>
<li><strong>成员变量如果没有被赋初值</strong>：则会⾃动以类型的默认值⽽赋值（⼀种情况例外:被 final 修饰的成员变量也必须显式地赋值），⽽局部变量则不会⾃动赋值</li>
</ol>
<h3 id="11-静态变量和实例变量的区别？静态方法、实例方法呢？"><a href="#11-静态变量和实例变量的区别？静态方法、实例方法呢？" class="headerlink" title="11.静态变量和实例变量的区别？静态方法、实例方法呢？"></a>11.静态变量和实例变量的区别？静态方法、实例方法呢？</h3><blockquote>
<p>静态变量和实例变量的区别？</p>
</blockquote>
<p><strong>静态变量:</strong> 是被 static 修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个副本。</p>
<p><strong>实例变量:</strong> 必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。</p>
<blockquote>
<p>静态⽅法和实例⽅法有何不同?</p>
</blockquote>
<p>类似地。</p>
<p><strong>静态方法</strong>：static 修饰的方法，也被称为类方法。在外部调⽤静态⽅法时，可以使⽤”<strong>类名.⽅法名</strong>“的⽅式，也可以使⽤”<strong>对象名.⽅法名</strong>“的⽅式。静态方法里不能访问类的非静态成员变量和方法。</p>
<p><strong>实例⽅法</strong>：依存于类的实例，需要使用”<strong>对象名.⽅法名</strong>“的⽅式调用；可以访问类的所有成员变量和方法</p>
<h3 id="12-Java-是值传递，还是引用传递？"><a href="#12-Java-是值传递，还是引用传递？" class="headerlink" title="12.Java 是值传递，还是引用传递？"></a>12.Java 是值传递，还是引用传递？</h3><p>Java 语言是<strong>值传递</strong>。Java 语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的。</p>
<p>JVM 的内存分为堆和栈，其中栈中存储了基本数据类型和引用数据类型实例的地址，也就是对象地址。</p>
<p>而对象所占的空间是在堆中开辟的，所以传递的时候可以理解为把变量存储的对象地址给传递过去，因此引用类型也是值传递。</p>
<p><img src="/2024/12/09/hello-world/e-14.png" alt="Java引用数据值传递示意图"></p>
<h3 id="深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"><a href="#深拷贝和浅拷贝区别了解吗？什么是引用拷贝？" class="headerlink" title="深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"></a><a href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%8C%BA%E5%88%AB%E4%BA%86%E8%A7%A3%E5%90%97-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%95%E7%94%A8%E6%8B%B7%E8%B4%9D">深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</a></h3><p>关于深拷贝和浅拷贝区别，我这里先给结论：</p>
<ul>
<li><strong>引用拷贝</strong>： 简单来说，引用拷贝就是两个不同的引用指向同一个对象。</li>
<li><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li>
<li><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</li>
</ul>
<p><img src="/2024/12/09/hello-world/ow&deep-copy.png" alt="浅拷贝、深拷贝、引用拷贝示意图"></p>
<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><h3 id="1-Object-类的常见方法"><a href="#1-Object-类的常见方法" class="headerlink" title="1.Object 类的常见方法?"></a>1.Object 类的常见方法?</h3><p>Object 类是一个特殊的类，是所有类的父类，也就是说所有类都可以调用它的方法。它主要提供了以下 11 个方法，大概可以分为六类：</p>
<p><img src="/2024/12/09/hello-world/e-21.png" alt="Object类的方法"></p>
<p><strong>对象比较</strong>：</p>
<ul>
<li>public native int hashCode() ：native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的 HashMap。</li>
<li>public boolean equals(Object obj)：用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写用户比较字符串的值是否相等。</li>
</ul>
<p><strong>对象拷贝</strong>：</p>
<ul>
<li>protected native Object clone() throws CloneNotSupportedException：naitive 方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() !&#x3D; x 为 true，x.clone().getClass() &#x3D;&#x3D; x.getClass() 为 true。Object 本身没有实现 Cloneable 接口，所以不重写 clone 方法并且进行调用的话会发生 CloneNotSupportedException 异常。</li>
</ul>
<p><strong>对象转字符串：</strong></p>
<ul>
<li>public String toString()：返回类的名字@实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</li>
</ul>
<p><strong>多线程调度：</strong></p>
<ul>
<li>public final native void notify()：native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</li>
<li>public final native void notifyAll()：native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</li>
<li>public final native void wait(long timeout) throws InterruptedException：native 方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 。timeout 是等待时间。</li>
<li>public final void wait(long timeout, int nanos) throws InterruptedException：多了 nanos 参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 毫秒。</li>
<li>public final void wait() throws InterruptedException：跟之前的 2 个 wait 方法一样，只不过该方法一直等待，没有超时时间这个概念</li>
</ul>
<p><strong>反射：</strong></p>
<ul>
<li>public final native Class&lt;?&gt; getClass()：native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</li>
</ul>
<p><strong>垃圾回收：</strong></p>
<ul>
<li>protected void finalize() throws Throwable ：通知垃圾收集器回收对象。</li>
</ul>
<h3 id="2-和-equals-的区别"><a href="#2-和-equals-的区别" class="headerlink" title="2.&#x3D;&#x3D; 和 equals() 的区别"></a>2.&#x3D;&#x3D; 和 equals() 的区别</h3><p><strong><code>==</code></strong> 对于基本类型和引用类型的作用效果是不同的：</p>
<ul>
<li>对于基本数据类型来说，<code>==</code> 比较的是值。</li>
<li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</li>
</ul>
<blockquote>
<p>因为 Java 只有值传递，所以，对于 &#x3D;&#x3D; 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p>
</blockquote>
<p><strong><code>equals()</code></strong> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类，因此所有的类都有<code>equals()</code>方法。</p>
<p><code>Object</code> 类 <code>equals()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>equals()</code> 方法存在两种使用情况：</p>
<ul>
<li><strong>类没有重写 <code>equals()</code>方法</strong>：通过<code>equals()</code>比较该类的两个对象时，等价于通过“&#x3D;&#x3D;”比较这两个对象，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li>
<li><strong>类重写了 <code>equals()</code>方法</strong>：一般我们都重写 <code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</li>
</ul>
<p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，因为 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址，而 <code>String</code> 的 <code>equals</code> 方法比较的是对象的值。</p>
<p>当创建 <code>String</code> 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 <code>String</code> 对象。</p>
<h3 id="3-hashCode-有什么用？"><a href="#3-hashCode-有什么用？" class="headerlink" title="3.hashCode() 有什么用？"></a>3.hashCode() 有什么用？</h3><p><code>hashCode()</code> 的作用是获取哈希码（<code>int</code> 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。</p>
<p><img src="/2024/12/09/hello-world/hashcode-method.png" alt="hashCode() 方法"></p>
<p><code>hashCode()</code> 定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是：<code>Object</code> 的 <code>hashCode()</code> 方法是本地方法，也就是用 C 语言或 C++ 实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>散列表存储的是键值对(key-value)，它的特点是：<strong>能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</strong></p>
<h3 id="4-为什么要有-hashCode？"><a href="#4-为什么要有-hashCode？" class="headerlink" title="4.为什么要有 hashCode？"></a>4.为什么要有 hashCode？</h3><p>当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 <code>hashCode</code> 值来判断对象加入的位置，同时也会与其他已经加入的对象的 <code>hashCode</code> 值作比较，如果没有相符的 <code>hashCode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashCode</code> 值的对象，这时会调用 <code>equals()</code> 方法来检查 <code>hashCode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 <code>equals</code> 的次数，相应就大大提高了执行速度。</p>
<p>其实， <code>hashCode()</code> 和 <code>equals()</code>都是用于比较两个对象是否相等</p>
<p><strong>那为什么 JDK 还要同时提供这两个方法呢？</strong></p>
<p>这是因为在一些容器（比如 <code>HashMap</code>、<code>HashSet</code>）中，有了 <code>hashCode()</code> 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进<code>HashSet</code>的过程）！</p>
<p>我们在前面也提到了添加元素进<code>HashSet</code>的过程，如果 <code>HashSet</code> 在对比的时候，同样的 <code>hashCode</code> 有多个对象，它会继续使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashCode</code> 帮助我们大大缩小了查找成本。</p>
<p><strong>那为什么不只提供 <code>hashCode()</code> 方法呢？</strong></p>
<p>这是因为两个对象的<code>hashCode</code> 值相等并不代表两个对象就相等。</p>
<p><strong>那为什么两个对象有相同的 <code>hashCode</code> 值，它们也不一定是相等的？</strong></p>
<p>因为 <code>hashCode()</code> 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code> )。</p>
<p>总结下来就是：</p>
<ul>
<li>如果两个对象的<code>hashCode</code> 值相等，那这两个对象不一定相等（哈希碰撞）。</li>
<li>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法也返回 <code>true</code>，我们才认为这两个对象相等。</li>
<li>如果两个对象的<code>hashCode</code> 值不相等，我们就可以直接认为这两个对象不相等。</li>
</ul>
<h3 id="5-为什么重写-equals-时必须重写-hashCode-方法？"><a href="#5-为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="5.为什么重写 equals() 时必须重写 hashCode() 方法？"></a>5.为什么重写 equals() 时必须重写 hashCode() 方法？</h3><p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p>
<p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p>
<p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话，使用 <code>HashMap</code> 会出现一下新的问题</p>
<ol>
<li><strong>破坏了<code>hashCode</code>契约</strong>：根据Java规范，如果两个对象通过<code>equals()</code>方法比较是相等的，那么这两个对象的<code>hashCode()</code>方法必须返回相同的整数值。如果你没有重写<code>hashCode()</code>，那么即使两个对象通过<code>equals()</code>方法比较是相等的，它们也可能有不同的哈希码，因为默认的<code>hashCode()</code>方法是根据对象的内存地址生成的。</li>
<li><strong>导致<code>HashMap</code>行为异常</strong>：当将这些对象作为键添加到<code>HashMap</code>中时，可能会出现意料之外的行为。具体来说，即使两个键通过<code>equals()</code>方法比较是相等的，它们也可能被错误地存储在哈希表的不同位置，因为它们有不同的哈希码。这意味着你可能无法通过一个等价的键来正确地检索或删除映射的值，因为<code>HashMap</code>首先会根据<code>hashCode()</code>方法返回的哈希码来定位键，然后才使用<code>equals()</code>方法来找到确切的键。</li>
<li><strong>影响<code>HashMap</code>的性能</strong>：由于哈希码的不一致可能会导致哈希冲突增加，这会影响到<code>HashMap</code>的性能，因为增加了在同一桶内进行等值比较的次数。</li>
</ol>
<p><strong>总结</strong>：</p>
<ul>
<li><code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</li>
<li>两个对象有相同的 <code>hashCode</code> 值，他们也不一定是相等的（哈希碰撞）。</li>
</ul>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="1-String、StringBuffer、StringBuilder-的区别？"><a href="#1-String、StringBuffer、StringBuilder-的区别？" class="headerlink" title="1.String、StringBuffer、StringBuilder 的区别？"></a>1.String、StringBuffer、StringBuilder 的区别？</h3><p><strong>可变性</strong></p>
<p><code>String</code> 是不可变的（后面会详细分析原因）。</p>
<p><code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</p>
<p><strong>线程安全性</strong></p>
<p><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。<code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。<code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</p>
<p><strong>性能</strong></p>
<p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<p><strong>对于三者使用的总结：</strong></p>
<ol>
<li>操作少量的数据: 适用 <code>String</code></li>
<li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li>
<li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li>
</ol>
<h3 id="2-String-为什么是不可变的"><a href="#2-String-为什么是不可变的" class="headerlink" title="2.String 为什么是不可变的?"></a>2.String 为什么是不可变的?</h3><p><code>String</code> 类中使用 <code>final</code> 关键字修饰字符数组来保存字符串，</p>
<p>1.保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供&#x2F;暴露修改这个字符串的方法。</p>
<p>2.<code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</p>
<h3 id="3-String-equals-和-Object-equals-有何区别？"><a href="#3-String-equals-和-Object-equals-有何区别？" class="headerlink" title="3.String#equals() 和 Object#equals() 有何区别？"></a>3.String#equals() 和 Object#equals() 有何区别？</h3><p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，比较的是 String 字符串的值是否相等。 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址。</p>
<h3 id="4-字符串常量池的作用了解吗"><a href="#4-字符串常量池的作用了解吗" class="headerlink" title="4.字符串常量池的作用了解吗"></a>4.字符串常量池的作用了解吗</h3><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在堆中创建字符串对象”ab“</span></span><br><span class="line"><span class="comment">// 将字符串对象”ab“的引用保存在字符串常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”ab“的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">System.out.println(aa==bb);<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="4-String-str1-new-String-“abc”-和-String-str2-“abc”-和-区别？"><a href="#4-String-str1-new-String-“abc”-和-String-str2-“abc”-和-区别？" class="headerlink" title="4.String str1 &#x3D; new String(“abc”)和 String str2 &#x3D; “abc” 和 区别？"></a>4.String str1 &#x3D; new String(“abc”)和 String str2 &#x3D; “abc” 和 区别？</h3><p>两个语句都会去字符串常量池中检查是否已经存在 “abc”，如果有则直接使用，如果没有则会在常量池中创建 “abc” 对象。</p>
<p><img src="/2024/12/09/hello-world/e-17.png" alt="堆与常量池中的String"></p>
<p>但是不同的是，String str1 &#x3D; new String(“abc”) 还会通过 new String() 在堆里创建一个 “abc” 字符串对象实例。所以后者可以理解为被前者包含。</p>
<blockquote>
<p>String s &#x3D; new String(“abc”)创建了几个对象？</p>
</blockquote>
<p>很明显，一个或两个。如果字符串常量池已经有“abc”，则是一个；否则，两个。</p>
<p>当字符创常量池没有 “abc”，此时会创建如下两个对象：</p>
<ul>
<li>一个是字符串字面量 “abc” 所对应的、字符串常量池中的实例</li>
<li>另一个是通过 new String() 创建并初始化的，内容与”abc”相同的实例，在堆中</li>
</ul>
<h3 id="5-String-intern-方法有什么作用"><a href="#5-String-intern-方法有什么作用" class="headerlink" title="5.String#intern 方法有什么作用?"></a>5.String#intern 方法有什么作用?</h3><p><code>String.intern()</code> 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况：</p>
<ul>
<li>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。</li>
<li>如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。</li>
</ul>
<h3 id="6-String-类型的变量和常量做“-”运算时发生了什么"><a href="#6-String-类型的变量和常量做“-”运算时发生了什么" class="headerlink" title="6.String 类型的变量和常量做“+”运算时发生了什么"></a>6.String 类型的变量和常量做“+”运算时发生了什么</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> str1 + str2;</span><br><span class="line"><span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> <span class="string">&quot;string&quot;</span>;</span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line">System.out.println(str3 == str5);<span class="comment">//true</span></span><br><span class="line">System.out.println(str4 == str5);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：比较 String 字符串的值是否相等，可以使用 <code>equals()</code> 方法。 <code>String</code> 中的 <code>equals</code> 方法是被重写过的。 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址，而 <code>String</code> 的 <code>equals</code> 方法比较的是字符串的值是否相等。如果你使用 <code>==</code> 比较两个字符串是否相等的话，IDEA 还是提示你使用 <code>equals()</code> 方法替换。</p>
</blockquote>
<p><strong>对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。</strong></p>
<p>常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。</p>
<p>对于 <code>String str3 = &quot;str&quot; + &quot;ing&quot;;</code> 编译器会给你优化成 <code>String str3 = &quot;string&quot;;</code> 。</p>
<p>并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：</p>
<ul>
<li>基本数据类型( <code>byte</code>、<code>boolean</code>、<code>short</code>、<code>char</code>、<code>int</code>、<code>float</code>、<code>long</code>、<code>double</code>)以及字符串常量。</li>
<li><code>final</code> 修饰的基本数据类型和字符串变量</li>
<li>字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; ）</li>
</ul>
<p><strong>引用的值在程序编译期是无法确定的，编译器无法对其进行优化。</strong></p>
<p>对象引用和“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append(str1).append(str2).toString();</span><br></pre></td></tr></table></figure>

<p>我们在平时写代码的时候，尽量避免多个字符串对象拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 <code>StringBuilder</code> 或者 <code>StringBuffer</code>。</p>
<p>不过，字符串使用 <code>final</code> 关键字声明之后，可以让编译器当做常量来处理。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="comment">// 下面两个表达式其实是等价的</span></span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;<span class="comment">// 常量池中的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> str1 + str2; <span class="comment">// 常量池中的对象</span></span><br><span class="line">System.out.println(c == d);<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>被 <code>final</code> 关键字修饰之后的 <code>String</code> 会被编译器当做常量来处理，编译器在程序编译期就可以确定它的值，其效果就相当于访问常量。</p>
<p>如果 ，编译器在运行时才能知道其确切值的话，就无法对其优化。</p>
<p>示例代码（<code>str2</code> 在运行时才能确定其值）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> getStr();</span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;<span class="comment">// 常量池中的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> str1 + str2; <span class="comment">// 在堆上创建的新的对象</span></span><br><span class="line">System.out.println(c == d);<span class="comment">// false</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getStr</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/2023/05/20/redis/</url>
    <content><![CDATA[<h1 id="Redis高级篇"><a href="#Redis高级篇" class="headerlink" title="Redis高级篇"></a>Redis高级篇</h1><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p><strong>RDB</strong>全称Redis Database Backup file(Redis数据备份文件)，也被叫做<strong>Redis数据快照</strong>。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。</p>
<p>快照文件称为RDB文件，默认是保存在当前运行目录</p>
<h4 id="RDB-创建快照时会阻塞主线程吗？"><a href="#RDB-创建快照时会阻塞主线程吗？" class="headerlink" title="RDB 创建快照时会阻塞主线程吗？"></a>RDB 创建快照时会阻塞主线程吗？</h4><p>Redis 提供了两个命令来生成 RDB 快照文件：</p>
<ul>
<li><code>save</code> : 同步保存操作，会阻塞 Redis 主线程；</li>
<li><code>bgsave</code> : fork 出一个子进程，子进程执行，不会阻塞 Redis 主线程，默认选项。</li>
</ul>
<blockquote>
<p>这里说 Redis 主线程而不是主进程的主要是因为 Redis 启动之后主要是通过单线程的方式完成主要的工作。如果你想将其描述为 Redis 主进程，也没毛病</p>
</blockquote>
<p>Redis 还可以通过配置文件的选项来实现每隔一段时间自动执行一次 bgsave 命令，默认会提供以下配置：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">save <span class="number">900</span> <span class="number">1</span></span><br><span class="line">save <span class="number">300</span> <span class="number">10</span></span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>

<p>别看选项名叫 save，实际上执行的是 bgsave 命令，也就是会创建子进程来生成 RDB 快照文件。 只要满足上面条件的任意一个，就会执行 bgsave，它们的意思分别是：</p>
<ul>
<li>900 秒之内，对数据库进行了至少 1 次修改；</li>
<li>300 秒之内，对数据库进行了至少 10 次修改；</li>
<li>60 秒之内，对数据库进行了至少 10000 次修改。</li>
</ul>
<p><img src="/2023/05/20/redis/1713600836851.png"></p>
<h4 id="RDB-在执行快照的时候，数据能修改吗？"><a href="#RDB-在执行快照的时候，数据能修改吗？" class="headerlink" title="RDB 在执行快照的时候，数据能修改吗？"></a>RDB 在执行快照的时候，数据能修改吗？</h4><p>可以的，执行 bgsave 过程中，Redis 依然<strong>可以继续处理操作命令</strong>的，也就是数据是能被修改的，关键的技术就在于<strong>写时复制技术（Copy-On-Write, COW）。</strong></p>
<p>执行 bgsave 命令的时候，会通过 fork() 创建子进程，此时子进程和父进程是共享同一片内存数据的，因为创建子进程的时候，会复制父进程的页表，但是页表指向的物理内存还是一个，此时如果主线程执行读操作，则主线程和 bgsave 子进程<strong>互相不影响</strong>。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/c34a9d1f58d602ff1fe8601f7270baa7-20230309232304226.png" alt="img"></p>
<p>如果主线程执行<strong>写操作</strong>，则被修改的数据会<strong>复制一份副本</strong>，然后 bgsave 子进程会把该副本数据写入 RDB 文件，在这个过程中，主线程仍然可以直接修改原来的数据。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/ebd620db8a1af66fbeb8f4d4ef6adc68-20230309232308604.png" alt="img"></p>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>AOF全称为Append Only File(追加文件)。Redis 处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。</p>
<h4 id="AOF-工作基本流程是怎样的？"><a href="#AOF-工作基本流程是怎样的？" class="headerlink" title="AOF 工作基本流程是怎样的？"></a>AOF 工作基本流程是怎样的？</h4><p>AOF 持久化功能的实现可以简单分为 5 步：</p>
<ol>
<li><strong>命令追加（append）</strong>：所有的写命令会追加到 AOF 缓冲区中。</li>
<li><strong>文件写入（write）</strong>：将 AOF 缓冲区的数据写入到 AOF 文件中。这一步需要调用<code>write</code>函数（系统调用），<code>write</code>将数据写入到了系统内核缓冲区之后直接返回了（延迟写）。注意！！！此时并没有同步到磁盘。</li>
<li><strong>文件同步（fsync）</strong>：AOF 缓冲区根据对应的持久化方式（ <code>fsync</code> 策略）向硬盘做同步操作。这一步需要调用 <code>fsync</code> 函数（系统调用）， <code>fsync</code> 针对单个文件操作，对其进行强制硬盘同步，<code>fsync</code> 将阻塞直到写入磁盘完成后返回，保证了数据持久化。</li>
<li><strong>文件重写（rewrite）</strong>：随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的。</li>
<li><strong>重启加载（load）</strong>：当 Redis 重启时，可以加载 AOF 文件进行数据恢复。</li>
</ol>
<h4 id="为什么先执行命令，再把数据写入日志呢？"><a href="#为什么先执行命令，再把数据写入日志呢？" class="headerlink" title="为什么先执行命令，再把数据写入日志呢？"></a>为什么先执行命令，再把数据写入日志呢？</h4><p>Reids 是先执行写操作命令后，才将该命令记录到 AOF 日志里的，这么做其实有两个好处。</p>
<ul>
<li><strong>避免额外的检查开销</strong>：因为如果先将写操作命令记录到 AOF 日志里，再执行该命令的话，如果当前的命令语法有问题，那么如果不进行命令语法检查，该错误的命令记录到 AOF 日志里后，Redis 在使用日志恢复数据时，就可能会出错。</li>
<li><strong>不会阻塞当前写操作命令的执行</strong>：因为当写操作命令执行成功后，才会将命令记录到 AOF 日志。</li>
</ul>
<p>当然，这样做也会带来风险：</p>
<ul>
<li><strong>数据可能会丢失：</strong> 执行写操作命令和记录日志是两个过程，那当 Redis 在还没来得及将命令写入到硬盘时，服务器发生宕机了，这个数据就会有丢失的风险。</li>
<li><strong>可能阻塞其他操作：</strong> 由于写操作命令执行成功后才记录到 AOF 日志，所以不会阻塞当前命令的执行，但因为 AOF 日志也是在主线程中执行，所以当 Redis 把日志文件写入磁盘的时候，还是会阻塞后续的操作无法执行。</li>
</ul>
<h4 id="AOF-写回策略有几种？"><a href="#AOF-写回策略有几种？" class="headerlink" title="AOF 写回策略有几种？"></a>AOF 写回策略有几种？</h4><p>先来看看，Redis 写入 AOF 日志的过程，如下图：</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/4eeef4dd1bedd2ffe0b84d4eaa0dbdea-20230309232249413.png" alt="img"></p>
<p>具体说说：</p>
<ol>
<li>Redis 执行完写操作命令后，会将命令追加到 server.aof_buf 缓冲区；</li>
<li>然后通过 write() 系统调用，将 aof_buf 缓冲区的数据写入到 AOF 文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 page cache，等待内核将数据写入硬盘；</li>
<li>具体内核缓冲区的数据什么时候写入到硬盘，由内核决定。</li>
</ol>
<p>Redis 提供了 3 种写回硬盘的策略，控制的就是上面说的第三步的过程。 在 Redis.conf 配置文件中的 appendfsync 配置项可以有以下 3 种参数可填：</p>
<ul>
<li><strong>Always</strong>，这个单词的意思是「总是」，所以它的意思是每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘；</li>
<li><strong>Everysec</strong>，这个单词的意思是「每秒」，所以它的意思是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘；</li>
<li><strong>No</strong>，意味着不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。</li>
</ul>
<p>我也把这 3 个写回策略的优缺点总结成了一张表格：</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/98987d9417b2bab43087f45fc959d32a-20230309232253633.png" alt="img"></p>
<h4 id="AOF-日志过大，会触发什么机制？"><a href="#AOF-日志过大，会触发什么机制？" class="headerlink" title="AOF 日志过大，会触发什么机制？"></a>AOF 日志过大，会触发什么机制？</h4><p>AOF 日志是一个文件，随着执行的写操作命令越来越多，文件的大小会越来越大。 如果当 AOF 日志文件过大就会带来性能问题，比如重启 Redis 后，需要读 AOF 文件的内容以恢复数据，如果文件过大，整个恢复的过程就会很慢。</p>
<p>所以，Redis 为了避免 AOF 文件越写越大，提供了 <strong>AOF 重写机制</strong>，当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来压缩 AOF 文件。</p>
<p>AOF 重写机制是在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件。</p>
<p>举个例子，在没有使用重写机制前，假设前后执行了「<em>set name xiaolin</em>」和「<em>set name xiaolincoding</em>」这两个命令的话，就会将这两个命令记录到 AOF 文件。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/723d6c580c05400b3841bc69566dd61b-20230309232257343.png" alt="img"></p>
<p>但是<strong>在使用重写机制后，就会读取 name 最新的 value（键值对） ，然后用一条 「set name xiaolincoding」命令记录到新的 AOF 文件</strong>，之前的第一个命令就没有必要记录了，因为它属于「历史」命令，没有作用了。这样一来，一个键值对在重写日志中只用一条命令就行了。</p>
<p>重写工作完成后，就会将新的 AOF 文件覆盖现有的 AOF 文件，这就相当于压缩了 AOF 文件，使得 AOF 文件体积变小了。</p>
<h4 id="重写-AOF-日志的过程是怎样的？"><a href="#重写-AOF-日志的过程是怎样的？" class="headerlink" title="重写 AOF 日志的过程是怎样的？"></a>重写 AOF 日志的过程是怎样的？</h4><p>Redis 的<strong>重写 AOF 过程是由后台子进程 *bgrewriteaof* 来完成的</strong>，这么做可以达到两个好处：</p>
<ul>
<li>子进程进行 AOF 重写期间，主进程可以继续处理命令请求，从而避免阻塞主进程；</li>
<li>子进程带有主进程的数据副本，这里使用子进程而不是线程，因为如果是使用线程，多线程之间会共享内存，那么在修改共享内存数据的时候，需要通过加锁来保证数据的安全，而这样就会降低性能。而使用子进程，创建子进程时，父子进程是共享内存数据的，不过这个共享的内存只能以只读的方式，而当父子进程任意一方修改了该共享内存，就会发生「写时复制」，于是父子进程就有了独立的数据副本，就不用加锁来保证数据安全。</li>
</ul>
<p>触发重写机制后，主进程就会创建重写 AOF 的子进程，此时父子进程共享物理内存，重写子进程只会对这个内存进行只读，重写 AOF 子进程会读取数据库里的所有数据，并逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志（新的 AOF 文件）。</p>
<p><strong>但是重写过程中，主进程依然可以正常处理命令</strong>，那问题来了，重写 AOF 日志过程中，如果主进程修改了已经存在 key-value，那么会发生写时复制，此时这个 key-value 数据在子进程的内存数据就跟主进程的内存数据不一致了，这时要怎么办呢？</p>
<p>为了解决这种数据不一致问题，Redis 设置了一个 <strong>AOF 重写缓冲区</strong>，这个缓冲区在创建 bgrewriteaof 子进程之后开始使用。</p>
<p>在重写 AOF 期间，当 Redis 执行完一个写命令之后，它会<strong>同时将这个写命令写入到 「AOF 缓冲区」和 「AOF 重写缓冲区」</strong>。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0ODI3Njc0,size_16,color_FFFFFF,t_70-20230309232301042.png" alt="img"></p>
<p>也就是说，在 bgrewriteaof 子进程执行 AOF 重写期间，主进程需要执行以下三个工作:</p>
<ul>
<li>执行客户端发来的命令；</li>
<li>将执行后的写命令追加到 「AOF 缓冲区」；</li>
<li>将执行后的写命令追加到 「AOF 重写缓冲区」；</li>
</ul>
<p>当子进程完成 AOF 重写工作（<em>扫描数据库中所有数据，逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志</em>）后，会向主进程发送一条信号，信号是进程间通讯的一种方式，且是异步的。</p>
<p>主进程收到该信号后，会调用一个信号处理函数，该函数主要做以下工作：</p>
<ul>
<li>将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中，使得新旧两个 AOF 文件所保存的数据库状态一致；</li>
<li>新的 AOF 的文件进行改名，覆盖现有的 AOF 文件。</li>
</ul>
<p>信号函数执行完后，主进程就可以继续像往常一样处理命令了。</p>
<p><img src="/2023/05/20/redis/1713601644337.png"></p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><ul>
<li>其基本编码方式是RAW,基于简单<strong>动态字符串</strong>(SDS)实现，存储上限为512mb。</li>
<li>如果存储的SDS长度小于44字节，则会采用EMBSTR编码，此时object head与SDS是一段连续空间。申请内存时只需要调用一次内存分配函数，效率更高。</li>
<li>如果存储的字符串是整数值，并且大小在LONG MAX范围内，则会采用INT编码：直接将数据保存在RedisObject的ptr指针位置（刚好8字节），不再需要SDS了。</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>String 类型的底层的数据结构实现主要是 SDS（简单动态字符串）。 SDS 和我们认识的 C 字符串不太一样，之所以没有使用 C 语言的字符串表示，因为 SDS 相比于 C 的原生字符串：</p>
<ul>
<li><strong>SDS 不仅可以保存文本数据，还可以保存二进制数据</strong>。因为 SDS 使用 len 属性的值而不是空字符来判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 buf[] 数组里的数据。所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。</li>
<li>**SDS 获取字符串长度的时间复杂度是 O(1)**。因为 C 语言的字符串并不记录自身长度，所以获取长度的复杂度为 O(n)；而 SDS 结构里用 len 属性记录了字符串长度，所以复杂度为 O(1)。</li>
<li><strong>Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出</strong>。因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题。</li>
</ul>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p><strong>需要存储常规数据的场景</strong></p>
<ul>
<li>举例：缓存 Session、Token、图片地址、序列化后的对象(相比较于 Hash 存储更节省内存)。</li>
<li>相关命令：<code>SET</code>、<code>GET</code>。</li>
</ul>
<p><strong>需要计数的场景</strong></p>
<ul>
<li>举例：用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数。</li>
<li>相关命令：<code>SET</code>、<code>GET</code>、 <code>INCR</code>、<code>DECR</code> 。</li>
</ul>
<p><strong>分布式锁</strong></p>
<p>利用 <code>SETNX key value</code> 命令可以实现一个最简易的分布式锁（存在一些缺陷，通常不建议这样实现分布式锁）。</p>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List 类型的底层数据结构是由<strong>双向链表或压缩列表</strong>实现的：</p>
<ul>
<li>如果列表的元素个数小于 512 个（默认值，可由 list-max-ziplist-entries 配置），列表每个元素的值都小于 64 字节（默认值，可由 list-max-ziplist-value 配置），Redis 会使用<strong>压缩列表</strong>作为 List 类型的底层数据结构；</li>
<li>如果列表的元素不满足上面的条件，Redis 会使用<strong>双向链表</strong>作为 List 类型的底层数据结构；<strong>支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</strong></li>
</ul>
<p>但是<strong>在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 quicklist 实现了，替代了双向链表和压缩列表</strong>。</p>
<h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><p><strong>信息流展示</strong></p>
<ul>
<li>举例：最新文章、最新动态。</li>
<li>相关命令：<code>LPUSH</code>、<code>LRANGE</code>。</li>
</ul>
<p><strong>消息队列</strong></p>
<p><code>List</code> 可以用来做消息队列，只是功能过于简单且存在很多缺陷，不建议这样做。</p>
<p>相对来说，Redis 5.0 新增加的一个数据结构 <code>Stream</code> 更适合做消息队列一些，只是功能依然非常简陋。和专业的消息队列相比，还是有很多欠缺的地方比如消</p>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>Hash 类型的底层数据结构是由<strong>压缩列表或哈希表</strong>实现的：</p>
<ul>
<li>如果哈希类型元素个数小于 512 个（默认值，可由 hash-max-ziplist-entries 配置），所有值小于 64 字节（默认值，可由 hash-max-ziplist-value 配置）的话，Redis 会使用<strong>压缩列表</strong>作为 Hash 类型的底层数据结构；</li>
<li>如果哈希类型元素不满足上面条件，Redis 会使用<strong>哈希表</strong>作为 Hash 类型的底层数据结构。</li>
</ul>
<p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了</strong>。</p>
<h4 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h4><p><strong>对象数据存储场景</strong></p>
<ul>
<li>举例：用户信息、商品信息、文章信息、购物车信息。</li>
<li>相关命令：<code>HSET</code> （设置单个字段的值）、<code>HMSET</code>（设置多个字段的值）、</li>
</ul>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><blockquote>
<p>Set 类型内部实现</p>
</blockquote>
<p>Set 类型的底层数据结构是由<strong>哈希表或整数集合</strong>实现的：</p>
<ul>
<li>如果集合中的元素都是整数且元素个数小于 512 （默认值，set-maxintset-entries配置）个，Redis 会使用<strong>整数集合</strong>作为 Set 类型的底层数据结构；</li>
<li>如果集合中的元素不满足上面条件，则 Redis 使用<strong>哈希表</strong>作为 Set 类型的底层数据结构。</li>
</ul>
<p>Redis 中的 Set 类型是一种无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 <code>HashSet</code> 。当你需要存储一个列表数据，又不希望出现重复数据时，Set 是一个很好的选择，并且 Set 提供了判断某个元素是否在一个 Set 集合内的重要接口，这个也是 List 所不能提供的。</p>
<p>你可以基于 Set 轻易实现交集、并集、差集的操作，比如你可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。这样的话，Set 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。</p>
<h4 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h4><p><strong>需要存放的数据不能重复的场景</strong></p>
<ul>
<li>举例：网站 UV 统计（数据量巨大的场景还是 <code>HyperLogLog</code>更适合一些）、文章点赞、动态点赞等场景。</li>
<li>相关命令：<code>SCARD</code>（获取集合数量） 。</li>
</ul>
<p><strong>需要获取多个数据源交集、并集和差集的场景</strong></p>
<ul>
<li>举例：共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐（差集）、音乐推荐（差集）、订阅号推荐（差集+交集） 等场景。</li>
<li>相关命令：<code>SINTER</code>（交集）、<code>SINTERSTORE</code> （交集）、<code>SUNION</code> （并集）、<code>SUNIONSTORE</code>（并集）、<code>SDIFF</code>（差集）、<code>SDIFFSTORE</code> （差集）。</li>
</ul>
<p><strong>需要随机获取数据源中的元素的场景</strong></p>
<ul>
<li>举例：抽奖系统、随机点名等场景。</li>
<li>相关命令：<code>SPOP</code>（随机获取集合中的元素并移除，适合不允许重复中奖的场景）、<code>SRANDMEMBER</code>（随机获取集合中的元素，适合允许重复中奖的场景）。</li>
</ul>
<h3 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h3><blockquote>
<p>ZSet 类型内部实现</p>
</blockquote>
<p>Zset 类型的底层数据结构是由<strong>压缩列表或跳表</strong>实现的：</p>
<ul>
<li>如果有序集合的元素个数小于 128 个，并且每个元素的值小于 64 字节时，Redis 会使用<strong>压缩列表</strong>作为 Zset 类型的底层数据结构；</li>
<li>如果有序集合的元素不满足上面的条件，Redis 会使用<strong>跳表</strong>作为 Zset 类型的底层数据结构；</li>
</ul>
<p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。</strong></p>
<h4 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h4><p><strong>需要随机获取数据源中的元素根据某个权重进行排序的场景</strong></p>
<ul>
<li>举例：各种排行榜比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。</li>
<li>相关命令：<code>ZRANGE</code> (从小到大排序)、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)。</li>
</ul>
<p><strong>需要存储的数据有优先级或者重要程度的场景</strong> 比如优先级任务队列。</p>
<ul>
<li>举例：优先级任务队列。</li>
<li>相关命令：<code>ZRANGE</code> (从小到大排序)、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th>数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>String</td>
<td>一种二进制安全的数据类型，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。</td>
</tr>
<tr>
<td>List</td>
<td>Redis 的 List 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</td>
</tr>
<tr>
<td>Hash</td>
<td>一个 String 类型的 field-value（键值对） 的映射表，特别适合用于存储对象，后续操作的时候，你可以直接修改这个对象中的某些字段的值。</td>
</tr>
<tr>
<td>Set</td>
<td>无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 <code>HashSet</code> 。</td>
</tr>
<tr>
<td>Zset</td>
<td>和 Set 相比，Sorted Set 增加了一个权重参数 <code>score</code>，使得集合中的元素能够按 <code>score</code> 进行有序排列，还可以通过 <code>score</code> 的范围来获取元素的列表。有点像是 Java 中 <code>HashMap</code> 和 <code>TreeSet</code> 的结合体。</td>
</tr>
</tbody></table>
<h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><p>用户控件和内何况工具<br>任何Linux发行版，其系统内核都是Linux。 我们的应用都需要通过Linux内核与硬件交互。</p>
<p>为了避免用户应用导致冲突甚至内核崩溃，用户应用与内核是分离的：<br>进程的寻址空间会划分为两部分：<strong>内核空间、用户空间</strong><br>● 用户空间只能执行受限的命令(Ring3)，而且不能直接调用系统资源，必须通过内核提供的接口来访问<br>● 内核空间可以执行特权命令(Ring0)，调用一切系统资源</p>
<p>Linux系统为了提高<strong>IO效率</strong>，会在用户空间和内核空间都加入<strong>缓冲区</strong>：<br>写数据时，要把用户缓冲数据<strong>拷贝</strong>到<strong>内核缓冲区</strong>，然后写入设备<br>读数据时，要从设备<strong>读取</strong>数据到<strong>内核缓冲</strong>区，然后拷贝到<strong>用户缓冲区</strong></p>
<h3 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h3><p>阻塞IO就是两个阶段都必须阻塞等待</p>
<p><img src="/2023/05/20/redis/1713689554700.png"></p>
<p>可以看到，阻塞IO模型中，用户进程在两个阶段都是<strong>阻塞状态</strong>。</p>
<h3 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h3><p>非阻塞IO的<strong>recvfrom操作</strong>会立即返回结果而不是阻塞用户进程</p>
<p><img src="/2023/05/20/redis/1713689915308.png"></p>
<p>性能上可能不如阻塞IO</p>
<h3 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h3><p>无论是阻塞IO还是非阻塞IO,用户应用在一阶段都需要调用recvfrom来获取数据，差别在于无数据时的处理方案：<br>● 如果调用recvfrom时，恰好没有数据，阻塞IO会使进程阻塞，非阻塞IO使CPU空转，都不能充分发挥CPU的作用。<br>● 如果调用recvfrom时，恰好<strong>有</strong>数据，则用户进程可以直接进入第二阶段，读取并处理数据<br>比如服务端处理客户端Socketi请求时，在单线程情况下，只能依次处理每一个socket,如果正在处理的socket恰好未就绪（数据不可读或不可写)，线程就会被阻塞，所有其它客户端socketi都必须等待，性能自然会很差。</p>
<p>这就像服务员给顾客点餐，分两步：<br>1.顾客思考要吃什么（等待数据就绪）<br>2.顾客想好了，开始点餐（读取数据）</p>
<p>要提高效率有冲办法？<br>√方案一：增加更多服务员（多线程)<br>√方案二：不排队，谁想好了吃什么（数据就绪了），服务员就给谁点餐（用户应用就去读取数据）</p>
<p><strong>用户进程如何知道内核中数据是否就绪呢？</strong></p>
<p><strong>文件描述符</strong>(File Descriptor)：简称FD,是一个从0开始递增的<strong>无符号整数</strong>，用来关联Linux中的一个文件。在Linux中，一切皆文件，例如常规文件、视频、硬件设备等，当然也包括网络套接字(Socket)。</p>
<p><strong>IO多路复用</strong>：是利用单个线程来同时监听多个FD,并在某个FD可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。</p>
<p><img src="/2023/05/20/redis/1713693251507.png"></p>
<p><img src="/2023/05/20/redis/1713693697297.png" alt="1713693697297"></p>
]]></content>
  </entry>
  <entry>
    <title>Ts</title>
    <url>/2023/06/28/TS/</url>
    <content><![CDATA[<h1 id="TS安装命令"><a href="#TS安装命令" class="headerlink" title="TS安装命令"></a>TS安装命令</h1><p><strong>起步安装</strong>  <em><strong>npm install typescript -g</strong></em></p>
<p>1.需转换JS<br><strong>TS文件转换JS</strong>  <em><strong>tsc 文件名.ts</strong></em><br><strong>JS文件运行</strong> <em><strong>node 文件名.js</strong></em></p>
<p>2.可以直接运行TS，不用转换JS<br><strong>TS库</strong> <em><strong>npm install ts-node -g</strong></em><br><strong>生成package.json</strong> <em><strong>npm init -y</strong></em><br><strong>生成package-lock.json</strong> <em><strong>npm i @types&#x2F;node -D</strong></em></p>
<h1 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h1><h3 id="1-字符串类型"><a href="#1-字符串类型" class="headerlink" title="1.字符串类型"></a>1.字符串类型</h3><p>字符串是使用string定义的</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="built_in">string</span> = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="comment">//普通声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以使用es6的字符串模板</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">str</span>: <span class="built_in">string</span> = <span class="string">`dddd<span class="subst">$&#123;a&#125;</span>`</span></span><br></pre></td></tr></table></figure>

<h3 id="2-数字类型"><a href="#2-数字类型" class="headerlink" title="2.数字类型"></a>2.数字类型</h3><p>支持十六进制、十进制、八进制和二进制；</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">notANumber</span>: <span class="built_in">number</span> = <span class="title class_">NaN</span>;<span class="comment">//Nan</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">num</span>: <span class="built_in">number</span> = <span class="number">123</span>;<span class="comment">//普通数字</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">infinityNumber</span>: <span class="built_in">number</span> = <span class="title class_">Infinity</span>;<span class="comment">//无穷大</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">decimal</span>: <span class="built_in">number</span> = <span class="number">6</span>;<span class="comment">//十进制</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">hex</span>: <span class="built_in">number</span> = <span class="number">0xf00d</span>;<span class="comment">//十六进制</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">binary</span>: <span class="built_in">number</span> = <span class="number">0b1010</span>;<span class="comment">//二进制</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">octal</span>: <span class="built_in">number</span> = <span class="number">0o744</span>;<span class="comment">//八进制s</span></span><br></pre></td></tr></table></figure>

<h3 id="3-布尔类型"><a href="#3-布尔类型" class="headerlink" title="3.布尔类型"></a>3.布尔类型</h3><p>注意，使用构造函数 <code>Boolean</code> 创造的对象<strong>不是</strong>布尔值，而是布尔对象</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">booleand</span>: <span class="built_in">boolean</span> = <span class="literal">true</span> <span class="comment">//可以直接使用布尔值</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> <span class="attr">booleand2</span>: <span class="built_in">boolean</span> = <span class="title class_">Boolean</span>(<span class="number">1</span>) <span class="comment">//也可以通过函数返回布尔值</span></span><br></pre></td></tr></table></figure>

<h3 id="4-空值类型"><a href="#4-空值类型" class="headerlink" title="4.空值类型"></a>4.空值类型</h3><p>在 <a href="https://so.csdn.net/so/search?q=TypeScript&spm=1001.2101.3001.7020">TypeScript</a> 中，可以用 <code>void</code> 表示没有任何返回值的函数</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">u</span>: <span class="built_in">void</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">n</span>: <span class="built_in">void</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<h3 id="5-Null和undefined类型"><a href="#5-Null和undefined类型" class="headerlink" title="5.Null和undefined类型"></a>5.Null和undefined类型</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">u</span>: <span class="literal">undefined</span> = <span class="literal">undefined</span>;<span class="comment">//定义undefined</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">n</span>: <span class="literal">null</span> = <span class="literal">null</span>;<span class="comment">//定义null</span></span><br></pre></td></tr></table></figure>

<p>void 和 undefined 和 null 最大的区别<br>与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 string 类型的变量：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这样写会报错 void类型不可以分给其他类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">test</span>: <span class="built_in">void</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">num2</span>: <span class="built_in">string</span> = <span class="string">&quot;1&quot;</span></span><br><span class="line"></span><br><span class="line">num2 = test</span><br><span class="line"><span class="comment">//这样是没问题的</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">test</span>: <span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">num2</span>: <span class="built_in">string</span> = <span class="string">&quot;1&quot;</span></span><br><span class="line"></span><br><span class="line">num2 = test</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者这样的</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">test</span>: <span class="literal">undefined</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">num2</span>: <span class="built_in">string</span> = <span class="string">&quot;1&quot;</span></span><br><span class="line"></span><br><span class="line">num2 = test</span><br></pre></td></tr></table></figure>

<h1 id="任意类型"><a href="#任意类型" class="headerlink" title="任意类型"></a>任意类型</h1><h3 id="Any-类型"><a href="#Any-类型" class="headerlink" title="Any 类型"></a>Any 类型</h3><p>1.没有强制限定哪种类型，随时切换类型都可以 我们可以对 any 进行任何操作，不需要检查类型<br>2.声明变量的时候没有指定任意类型默认为any3.弊端如果使用any 就失去了TS类型检测的作用<br>3.弊端如果使用any 就失去了TS类型检测的作用<br>4.<a href="https://so.csdn.net/so/search?q=TypeScript&spm=1001.2101.3001.7020">TypeScript</a> 3.0中引入的 unknown 类型也被认为是 top type ，但它更安全。与 any 一样，所有类型都可以分配给unknown</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">anys</span>:<span class="built_in">any</span> = <span class="number">123</span></span><br><span class="line">anys = <span class="string">&#x27;123&#x27;</span></span><br><span class="line">anys = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a;</span><br><span class="line">a = <span class="number">123</span></span><br><span class="line">a = <span class="literal">true</span></span><br></pre></td></tr></table></figure>



<h3 id="unknown-顶级类型"><a href="#unknown-顶级类型" class="headerlink" title="unknown 顶级类型"></a>unknown 顶级类型</h3><p>unknow类型比any更加严格当你要使用any 的时候可以尝试使用unknow</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//unknown可赋值对象只有unknown 和 any</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">bbb</span>:<span class="built_in">unknown</span> = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">aaa</span>:<span class="built_in">any</span>= <span class="string">&#x27;456&#x27;</span></span><br><span class="line"> </span><br><span class="line">aaa = bbb</span><br></pre></td></tr></table></figure>

<p>unkoown 类型 是不能调用属性和方法的，any 可以</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">如果是<span class="built_in">any</span>类型在对象没有这个属性的时候还在获取是不会报错的</span><br><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>:<span class="built_in">any</span> = &#123;<span class="attr">b</span>:<span class="number">1</span>&#125;</span><br><span class="line">obj.<span class="property">a</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">如果是unknow 是不能调用属性和方法</span><br><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>:<span class="built_in">unknown</span> = &#123;<span class="attr">b</span>:<span class="number">1</span>,<span class="attr">ccc</span>:():<span class="function"><span class="params">number</span>=&gt;</span><span class="number">213</span>&#125;</span><br><span class="line">obj.<span class="property">b</span></span><br><span class="line">obj.<span class="title function_">ccc</span>()</span><br></pre></td></tr></table></figure>

<h3 id="Object-和-object类型"><a href="#Object-和-object类型" class="headerlink" title="Object 和 object类型"></a>Object 和 object类型</h3><p>Object 包括所有类型<br>object 包括非值类型的类型<br>{}包括所有类型，与Object类似</p>
<p>tips：{}定义的字面量模式不能修改值的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">o</span>:<span class="built_in">object</span> = &#123;&#125;  <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">o</span>:<span class="built_in">object</span> = []  <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">o</span>:<span class="built_in">object</span> = <span class="function">()=&gt;</span><span class="number">123</span>  <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">o</span>:<span class="built_in">object</span> = <span class="number">123</span> <span class="comment">//错误</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">o</span>:<span class="built_in">object</span> = <span class="string">&#x27;abc&#x27;</span> <span class="comment">//错误</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>:&#123;&#125;= &#123;<span class="attr">age</span>:<span class="number">1</span>&#125;</span><br><span class="line">a.<span class="property">age</span> = <span class="number">3</span>  <span class="comment">// 无法修改</span></span><br></pre></td></tr></table></figure>

<h1 id="interface-接口"><a href="#interface-接口" class="headerlink" title="interface 接口"></a>interface 接口</h1><h3 id="1-interface-重合"><a href="#1-interface-重合" class="headerlink" title="1.interface 重合"></a>1.interface 重合</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Fn</span> &#123;</span><br><span class="line">    name : <span class="built_in">string</span>,</span><br><span class="line">    age : <span class="built_in">number</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Fn</span> &#123;</span><br><span class="line">    id : <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span>可以重名，并且继承该<span class="keyword">interface</span>的对象需声明全部属性和函数</span><br><span class="line">let o:<span class="title class_">Fn</span> = &#123;</span><br><span class="line">    name : <span class="string">&#x27;nihao&#x27;</span>,</span><br><span class="line">    age : <span class="number">14</span>,</span><br><span class="line">    id : <span class="number">12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-interface-任意key"><a href="#2-interface-任意key" class="headerlink" title="2.interface 任意key"></a>2.interface 任意key</h3><p>如果在interface中不知道定义何种属性，可以通过索引签名：<br>[名字:string]:any  使用后该属性不需要在对象中声明。</p>
<p>设置可选属性， 在interface中定义： age ?:number 添加一个问号， 使用后该属性不需要在对象中声明。</p>
<p><strong>readonly 为 只读，用来修饰属性和函数，不可修改。</strong></p>
<h3 id="3-interface定义函数"><a href="#3-interface定义函数" class="headerlink" title="3.interface定义函数"></a>3.interface定义函数</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Fn</span> &#123;</span><br><span class="line">    (<span class="attr">name</span>:<span class="built_in">string</span>):<span class="built_in">string</span> <span class="comment">// 有参函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">fn</span>:<span class="title class_">Fn</span> = <span class="keyword">function</span>(<span class="params"><span class="attr">name</span>:<span class="built_in">string</span></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Fn</span> &#123;</span><br><span class="line">    ():<span class="built_in">string</span> <span class="comment">// 无参函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">fn</span>:<span class="title class_">Fn</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;肖镇楠&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h1><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr1</span>:<span class="built_in">string</span>[] = [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr2</span>:<span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Fn</span> &#123;</span><br><span class="line">    name : <span class="built_in">string</span></span><br><span class="line">    age ?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line">对象数组</span><br><span class="line"><span class="keyword">let</span> <span class="attr">f</span>:<span class="title class_">Fn</span>[] = [&#123;<span class="attr">name</span>:<span class="string">&quot;xzn&quot;</span>,<span class="attr">age</span>:<span class="number">1</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">&quot;wo&quot;</span>&#125;]</span><br><span class="line"></span><br><span class="line">二维</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:<span class="built_in">any</span>[][] = [[<span class="number">1</span>],[<span class="number">2</span>,<span class="string">&quot;2&quot;</span>],[<span class="number">3</span>,<span class="literal">true</span>]]</span><br></pre></td></tr></table></figure>

<h1 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h1><h3 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">有参函数</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a : <span class="built_in">number</span> , b : <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">无参无反函数</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">cao</span>(<span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;不想玩啦&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">函数可选参数</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a : <span class="built_in">number</span>  = <span class="number">2</span>, b : <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数接口"><a href="#函数接口" class="headerlink" title="函数接口"></a>函数接口</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">第一种写法</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Obj</span>&#123;</span><br><span class="line">    <span class="attr">user</span>:<span class="built_in">number</span>[]	<span class="comment">// 数组</span></span><br><span class="line">    <span class="attr">add</span>:<span class="function">(<span class="params"><span class="attr">num</span>:<span class="built_in">number</span></span>)=&gt;</span><span class="built_in">void</span>	<span class="comment">// 添加</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>:<span class="title class_">Obj</span> = &#123;</span><br><span class="line">    user :[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">    <span class="title function_">add</span>(<span class="params"><span class="attr">num</span>:<span class="built_in">number</span></span>)&#123;	<span class="comment">// 视频中第一个参数是this</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">user</span>.<span class="title function_">push</span>(num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">第二种 带<span class="variable language_">this</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Obj</span>&#123;</span><br><span class="line">    <span class="attr">user</span>:<span class="built_in">number</span>[]</span><br><span class="line">    <span class="attr">add</span>:<span class="function">(<span class="params"><span class="attr">this</span>:<span class="title class_">Obj</span>,<span class="attr">num</span>:<span class="built_in">number</span></span>)=&gt;</span><span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>:<span class="title class_">Obj</span> = &#123;</span><br><span class="line">    user :[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">    <span class="title function_">add</span>(<span class="params"><span class="attr">this</span>:<span class="title class_">Obj</span>，<span class="attr">num</span>:<span class="built_in">number</span></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">user</span>.<span class="title function_">push</span>(num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">user</span>:<span class="built_in">number</span>[] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">findNum</span>(<span class="params"><span class="attr">str</span>:<span class="built_in">string</span></span>):<span class="built_in">any</span>  有参函数</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">findNum</span>(<span class="params"><span class="attr">id</span>:<span class="built_in">number</span></span>):<span class="built_in">any</span>	</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">findNum</span>(<span class="params"></span>):<span class="built_in">any</span>			 无参函数</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">findNum</span>(<span class="params">ids?:<span class="built_in">number</span> | <span class="built_in">string</span></span>):<span class="built_in">any</span>&#123;  <span class="comment">//联合类型</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> ids ==<span class="string">&#x27;number&#x27;</span>)&#123;		<span class="comment">//匹配类型</span></span><br><span class="line">        <span class="keyword">return</span> user.<span class="title function_">filter</span>(<span class="function"><span class="params">v</span> =&gt;</span> v== ids)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> ids == <span class="string">&#x27;string&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;好累&quot;</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">findNum</span>(<span class="string">&quot;1&quot;</span>))</span><br></pre></td></tr></table></figure>

<h1 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h1><p><strong>属性联合</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">str</span>: <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line">str = <span class="number">123</span></span><br><span class="line">str = <span class="string">&quot;23&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>函数联合</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">People</span>&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Man</span>&#123;</span><br><span class="line">    <span class="attr">sex</span>:<span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 两个接口都继承</span></span><br><span class="line"><span class="keyword">const</span> nan = (<span class="attr">man</span>: <span class="title class_">People</span> &amp; <span class="title class_">Man</span>) :<span class="function"><span class="params">void</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(man)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">nan</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;xzn&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">15</span>,</span><br><span class="line">    <span class="attr">sex</span>:<span class="number">1</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="keyword">function</span>(<span class="params"><span class="attr">num</span>: <span class="built_in">number</span> |<span class="built_in">string</span></span>):<span class="built_in">void</span>&#123;</span><br><span class="line">    <span class="comment">// 第一种写法</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>((num <span class="keyword">as</span> <span class="built_in">string</span>).<span class="property">length</span>);  <span class="comment">// num如果是number类型转换为string类型</span></span><br><span class="line">    <span class="comment">// 第二种写法</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>((&lt;<span class="built_in">string</span>&gt;num).<span class="property">length</span>);  <span class="comment">// num如果是number类型转换为string类型</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">fn</span>(<span class="string">&#x27;1213&#x27;</span>)</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2024/09/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h1><h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><p>单例模式分为两种，一种为饿汉式，一种为懒汉式，</p>
<p>饿汉式采用直接实例化 Singleton 的方式，但这样如果在不使用的情况下会<strong>消耗</strong>资源</p>
<p>懒汉式采用的后面实例化，从而达到<strong>节约</strong>资源，当有多<strong>个线程</strong>访问进去的时候，为了保证获取到的都是同一个 Singleton.class，通过对其进行<strong>上锁</strong>，保证只有<strong>一个线程</strong>可以进去获取实例化，当实例化结束后，<strong>其他线程获取到的都是已经被实例化好的singleton</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">simple</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> simple instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">simple</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> simple <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (simple.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance=  <span class="keyword">new</span> <span class="title class_">simple</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="工厂"><a href="#工厂" class="headerlink" title="工厂"></a>工厂</h2><h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">    Integer <span class="title function_">cash</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">implements</span> <span class="title class_">Fruit</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">cash</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Banana</span> <span class="keyword">implements</span> <span class="title class_">Fruit</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">cash</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Fruit <span class="title function_">getFruit</span><span class="params">(<span class="type">int</span> type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Banana</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Factory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Factory</span>();</span><br><span class="line">        <span class="type">Fruit</span> <span class="variable">fruit</span> <span class="operator">=</span> factory.getFruit(<span class="number">1</span>);</span><br><span class="line">        <span class="type">Fruit</span> <span class="variable">fruit2</span> <span class="operator">=</span> factory.getFruit(<span class="number">2</span>);</span><br><span class="line">        System.out.println(fruit.cash());</span><br><span class="line">        System.out.println(fruit2.cash());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这个简单工厂不符合太符合开闭原则的，因为工厂实际上是针对于调用方提供的，所以我们应该尽可能对修改关闭。</p>
<h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p><font style="color:rgb(44, 62, 80);">在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由子类来创建对象。</font></p>
<p><font style="color:rgb(55, 65, 81);">定义一个创建对象的接口，但让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1733306031191-5203157f-dfaf-4638-ae03-3109ae6bea95.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> Fruit <span class="title function_">getFruit</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppleFactory</span> <span class="keyword">extends</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Fruit <span class="title function_">getFruit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><p><font style="color:rgb(55, 65, 81);">提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。缺陷在于每添加一个新产品就要在抽象类进行修改，违反了开闭原则</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractProductA</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractProductB</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductA1</span> <span class="keyword">extends</span> <span class="title class_">AbstractProductA</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductA2</span> <span class="keyword">extends</span> <span class="title class_">AbstractProductA</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductB1</span> <span class="keyword">extends</span> <span class="title class_">AbstractProductB</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductB2</span> <span class="keyword">extends</span> <span class="title class_">AbstractProductB</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> AbstractProductA <span class="title function_">createProductA</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">abstract</span> AbstractProductB <span class="title function_">createProductB</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFactory1</span> <span class="keyword">extends</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    AbstractProductA <span class="title function_">createProductA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductA1</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AbstractProductB <span class="title function_">createProductB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductB1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFactory2</span> <span class="keyword">extends</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    AbstractProductA <span class="title function_">createProductA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductA2</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AbstractProductB <span class="title function_">createProductB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductB2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AbstractFactory</span> <span class="variable">abstractFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteFactory1</span>();</span><br><span class="line">        <span class="type">AbstractProductA</span> <span class="variable">productA</span> <span class="operator">=</span> abstractFactory.createProductA();</span><br><span class="line">        <span class="type">AbstractProductB</span> <span class="variable">productB</span> <span class="operator">=</span> abstractFactory.createProductB();</span><br><span class="line">        <span class="comment">// do something with productA and productB</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Builder"><a href="#Builder" class="headerlink" title="Builder"></a>Builder</h2><p>封装一个对象的构造过程，并允许按步骤构造，单如果这个实体类的属性超过4个或以上的时候就推荐使用建造者模式创建对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String phone;</span><br><span class="line">    <span class="type">int</span> sex;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age, String phone, <span class="type">int</span> sex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.phone = phone;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Builder <span class="title function_">builder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Builder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span>  <span class="title class_">Builder</span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">        String phone;</span><br><span class="line">        <span class="type">int</span> sex;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">name</span><span class="params">(String name)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">age</span><span class="params">(<span class="type">int</span> age)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">phone</span><span class="params">(String phone)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">this</span>.phone = phone;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">sex</span><span class="params">(<span class="type">int</span> sex)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">this</span>.sex = sex;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Person <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>(name, age, phone, sex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p><strong><font style="color:rgb(93, 93, 93);">原型模式使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。也就是说，原型对象作为模板，通过克隆操作，来产生更多的对象，就像细胞的复制一样。</font></strong></p>
]]></content>
  </entry>
  <entry>
    <title>线程池</title>
    <url>/2024/11/10/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h2 id="线程回顾"><a href="#线程回顾" class="headerlink" title="线程回顾"></a>线程回顾</h2><hr>
<p>创建线程的方式</p>
<ul>
<li>继承 Thread 类</li>
<li>实现 Runnable 接口</li>
</ul>
<p>创建后的线程有如下状态：</p>
<p>NEW：新建的线程，无任何操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">&quot;is running&quot;</span>));</span><br><span class="line">        Thread.<span class="type">State</span> <span class="variable">state</span> <span class="operator">=</span> thread.getState();</span><br><span class="line">        <span class="comment">// 线程刚创建还未执行，状态为 NEW</span></span><br><span class="line">        System.out.println(state);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>RUNNABLE：可执行的线程，在 JVM 中执行但是在等待操作系统的资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">&quot;is running&quot;</span>));</span><br><span class="line">    thread.start();</span><br><span class="line">    Thread.<span class="type">State</span> <span class="variable">state</span> <span class="operator">=</span> thread.getState();</span><br><span class="line">    <span class="comment">// 调用 start() 方法,可以执行，但不代表一定在执行</span></span><br><span class="line">    System.out.println(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BOLCKED：阻塞，获取不到锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Test.class) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Test.class) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        <span class="comment">// 等待，保证 线程1 开始执行</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        Thread.<span class="type">State</span> <span class="variable">state</span> <span class="operator">=</span> thread2.getState();</span><br><span class="line">        System.out.println(state);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>WAITING：等待，等待其他线程进行操作，时间不确定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(LockSupport::park);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">// 等待线程开始执行</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.<span class="type">State</span> <span class="variable">state</span> <span class="operator">=</span> thread.getState();</span><br><span class="line">        System.out.println(state);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 等待状态解除禁止，线程执行完毕</span></span><br><span class="line">        LockSupport.unpark(thread);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        state = thread.getState();</span><br><span class="line">        System.out.println(state);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>TIMED_WAITING：等待，等待的时间是确定的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.<span class="type">State</span> <span class="variable">state</span> <span class="operator">=</span> thread.getState();</span><br><span class="line">        System.out.println(state);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>TERMINATED：终止，线程已经运行完毕</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">&quot;is running&quot;</span>));</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 等待线程执行完毕</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.<span class="type">State</span> <span class="variable">state</span> <span class="operator">=</span> thread.getState();</span><br><span class="line">        System.out.println(state);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="引入线程池"><a href="#引入线程池" class="headerlink" title="引入线程池"></a>引入线程池</h2><hr>
<p>上述创建线程的方式存在如下缺陷：</p>
<ul>
<li>线程使用完后会被销毁，高并发场景下频繁创建和销毁线程的性能开销不可忽略</li>
<li>无法控制线程并发数量，线程过多会导致 JVM 宕机</li>
</ul>
<p>线程池是一种池化思想，由于创建和销毁线程需要时间，以及系统资源开销，我们需要一个“管理者”来统一管理线程及任务分配，减少这些开销，解决资源不足的问题。</p>
<p>在主要大厂的编程规范中，不允许在应用中自行显式地创建线程，线程必须通过线程池提供。</p>
<hr>
<h3 id="线程池解决了什么问题"><a href="#线程池解决了什么问题" class="headerlink" title="线程池解决了什么问题"></a>线程池解决了什么问题</h3><hr>
<ul>
<li>降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗：</li>
<li>提高系统响应速度，当有任务到达时，通过复用已存在的线程，无需等待新线程的创建便能立即执行：</li>
<li>方便线程并发数的管控。因为线程若是无限制的创建，可能会导致内存占用过多而产生OOM</li>
<li>节省CPU切换线程的时间成本（需要保持当前执行线程的现场，并恢复要执行线程的现场）。</li>
<li>提供更强大的功能，延时定时线程池</li>
</ul>
<hr>
<h3 id="线程池引发了什么问题"><a href="#线程池引发了什么问题" class="headerlink" title="线程池引发了什么问题"></a>线程池引发了什么问题</h3><hr>
<ul>
<li>异步任务提交后，如果JVM宕机，已提交的任务会丢失，需要考虑确认机制</li>
<li>使用不合理可能导致内存溢出问题</li>
<li>参数过多，代码结构引入数据结构与算法，增加使用难度</li>
</ul>
<hr>
<h2 id="线程池概述"><a href="#线程池概述" class="headerlink" title="线程池概述"></a>线程池概述</h2><hr>
<h3 id="线程池继承结构"><a href="#线程池继承结构" class="headerlink" title="线程池继承结构"></a>线程池继承结构</h3><hr>
<p><img src="/2024/11/10/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20240625142529340.png" alt="image-20240625142529340"></p>
<ul>
<li>最常用的是 ThreadPoolExecutor</li>
<li>调度用 ScheduledThreadPoolExecutor，类似 Timer 和 TimerTask。</li>
<li>任务拆分合并用 ForkJoinPool</li>
<li>Executors是工具类，协助创建线程池的</li>
</ul>
<hr>
<h3 id="线程池工作状态"><a href="#线程池工作状态" class="headerlink" title="线程池工作状态"></a>线程池工作状态</h3><hr>
<p><img src="/2024/11/10/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20240625144239291.png" alt="image-20240625144239291"></p>
<ul>
<li>RUNNING（运行状态)：这是线程池的初始状态。<ul>
<li>在此状态下，线程池接受新任务，并且也会处理等待队列中的任务。</li>
<li>线程池的线程会一直运行，直到被转换到其他状态。</li>
</ul>
</li>
<li>SHUTDOWN（关闭状态）：当调用线程池的shutdown()方法时，线程池会进入此状态。<ul>
<li>在此状态下，线程池不接受新任务，但会继续处理等待队列中的任务。</li>
<li>等待队列中的任务处理完毕后，线程池中的线程会逐渐结束，直到所有线程结束运行。</li>
</ul>
</li>
<li>STOP（停止状态）：当调用线程池的shutdownNow()方法时，线程池会进入此状态。<ul>
<li>在此状态下，线程池不接受新任务，同时也不处理等待队列中的任务</li>
<li>而是尝试停止所有正在执行的任务，并且回收线程池中的所有线程。</li>
</ul>
</li>
<li>TIDYING（整理状态）：当所有的任务已经终止，workerCount（工作线程数）为0时，线程池会进入此状态。<ul>
<li>此时，会执行terminated()钩子方法，允许线程池执行一些收尾工作。</li>
</ul>
</li>
<li>TERMINATED（终止状态）：terminated()钩子方法执行完毕后，线程池会进入此状态。<ul>
<li>在终止状态下，线程池的任务完全结束，不再有任何活动。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="七个核心参数"><a href="#七个核心参数" class="headerlink" title="七个核心参数"></a>七个核心参数</h3><hr>
<table>
<thead>
<tr>
<th>参数名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>corePoolSize</code></td>
<td>核心线程池基本大小，核心线程数</td>
</tr>
<tr>
<td><code>maximumPoolSize</code></td>
<td>线程池最大线程数</td>
</tr>
<tr>
<td><code>keepAliveTime</code></td>
<td>线程空闲后的存活时间</td>
</tr>
<tr>
<td><code>TimeUnit unit</code></td>
<td>线程空闲后的存活时间单位</td>
</tr>
<tr>
<td><code>BlockingQueue workQueue</code></td>
<td>存放任务的阻塞队列</td>
</tr>
<tr>
<td><code>ThreadFactory threadFactory</code></td>
<td>创建线程的工厂</td>
</tr>
<tr>
<td><code>RejectedExecutionHandler handler</code></td>
<td>当阻塞队列和最大线程池都满了之后的饱和策略</td>
</tr>
</tbody></table>
<hr>
<h4 id="corePoolSize"><a href="#corePoolSize" class="headerlink" title="corePoolSize"></a>corePoolSize</h4><hr>
<p>核心线程数</p>
<ul>
<li>线程池刚创建时，线程数量为0，当每次执行 execute 添加新的任务时会在线程池创建一个新的线<br>程，直到线程数量达到 corePoolSize 为止。</li>
<li>核心线程会一直存活，即使没有任务需要执行，当线程数小于核心线程数时，即使有线程空闲，线程<br>池也会优先创建新线程处理</li>
<li>设置 allowCoreThreadTimeout&#x3D;true （默认false）时，核心线程超时会关闭</li>
</ul>
<hr>
<h4 id="maximumPoolSize"><a href="#maximumPoolSize" class="headerlink" title="maximumPoolSize"></a>maximumPoolSize</h4><hr>
<p>最大线程数</p>
<ul>
<li>当池中的线程数 &gt;&#x3D; corePoolSize ，且任务队列已满时。线程池会创建新线程来处理任务</li>
<li>当池中的线程数 &#x3D; maximumPoolSize ，且任务队列已满时，线程池会拒绝处理任务而抛出异常</li>
</ul>
<p>如果使用无界的阻塞队列，该参数不生效</p>
<hr>
<h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><hr>
<p>阻塞队列</p>
<ul>
<li>当线程池正在运行的线程数量已经达到 corePoolSize ，那么再通过 execute 添加新的任务则会被加到 workQueue 队列中</li>
<li>任务会在队列中排队等待执行，而不会立即执行</li>
<li>一般来说，这里的阻塞队列有以下几种选择：ArrayBlockingQueue ， LinkedBlockingQueue ， SynchronousQueue</li>
</ul>
<hr>
<h4 id="keepAliveTime-TimeUnit"><a href="#keepAliveTime-TimeUnit" class="headerlink" title="keepAliveTime &amp; TimeUnit"></a>keepAliveTime &amp; TimeUnit</h4><hr>
<p>保活时间及其单位</p>
<ul>
<li>当线程空闲时间达到 keepAliveTime 时，线程会退出，直到线程数量 &#x3D;corePoolSize</li>
<li>如果 allowCoreThreadTimeout&#x3D;true ，则会直到线程数量&#x3D;0</li>
</ul>
<p>keepAliveTime 是时间的大小，TimeUnit 是时间单位</p>
<hr>
<h4 id="ThreadFactory"><a href="#ThreadFactory" class="headerlink" title="ThreadFactory"></a>ThreadFactory</h4><hr>
<p>线程工厂</p>
<ul>
<li>主要用来创建线程</li>
<li>通过newThread()方法提供创建线程，该方法创建的线程都是“非守护线程”而且“线程优先级都是默认优先级”</li>
</ul>
<hr>
<h4 id="RejectedExecutionHandler"><a href="#RejectedExecutionHandler" class="headerlink" title="RejectedExecutionHandler"></a>RejectedExecutionHandler</h4><hr>
<p>拒绝策略</p>
<ul>
<li>当线程数已经达到 maxPoolSize ，且队列已满，会拒绝新任务</li>
<li>当线程池被调用 shutdown() 后，会等待线程池里的任务执行完毕，再 shutdown 。如果在调用shutdown() 和线程池真正 shutdown 之间提交任务，会拒绝新任务</li>
<li>当拒绝处理任务时线程池会调用 rejectedExecutionHandler 来处理这个任务。</li>
</ul>
<p>如果没有设置默认是 AbortPolicy ，另外在 ThreadPoolExecutor 类有几个内部实现类来处理这类情况：</p>
<ul>
<li>ThreadPoolExecutor.AbortPolicy ：丢弃任务并抛出 RejectedExecutionException 异常。</li>
<li>ThreadPoolExecutor.CallerRunsPolicy ：由调用线程处理该任务</li>
<li>ThreadPoolExecutor.DiscardPolicy ：也是丢弃任务，但是不抛出异常</li>
<li>ThreadPoolExecutor.DiscardOldestPolicy ：丢弃队列最前面的任务，然后重新尝试执行任务</li>
</ul>
<p>另外实现 RejectedExecutionHandler 接口即可实现自定义的拒绝策略</p>
<hr>
<h3 id="线程池逻辑结构"><a href="#线程池逻辑结构" class="headerlink" title="线程池逻辑结构"></a>线程池逻辑结构</h3><hr>
<p>线程池的编程模式下，任务是提交给整个线程池，而不是直接提交给某个线程，线程池在拿到任务后，就在内部协调空闲的线程，如果有，则将任务交给某个空闲的华线程。</p>
<p>一个线程同时只能执行一个任务，但可以同时向一个线程池提交多个任务。</p>
<p><img src="/2024/12/09/hello-world/240625164308135.png" alt="image-20240625164308135"></p>
<p>当一个任务被提交，线程池会进行如下工作：</p>
<ul>
<li>首先判断当前的核心线程数量如果小于核心线程数，创建一个核心线程并执行任务</li>
<li>如果大于核心线程数，则尝试将其放入等待队列，如果队列没有满则放入队列等待执行</li>
<li>如果队列已满，则判断非核心线程数的数量+核心线程数是否小于最大线程数量</li>
<li>小于：则创建一个非核心线程并执行任务（并不会取队列中的任务）</li>
<li>大于：执行拒绝策略</li>
</ul>
<hr>
<h3 id="线程池线程数设置"><a href="#线程池线程数设置" class="headerlink" title="线程池线程数设置"></a>线程池线程数设置</h3><hr>
<p>虽然使用线程池的好处很多，但是如果其线程数配置得不合理，不仅可能达不到预期效果，反而可能降低应用的性能。</p>
<p>因此按照任务类型分类，对不同的任务类型确定不同的线程数量。</p>
<hr>
<h4 id="任务类型分类"><a href="#任务类型分类" class="headerlink" title="任务类型分类"></a>任务类型分类</h4><hr>
<ul>
<li>IO密集型任务：<ul>
<li>此类任务主要是执行 IO 操作。由于执行 lO 操作的时间较长，导致 CPU 的利用率不高，这类任务 CPU 常处于空闲状态。</li>
<li>Netty 的 IO 读写操作为此类任务的典型例子</li>
</ul>
</li>
<li>CPU 密集型任务：<ul>
<li>此类任务主要是执行计算任务。由于响应时间很快，CPU 一直在运行，这种任务 CPU 的利用率很高。</li>
<li>例如设计加密解密算法等大量需要 CPU 运算的场景</li>
</ul>
</li>
<li>混合型任务：<ul>
<li>此类任务既要执行逻辑计算，又要进行 IO 操作（如 RPC 调用、数据库访问）相对来说，由于执行 IO 操作的耗时较长（一次网络往返往往在数百毫秒级别)，这类任务的 CPU 利用率也不是太高。</li>
<li>Web 服务器的 HTTP 请求处理操作为此类任务的典型例子</li>
</ul>
</li>
</ul>
<hr>
<h4 id="确定任务线程数"><a href="#确定任务线程数" class="headerlink" title="确定任务线程数"></a>确定任务线程数</h4><hr>
<ul>
<li><p>IO 密集型任务：</p>
<ul>
<li>由于 IO 密集型任务的CPU使用率较低，导致线程空余时间很多，因此通常需要开 CPU 核心数两倍的线程</li>
<li>Netty 的 IO 处理任务就是典型的 IO 密集型任务，所以，Netty 的 Reactor 实现类（定制版的线程池）的 IO 处理线程数默认正好为 CPU 核数的两倍</li>
</ul>
</li>
<li><p>CPU密集型任务：</p>
<ul>
<li>CPU 密集型的任务并行的任务越多，花在任务切换的时间就越多，CPU 执行任务的效率就越低，一般开等于 CPU 的核心数的线程数量</li>
<li>比如 4 个核心的 CPU，通过 4 个线程并行地执行 4 个 CPU 密集型任务，此时的效率是最高的。但是如果线程数远远超出 CPU 核心数量，就需要频繁地切换线程，线程上下文切换时需要消耗时间，反而会使得任务效率下降。</li>
</ul>
</li>
<li><p>混合型任务：</p>
<ul>
<li><p>业界有一个比较成熟的估算公式，具体如下：</p>
</li>
<li><pre><code>最佳线程数 = ((线程等待时间 + 线程 CPU 时间) / 线程 CPU 时间) * CPU核数

 
 
 
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 通过公式可以看出：等待时间所占的比例越高，需要的线程就越多，CPU 耗时所占的比例越高，需要的线程就越少</span><br><span class="line"></span><br><span class="line">  - 比如在 Web 服务器处理 HTTP 请求时，假设平均线程 CPU 运行时间为 100 毫秒，而线程等待时间（比如包括 DB 操作、RPC 操作作、缓存操作等）为 900 毫秒，如果 CPU 核数为 8 那么根据上面这个公式，估算如下：`(900 毫秒+100 毫秒) / 100 毫秒 * 8 = 10 * 8 = 80`，最好开 80 个线程</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">## 关键源码剖析</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">### 属性 &amp; 构造方法</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">对于 ThreadPoolExecutor 有几个关键的属性，这里需要先大致了解：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class ThreadPoolExecutor extends AbstractExecutorService &#123;</span><br><span class="line"> </span><br><span class="line">    // 控制变量-存放状态和线程数</span><br><span class="line">    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</span><br><span class="line"> </span><br><span class="line">    // 任务队列，必须是阻塞队列</span><br><span class="line">    private final BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"> </span><br><span class="line">    // 工作线程集合，存放线程池中所有的（活跃的）工作线程，只有在持有全局锁mainLock的前提下才能访问此集合</span><br><span class="line">    private final HashSet&lt;Worker&gt; workers = new HashSet&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    // 全局锁</span><br><span class="line">    private final ReentrantLock mainLock = new ReentrantLock();</span><br><span class="line"> </span><br><span class="line">    // awaitTermination方法使用的等待条件变量</span><br><span class="line">    private final Condition termination = mainLock.newCondition();</span><br><span class="line"> </span><br><span class="line">    // 线程工厂，用于创建新的线程实例</span><br><span class="line">    private volatile ThreadFactory threadFactory;</span><br><span class="line"> </span><br><span class="line">    // 拒绝执行处理器，对应不同的拒绝策略</span><br><span class="line">    private volatile RejectedExecutionHandler handler;</span><br><span class="line"> </span><br><span class="line">    // 空闲线程等待任务的时间周期，单位是纳秒</span><br><span class="line">    private volatile long keepAliveTime;</span><br><span class="line"> </span><br><span class="line">    // 是否允许核心线程超时，如果为true则keepAliveTime对核心线程也生效</span><br><span class="line">    private volatile boolean allowCoreThreadTimeOut;</span><br><span class="line"> </span><br><span class="line">    // 核心线程数</span><br><span class="line">    private volatile int corePoolSize;</span><br><span class="line"> </span><br><span class="line">    // 线程池容量</span><br><span class="line">    private volatile int maximumPoolSize;</span><br><span class="line"> </span><br><span class="line">    ......</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<p>对于其构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="built_in">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此可见，当我们手动创建线程池时，线程池并不会直接工作，而是将我们手动设置的关键参数进行初始化。</p>
<hr>
<h3 id="execute-方法"><a href="#execute-方法" class="headerlink" title="execute 方法"></a>execute 方法</h3><hr>
<p>ThreadPoolExecutor 的最基本使用方式就是通过 execute 方法提交一个 Runnable 任务，首先看图理解 execute 的执行逻辑</p>
<p><img src="https://lys2021.com/wp-content/uploads/2024/06/image-20240625174625992.png" alt="image-20240625174625992"></p>
<p>查看源码中的 execute 方法，这里我们分层次来看，先看最主要的外部的几个条件判断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">         * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">         * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">         * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">         * threads when it shouldn&#x27;t, by returning false.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">         * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">         * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">         * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">         * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">         * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">         * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">         * and so reject the task.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">// 获取当前线程池里的线程数</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;  <span class="comment">// 判断工作线程数，如果小于 corePollSize，则执行addWork</span></span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则，如果线程池还在运行，offer 到等待队列中</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;  <span class="comment">// 这里判断是否可以通过创建非核心线程的方式创建线程并执行</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>)) </span><br><span class="line">            reject(command);  <span class="comment">// 如果不能，则执行拒绝策略</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其实源码里面的注释解释的已经很明白了，这里的逻辑其实已经说明了一些常见的问题：</p>
<ul>
<li>当提交任务时，只要核心线程数没有满，都会新建核心线程执行任务，不会使用以前创建好的空闲的核心线程去执行</li>
<li>当无法向队列提交任务时，如果可以新建非核心线程，则会新建非核心线程并执行任务，不会在创建之后从队列中取任务执行</li>
</ul>
<hr>
<h3 id="addWorker-方法"><a href="#addWorker-方法" class="headerlink" title="addWorker 方法"></a>addWorker 方法</h3><hr>
<p>接下来我们灌注一下 addWorker 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加工作线程，如果返回false说明没有新创建工作线程，如果返回true说明创建和启动工作线程成功</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addWorker</span><span class="params">(Runnable firstTask, <span class="type">boolean</span> core)</span> &#123;</span><br><span class="line">    <span class="comment">//第一步，计数判断，不符合条件打回false</span></span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();;) &#123;</span><br><span class="line">        <span class="comment">// 这个是十分复杂的条件，这里先拆分多个与（&amp;&amp;）条件：</span></span><br><span class="line">        <span class="comment">// 1. 线程池状态至少为SHUTDOWN状态，也就是rs &gt;= SHUTDOWN(0)</span></span><br><span class="line">        <span class="comment">// 2. 线程池状态至少为STOP状态，也就是rs &gt;= STOP(1)，或者传入的任务实例firstTask不为null，或者任务队列为空</span></span><br><span class="line">        <span class="comment">// 其实这个判断的边界是线程池状态为shutdown状态下，不会再接受新的任务，在此前提下如果状态已经到了STOP、或者传入任务不为空、或者任务队列为空（已经没有积压任务）都不需要添加新的线程</span></span><br><span class="line">        <span class="keyword">if</span> (runStateAtLeast(c, SHUTDOWN)</span><br><span class="line">            &amp;&amp; (runStateAtLeast(c, STOP)</span><br><span class="line">                || firstTask != <span class="literal">null</span></span><br><span class="line">                || workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 注意这也是一个死循环 - 二层循环</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 这里每一轮循环都会重新获取工作线程数wc</span></span><br><span class="line">            <span class="comment">// 1. 如果传入的core为true，表示将要创建核心线程，通过wc和corePoolSize判断，如果wc &gt;= corePoolSize，则返回false表示创建核心线程失败</span></span><br><span class="line">            <span class="comment">// 2. 如果传入的core为false，表示将要创非建核心线程，通过wc和maximumPoolSize判断，如果wc &gt;= maximumPoolSize，则返回false表示创建非核心线程失败</span></span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c)</span><br><span class="line">                &gt;= ((core ? corePoolSize : maximumPoolSize) &amp; COUNT_MASK))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 成功通过CAS更新工作线程数wc，则break到最外层的循环</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            <span class="comment">// 走到这里说明了通过CAS更新工作线程数wc失败，这个时候需要重新判断线程池的状态是否由RUNNING已经变为SHUTDOWN</span></span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="comment">// 如果线程池状态已经由RUNNING已经变为SHUTDOWN，则重新跳出到外层循环继续执行</span></span><br><span class="line">            <span class="keyword">if</span> (runStateAtLeast(c, SHUTDOWN))</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// 如果线程池状态依然是RUNNING，CAS更新工作线程数wc失败说明有可能是并发更新导致的失败，则在内层循环重试即可 </span></span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//第二步，创建新work放入线程集合works（一个HashSet）</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 标记工作线程是否启动成功</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerStarted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 标记工作线程是否创建成功</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerAdded</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Worker</span> <span class="variable">w</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 传入任务实例firstTask创建Worker实例，Worker构造里面会通过线程工厂创建新的Thread对象，所以下面可以直接操作Thread t = w.thread</span></span><br><span class="line">        <span class="comment">// 这一步Worker实例已经创建，但是没有加入工作线程集合或者启动它持有的线程Thread实例</span></span><br><span class="line">        w = <span class="keyword">new</span> <span class="title class_">Worker</span>(firstTask);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里需要全局加锁，因为会改变一些指标值和非线程安全的集合</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">                <span class="comment">// 这里主要在加锁的前提下判断ThreadFactory创建的线程是否存活或者判断获取锁成功之后线程池状态是否已经更变为SHUTDOWN</span></span><br><span class="line">                <span class="comment">// 1. 如果线程池状态依然为RUNNING，则只需要判断线程实例是否存活，需要添加到工作线程集合和启动新的Worker</span></span><br><span class="line">                <span class="comment">// 2. 如果线程池状态小于STOP，也就是RUNNING或者SHUTDOWN状态下，同时传入的任务实例firstTask为null，则需要添加到工作线程集合和启动新的Worker</span></span><br><span class="line">                <span class="comment">// 对于2，换言之，如果线程池处于SHUTDOWN状态下，同时传入的任务实例firstTask不为null，则不会添加到工作线程集合和启动新的Worker</span></span><br><span class="line">                <span class="comment">// 这一步其实有可能创建了新的Worker实例但是并不启动（临时对象，没有任何强引用），这种Worker有可能成功下一轮GC被收集的垃圾对象</span></span><br><span class="line">                <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">                    (runStateLessThan(c, STOP) &amp;&amp; firstTask == <span class="literal">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">                    <span class="comment">// 把创建的工作线程实例添加到工作线程集合</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> workers.size();</span><br><span class="line">                    <span class="comment">// 尝试更新历史峰值工作线程数，也就是线程池峰值容量</span></span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    <span class="comment">// 这里更新工作线程是否启动成功标识为true，后面才会调用Thread#start()方法启动真实的线程实例</span></span><br><span class="line">                    workerAdded = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果成功添加工作线程，则调用Worker内部的线程实例t的Thread#start()方法启动真实的线程实例</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                <span class="comment">// 标记线程启动成功</span></span><br><span class="line">                workerStarted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 线程启动失败，需要从工作线程集合移除对应的Worker</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 添加Worker失败</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addWorkerFailed</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 从工作线程集合移除之</span></span><br><span class="line">        <span class="keyword">if</span> (w != <span class="literal">null</span>)</span><br><span class="line">            workers.remove(w);</span><br><span class="line">        <span class="comment">// wc数量减1    </span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        <span class="comment">// 基于状态判断尝试终结线程池</span></span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看看 addWork 的两个参数，第一个是需要提交的线程Runnable firstTask，第二个参数是 boolean 类型，表示是否为核心线程。</p>
<p>其中三处调用 addWork：</p>
<ul>
<li>第一次，条件if (workerCountOf(c) &lt; corePoolSize)：这个很好理解，工作线程数少于核心线程数，提交任务。所以addWorker(command, true)</li>
<li>第二次，如果 workerCountOf(recheck) &#x3D;&#x3D; 0： 如果worker的数量为0，那就 addWorker(null,false)，由于之前已经把command提交到阻塞队列了workQueue.offer(command)。所以提交一个空线程，直接从阻塞队列里面取就可以了。</li>
<li>第三次，如果线程池没有RUNNING或者offer阻塞队列失败，addWorker(command,false)：说明阻塞队列满了，将任务提交到非核心线程池。</li>
</ul>
<hr>
<h3 id="Worker-对象"><a href="#Worker-对象" class="headerlink" title="Worker 对象"></a>Worker 对象</h3><hr>
<p>线程池中的每一个线程被封装成了内部的一个Worker对象，ThreadPool维护的其实就是一组Worker对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">6138294804551838833L</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 保存ThreadFactory创建的线程实例，如果ThreadFactory创建线程失败则为null</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">// 保存传入的Runnable任务实例</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">// 记录每个线程完成的任务总数</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> completedTasks;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 唯一的构造函数，传入任务实例firstTask，注意可以为null</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        <span class="comment">// 禁止线程中断，直到runWorker()方法执行</span></span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="built_in">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="comment">// 通过ThreadFactory创建线程实例，注意一下Worker实例自身作为Runnable用于创建新的线程实例</span></span><br><span class="line">        <span class="built_in">this</span>.thread = getThreadFactory().newThread(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 委托到外部的runWorker()方法，注意runWorker()方法是线程池的方法，而不是Worker的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        runWorker(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Lock methods</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The value 0 represents the unlocked state.</span></span><br><span class="line">    <span class="comment">// The value 1 represents the locked state.</span></span><br><span class="line">    <span class="comment">//  是否持有独占锁，state值为1的时候表示持有锁，state值为0的时候表示已经释放锁</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 独占模式下尝试获取资源，这里没有判断传入的变量，直接CAS判断0更新为1是否成功，成功则设置独占线程为当前线程</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 独占模式下尝试是否资源，这里没有判断传入的变量，直接把state设置为0</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">        setState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>        &#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 尝试加锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span>  &#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>      &#123; release(<span class="number">1</span>); &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 是否锁定</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLocked</span><span class="params">()</span> &#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 启动后进行线程中断，注意这里会判断线程实例的中断标志位是否为false，只有中断标志位为false才会中断</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">interruptIfStarted</span><span class="params">()</span> &#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="literal">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="runWorker-方法"><a href="#runWorker-方法" class="headerlink" title="runWorker 方法"></a>runWorker 方法</h3><hr>
<p>Worker 方法中的 run 方法实际调用的是线程池中的 runWorker 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前线程，实际上和Worker持有的线程实例是相同的</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取Worker中持有的初始化时传入的任务对象，这里注意存放在临时变量task中</span></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> w.firstTask;</span><br><span class="line">    <span class="comment">// 设置Worker中持有的初始化时传入的任务对象为null</span></span><br><span class="line">    w.firstTask = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 由于Worker初始化时AQS中state设置为-1，这里要先做一次解锁把state更新为0，允许线程中断</span></span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="comment">// 记录线程是否因为用户异常终结，默认是true</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">completedAbruptly</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 如果线程池外部传递了任务则直接执行外部传递的任务</span></span><br><span class="line">        <span class="comment">// 2. 如果没有获取到外部传递进来的任务则调用getTask()去队列中获取任务并执行</span></span><br><span class="line">        <span class="comment">// 2.1. 如果在任务队列中获取到了任务则直接执行已经获取的任务</span></span><br><span class="line">        <span class="comment">// 2.2. 如果任务队列为空，没有任务则反复执行空循环阻塞当前线程死亡</span></span><br><span class="line">        <span class="comment">// getTask()由于使用了阻塞队列，这个while循环如果命中后半段会处于阻塞或者超时阻塞状态，getTask()返回为null会导致线程跳出死循环使线程终结</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Worker加锁，本质是AQS获取资源并且尝试CAS更新state由0更变为1</span></span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// 如果线程池正在停止（也就是由RUNNING或者SHUTDOWN状态向STOP状态变更），那么要确保当前工作线程是中断状态</span></span><br><span class="line">            <span class="comment">// 否则，要保证当前线程不是中断状态</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                    (Thread.interrupted() &amp;&amp;</span><br><span class="line">                    runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 钩子方法，任务执行前</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 调用任务的run方法，而不是start()方法，因为Worker本身就是一个线程类</span></span><br><span class="line">                    task.run();</span><br><span class="line">                    <span class="comment">// 钩子方法，任务执行后 - 正常情况</span></span><br><span class="line">                    afterExecute(task, <span class="literal">null</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    <span class="comment">// 钩子方法，任务执行后 - 异常情况</span></span><br><span class="line">                    afterExecute(task, ex);</span><br><span class="line">                    <span class="keyword">throw</span> ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 清空task临时变量，这个很重要，否则while会死循环执行同一个task</span></span><br><span class="line">                task = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 执行完成后自增当前工作线程执行的任务数量</span></span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                <span class="comment">// Worker解锁，本质是AQS释放资源，设置state为0</span></span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果线程能够执行到最后一行代表线程执行过程中没有由于发生异常导致跳出循环，将 突然结束 标志改为false</span></span><br><span class="line">        completedAbruptly = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 处理线程退出，completedAbruptly为true说明由于用户异常导致线程非正常退出</span></span><br><span class="line">        <span class="comment">// 执行回收工作线程的逻辑</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>runWorker 方法的本质其实就是通过一个 while 循环不断地通过 getTask() 方法获取任务，在调用方法执行的时候会先获取外部传递的任务，如果没有获取到外部传递的任务则调用 getTask() 方法获取任务队列中的任务并执行</p>
<hr>
<h3 id="getTask-方法"><a href="#getTask-方法" class="headerlink" title="getTask 方法"></a>getTask 方法</h3><hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Runnable <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// timeOut变量的值表示上次从阻塞队列中取任务时是否超时</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">timedOut</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果线程池状态rs &gt;= SHUTDOWN，也就是非RUNNING状态，再进行以下判断：</span></span><br><span class="line"><span class="comment">         * 1. rs &gt;= STOP，线程池是否正在stop；</span></span><br><span class="line"><span class="comment">         * 2. 阻塞队列是否为空。</span></span><br><span class="line"><span class="comment">         * 如果以上条件满足，则将workerCount减1并返回null。</span></span><br><span class="line"><span class="comment">         * 因为如果当前线程池状态的值是SHUTDOWN或以上时，不允许再向阻塞队列中添加任务。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line">        <span class="comment">// 判断是不是要超时处理</span></span><br><span class="line">        <span class="comment">// timed变量用于判断是否需要进行超时控制。</span></span><br><span class="line">        <span class="comment">// allowCoreThreadTimeOut默认是false，也就是核心线程不允许进行超时；</span></span><br><span class="line">        <span class="comment">// wc &gt; corePoolSize，表示当前线程池中的线程数量大于核心线程数量；</span></span><br><span class="line">        <span class="comment">// 对于超过核心线程数量的这些线程，需要进行超时控制</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">timed</span> <span class="operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 将线程队列数量原子性减</span></span><br><span class="line"><span class="comment">         * wc &gt; maximumPoolSize的情况是因为可能在此方法执行阶段同时执行了setMaximumPoolSize方法；</span></span><br><span class="line"><span class="comment">         * timed &amp;&amp; timedOut 如果为true，表示当前操作需要进行超时控制，并且上次从阻塞队列中获取任务发生了超时</span></span><br><span class="line"><span class="comment">         * 接下来判断，如果有效线程数量大于1，或者阻塞队列是空的，那么尝试将workerCount减1；</span></span><br><span class="line"><span class="comment">         * 如果减1失败，则返回重试。</span></span><br><span class="line"><span class="comment">         * 如果wc == 1时，也就说明当前线程是线程池中唯一的一个线程了。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            <span class="comment">//计数器做原子递减，递减成功后，返回null，for被中止</span></span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//递减失败，继续下一轮循环，直到成功</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//如果线程可被释放，那就poll，释放的时间为：keepAliveTime</span></span><br><span class="line">            <span class="comment">//否则，线程是不会被释放的，take一直被阻塞在这里，直到来了新任务继续工作</span></span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            <span class="comment">// 到这里说明可被释放的线程等待超时，已经销毁，设置该标记，下次循环将线程数减少</span></span><br><span class="line">            timedOut = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            <span class="comment">// 如果获取任务时当前线程发生了中断，则设置timedOut为false并返回循环重试</span></span><br><span class="line">            timedOut = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综上所述，线程池内部将我们提交的任务封装成了一个个 Woker 对象来管理，我们调用线程池的 execute 方法，实际上：</p>
<ul>
<li>execute 根据策略调用 -&gt; addWoker 方法</li>
<li>addWoker 方法调用 Worker 的 run 方法</li>
<li>Worker 的 run 方法调用 runWorker 方法</li>
<li>runWorker 方法不断去用 getTask 获取任务执行</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>力扣</title>
    <url>/2024/08/27/%E5%8A%9B%E6%89%A3/</url>
    <content><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a><a href="https://leetcode.cn/problems/sort-list/">148. 排序链表</a></h2><p>思想是归并排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span> )<span class="keyword">return</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next, slow = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 利用快慢指针移动中点</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> slow.next;</span><br><span class="line">        slow.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 分为两边临界值,切割链表</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">left</span> <span class="operator">=</span> sortList(head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">right</span> <span class="operator">=</span> sortList(tmp); <span class="comment">// 相当于 m +1</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);	<span class="comment">// 临时存储链表</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> h;</span><br><span class="line">        <span class="keyword">while</span>(left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(left.val &lt; right.val)&#123;</span><br><span class="line">                h.next = left;</span><br><span class="line">                left = left.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                h.next = right;</span><br><span class="line">                right = right.next;</span><br><span class="line">            &#125;</span><br><span class="line">            h = h.next;</span><br><span class="line">        &#125;</span><br><span class="line">        h.next = left != <span class="literal">null</span> ? left : right;</span><br><span class="line">        <span class="keyword">return</span> res.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1729236301573-8faba7b1-904e-4069-bacb-4ff41896c966.png"></p>
<h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></h2><p>这道题首先需要给数组排序, 按照x[0]排好位置，然后分为两种情况：</p>
<p>1.链表没有数据并且当前数组[0] 《&#x3D; 前一个数组[1]，那这样就要更新数据，判断前一个数组[1]是否需要更新数据</p>
<p>2.直接添加数组 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        ArrayList&lt;<span class="type">int</span>[]&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(intervals,(x, y) -&gt; x[<span class="number">0</span>] - y[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[]p : intervals)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> res.size();</span><br><span class="line">            <span class="keyword">if</span>(m &gt; <span class="number">0</span> &amp;&amp; p[<span class="number">0</span>] &lt;= res.get(m - <span class="number">1</span>)[<span class="number">1</span>])&#123;</span><br><span class="line">                res.get(m - <span class="number">1</span>)[<span class="number">1</span>] = Math.max(res.get(m - <span class="number">1</span>)[<span class="number">1</span>],p[<span class="number">1</span>]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.add(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[res.size()][]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>**<br>**</p>
<h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a><a href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></h2><p>这道题看题目可知，他需要返回原数组，所以不需要构建新数组或者链表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums)&#123;</span><br><span class="line">            <span class="comment">// 如果相同的时候，则跳过该数字不进行拷贝覆盖</span></span><br><span class="line">            <span class="keyword">if</span>(i != val)&#123;</span><br><span class="line">                nums[j] = i;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="179-最大数"><a href="#179-最大数" class="headerlink" title="179. 最大数"></a><a href="https://leetcode.cn/problems/largest-number/">179. 最大数</a></h2><p>这道题也可以套用快排模板的，主要是比较每一个 str 的大小，所以需要使用到compareTo函数。思路如下：、</p>
<ul>
<li><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">若拼接字符串 </font><em><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">x </font></em><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">+ </font><em><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">y </font></em><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">&gt; </font><em><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">y </font></em><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">+ </font><em><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">x</font></em><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> ，则 </font><em><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">x</font></em><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> “大于” </font><em><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">y</font></em><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 。</font></li>
<li><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">反之，若 </font><em><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">x </font></em><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">+ </font><em><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">y </font></em><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">&lt; </font><em><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">y </font></em><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">+ </font><em><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">x</font></em><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> ，则 </font><em><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">x</font></em><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> “小于” </font><em><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">y</font></em><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 。</font></li>
</ul>
<p><font style="color:rgba(6, 8, 31, 0.88);">在 Java 中，</font><code>&lt;font style=&quot;color:rgba(6, 8, 31, 0.88);&quot;&gt;compareTo&lt;/font&gt;</code><font style="color:rgba(6, 8, 31, 0.88);"> </font><font style="color:rgba(6, 8, 31, 0.88);">方法是</font><font style="color:rgba(6, 8, 31, 0.88);"> </font><code>&lt;font style=&quot;color:rgba(6, 8, 31, 0.88);&quot;&gt;Comparable&lt;/font&gt;</code><font style="color:rgba(6, 8, 31, 0.88);"> </font><font style="color:rgba(6, 8, 31, 0.88);">接口的一部分，用于比较两个对象。其返回值的含义如下：</font></p>
<ul>
<li><font style="color:rgba(6, 8, 31, 0.88);">如果返回值小于 0，表示调用该方法的对象在字典顺序上小于被比较的对象。</font></li>
<li><font style="color:rgba(6, 8, 31, 0.88);">如果返回值等于 0，表示两个对象相等。</font></li>
<li><font style="color:rgba(6, 8, 31, 0.88);">如果返回值大于 0，表示调用该方法的对象在字典顺序上大于被比较的对象。</font></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">largestNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        String[] strs = <span class="keyword">new</span> <span class="title class_">String</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; nums.length; i++)&#123;</span><br><span class="line">            strs[i] = String.valueOf(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sort(strs, 0, strs.length - 1);</span></span><br><span class="line">        Arrays.sort(strs, (x , y) -&gt; (x + y).compareTo(y + x));</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">if</span>(strs[strs.length - <span class="number">1</span>].equals(<span class="string">&quot;0&quot;</span>))<span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> strs.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            res.append(strs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(String strs[], <span class="type">int</span> l, <span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> strs[l];</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">do</span> i++; <span class="keyword">while</span>((strs[i] + x).compareTo(x + strs[i]) &lt; <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">do</span> j--; <span class="keyword">while</span>((strs[j] + x).compareTo(x + strs[j]) &gt; <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> strs[i];</span><br><span class="line">                strs[i] = strs[j];</span><br><span class="line">                strs[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(strs, l, j);</span><br><span class="line">        sort(strs, j + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里有两种做法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种使用内置函数</span></span><br><span class="line">Arrays.sort(strs, (x , y) -&gt; (x + y).compareTo(y + x));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种使用快排</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(String strs[], <span class="type">int</span> l, <span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> strs[l];</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">do</span> i++; <span class="keyword">while</span>((strs[i] + x).compareTo(x + strs[i]) &lt; <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">do</span> j--; <span class="keyword">while</span>((strs[j] + x).compareTo(x + strs[j]) &gt; <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> strs[i];</span><br><span class="line">                strs[i] = strs[j];</span><br><span class="line">                strs[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(strs, l, j);</span><br><span class="line">        sort(strs, j + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>快排只需要修改while里面的判定条件即可。</p>
<h2 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a><a href="https://leetcode.cn/problems/sort-colors/">75. 颜色分类</a></h2><p><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">给定一个包含红色、白色和蓝色、共 </font><code>&lt;font style=&quot;color:rgba(38, 38, 38, 0.75);&quot;&gt;n&lt;/font&gt;</code><em><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font></em><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">个元素的数组 </font><code>&lt;font style=&quot;color:rgba(38, 38, 38, 0.75);&quot;&gt;nums&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> ，</font><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"><strong><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">原地</font></strong></a><strong><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font></strong><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</font></p>
<p><strong><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">其实就是快排，把模板放上去即可！！</font></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortColors</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        sort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = nums[l];</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">do</span> i++; <span class="keyword">while</span>(nums[i] &lt; x);</span><br><span class="line">            <span class="keyword">do</span> j--; <span class="keyword">while</span>(nums[j] &gt; x);</span><br><span class="line">            <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                nums[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nums, l, j);</span><br><span class="line">        sort(nums, j + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></h2><p>快排的另一种变形，快速选择。主要是利用排序后查找某个特定元素。</p>
<p>基本思路与「快速排序」一致，每次敲定一个基准值 x，根据当前与 x 的大小关系，将范围在 [l,r] 的 nums[i] 划分为到两边。</p>
<p>同时利用，利用题目只要求输出第 k 大的值，而不需要对数组进行整体排序，我们只需要根据划分两边后，第 k 大数会落在哪一边，来决定对哪边进行递归处理即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 数组长度 - k 等于 升序后第几个元素</span></span><br><span class="line">        <span class="keyword">return</span> sort(nums,<span class="number">0</span>,nums.length - <span class="number">1</span>, nums.length - k );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> l , <span class="type">int</span> r, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r)<span class="keyword">return</span> nums[k];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = nums[l];</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">do</span> i++; <span class="keyword">while</span>(nums[i] &lt; x);</span><br><span class="line">            <span class="keyword">do</span> j--; <span class="keyword">while</span>(nums[j] &gt; x);</span><br><span class="line">            <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                nums[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k &lt;= j)<span class="keyword">return</span> sort(nums, l , j , k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> sort(nums,j + <span class="number">1</span>,r, k);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a></h2><p><strong>目前只会简单暴力法</strong></p>
<p>如果数组长度为奇数，中位数就等于中间数 ， 否则， 等于 中间两个数之和  &#x2F; 2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> []nums = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length + nums2.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; nums1.length; i++)&#123;</span><br><span class="line">            nums[i] = nums1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j : nums2)&#123;</span><br><span class="line">            nums[i++] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> (nums[(nums.length - <span class="number">1</span>)/ <span class="number">2</span>] + nums[(nums.length / <span class="number">2</span>)]) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">q</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> p.next; <span class="comment">// 暂存后继节点 p.next</span></span><br><span class="line">            p.next = q;  		   <span class="comment">// 修改p.next指向前序节点</span></span><br><span class="line">            q = p;				   <span class="comment">// q的位置后移</span></span><br><span class="line">            p = tmp;			   <span class="comment">// p位置后移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>利用双指针修改链表的方向</p>
<h2 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a href="https://leetcode.cn/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h2><p><strong>注意这里的索引是从 1 开始的。</strong>迭代的思路大概是：先用一个 for 循环找到第 m 个位置，然后再用一个 for 循环将 m 和 n 之间的元素反转。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1729478275971-cb87e9cd-9229-4fc4-b941-423cf2959ba4.png">s</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; left - <span class="number">1</span>; i++)</span><br><span class="line">            p = p.next; <span class="comment">// 反转节点前一个</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> p.next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; right - left + <span class="number">1</span>; i++)&#123; <span class="comment">// 反转所有节点</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        p.next.next = cur;	<span class="comment">// 指向反转列表后面的第一个节点</span></span><br><span class="line">        p.next = pre;		<span class="comment">// 指向反转后的第一个节点</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="876-链表的中间结点"><a href="#876-链表的中间结点" class="headerlink" title="876. 链表的中间结点"></a><a href="https://leetcode.cn/problems/middle-of-the-linked-list/">876. 链表的中间结点</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">middleNode</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">q</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(q != <span class="literal">null</span> &amp;&amp; q.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            q = q.next.next;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>也是双指针，只是需要注意while()里面的判定条件</p>
<h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h2><p>设「第一个公共节点」为 node ，「链表 headA」的节点数量为 a ，「链表 headB」的节点数量为 b ，「两链表的公共尾部」的节点数量为 c ，则有：</p>
<p>头节点 headA 到 node 前，共有 a−c 个节点；</p>
<p>头节点 headB 到 node 前，共有 b−c 个节点；</p>
<p>考虑构建两个节点指针 A , B 分别指向两链表头节点 headA , headB ，做如下操作：</p>
<p>指针 A 先遍历完链表 headA ，再开始遍历链表 headB ，当走到 node 时，共走步数为：<strong>a+(b−c)</strong></p>
<p>指针 B 先遍历完链表 headB ，再开始遍历链表 headA ，当走到 node 时，共走步数为：<strong>b+(a−c)</strong></p>
<p>如下式所示，此时指针 A , B 重合，并有两种情况：</p>
<p><strong>a+(b−c)&#x3D;b+(a−c)</strong></p>
<p>若两链表 有 公共尾部 (即 c&gt;0 ) ：指针 A , B 同时指向 [第一个公共节点] node 。</p>
<p>若两链表 无 公共尾部 (即 c&#x3D;0 ) ：指针 A , B 同时指向 null 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">a</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">b</span> <span class="operator">=</span> headB;</span><br><span class="line">        <span class="keyword">while</span>(a != b)&#123;</span><br><span class="line">            a = a == <span class="literal">null</span> ? headB : a.next;</span><br><span class="line">            b = b == <span class="literal">null</span> ? headA : b.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast) <span class="comment">// 如果快慢指针都相等说明有环</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="328-奇偶链表"><a href="#328-奇偶链表" class="headerlink" title="328. 奇偶链表"></a><a href="https://leetcode.cn/problems/odd-even-linked-list/">328. 奇偶链表</a></h2><p>分成快慢指针，一个指着偶数，一个奇数，快的为奇数。</p>
<p>遍历：</p>
<p>慢指针的下一个指向快指针的下一个（即使偶数）</p>
<p>快指针的下一个指向满指针的下一个（即使奇数）</p>
<p>最后把两个链表拼接起来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">oddEvenList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyFast</span> <span class="operator">=</span> fast;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            slow.next = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast.next = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow.next = dummyFast;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a><a href="https://leetcode.cn/problems/implement-stack-using-queues/">225. 用队列实现栈</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> LinkedList&lt;Integer&gt; list = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        list.addLast(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(empty())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(list.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list.size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><a href="https://leetcode.cn/problems/spiral-matrix/">54. 螺旋矩阵</a></h2><p>空值处理： 当 matrix 为空时，直接返回空列表 [] 即可。</p>
<p>初始化： 矩阵 左、右、上、下 四个边界 l , r , t , b ，用于打印的结果列表 res 。</p>
<p>循环打印： “从左向右、从上向下、从右向左、从下向上” 四个方向循环打印。</p>
<p>根据边界打印，即将元素按顺序添加至列表 res 尾部。</p>
<p>边界向内收缩 1 （代表已被打印）。</p>
<p>判断边界是否相遇（是否打印完毕），若打印完毕则跳出。</p>
<p>返回值： 返回 res 即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">// 每一个边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = matrix[<span class="number">0</span>].length - <span class="number">1</span>, t =<span class="number">0</span> , b = matrix.length - <span class="number">1</span>, x =<span class="number">0</span>;</span><br><span class="line">        Integer[] res = <span class="keyword">new</span> <span class="title class_">Integer</span>[(r +<span class="number">1</span>) * (b + <span class="number">1</span>)];</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l; i &lt;= r; i++)res[x++] = matrix[t][i];</span><br><span class="line">            <span class="keyword">if</span>(++t &gt; b)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> t; i &lt;= b; i++)res[x++] = matrix[i][r];</span><br><span class="line">            <span class="keyword">if</span>(--r &lt; l)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> r; i &gt;= l; i--)res[x++] = matrix[b][i];</span><br><span class="line">            <span class="keyword">if</span>(--b &lt; t)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> b; i &gt;= t; i--)res[x++] = matrix[i][l];</span><br><span class="line">            <span class="keyword">if</span>(++l &gt; r)<span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(res);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h2><p><font style="color:rgb(38, 38, 38);background-color:rgb(245, 245, 245);">当调用 </font><code>&lt;font style=&quot;color:rgb(233, 105, 0);background-color:rgb(245, 245, 245);&quot;&gt;push&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(245, 245, 245);"> 让元素入队时，只要把元素压入 </font><code>&lt;font style=&quot;color:rgb(233, 105, 0);background-color:rgb(245, 245, 245);&quot;&gt;s1&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(245, 245, 245);"> 即可，时间复杂度 </font><code>&lt;font style=&quot;color:rgb(233, 105, 0);background-color:rgb(245, 245, 245);&quot;&gt;O(1)&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(245, 245, 245);">：</font></p>
<p><font style="color:rgb(38, 38, 38);background-color:rgb(245, 245, 245);">使用 </font><code>&lt;font style=&quot;color:rgb(233, 105, 0);background-color:rgb(245, 245, 245);&quot;&gt;peek&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(245, 245, 245);"> 或 </font><code>&lt;font style=&quot;color:rgb(233, 105, 0);background-color:rgb(245, 245, 245);&quot;&gt;pop&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(245, 245, 245);"> 操作队头的元素时，若 </font><code>&lt;font style=&quot;color:rgb(233, 105, 0);background-color:rgb(245, 245, 245);&quot;&gt;s2&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(245, 245, 245);"> 为空，可以把 </font><code>&lt;font style=&quot;color:rgb(233, 105, 0);background-color:rgb(245, 245, 245);&quot;&gt;s1&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(245, 245, 245);"> 的所有元素取出再添加进 </font><code>&lt;font style=&quot;color:rgb(233, 105, 0);background-color:rgb(245, 245, 245);&quot;&gt;s2&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(245, 245, 245);">，</font><strong><font style="color:rgb(38, 38, 38);background-color:rgb(245, 245, 245);">这时候 </font></strong><code>**&lt;font style=&quot;color:rgb(233, 105, 0);background-color:rgb(245, 245, 245);&quot;&gt;s2&lt;/font&gt;**</code><strong><font style="color:rgb(38, 38, 38);background-color:rgb(245, 245, 245);"> 中元素就是先进先出顺序了</font></strong><font style="color:rgb(38, 38, 38);background-color:rgb(245, 245, 245);">，不过这样移动所有元素的复杂度是 </font><code>&lt;font style=&quot;color:rgb(233, 105, 0);background-color:rgb(245, 245, 245);&quot;&gt;O(n)&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(245, 245, 245);">：</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1;</span><br><span class="line">    Stack&lt;Integer&gt; stack2;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        stack1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        peek();</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.empty())&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> stack1.pop();</span><br><span class="line">                stack2.push(val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack2.size() == <span class="number">0</span> &amp;&amp; stack1.size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a href="https://leetcode.cn/problems/min-stack/">155. 最小栈</a></h2><p><strong><font style="color:rgb(38, 38, 38);background-color:rgb(245, 245, 245);">每个元素入栈时，还要记下来当前栈中的最小值</font></strong><font style="color:rgb(38, 38, 38);background-color:rgb(245, 245, 245);">。</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack;</span><br><span class="line">    Stack&lt;Integer&gt; minStack;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        stack.push(val);</span><br><span class="line">        <span class="keyword">if</span>(minStack.isEmpty() || val &lt;= minStack.peek())&#123;</span><br><span class="line">            minStack.push(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(stack.pop().equals(minStack.peek()))&#123;</span><br><span class="line">            minStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></h2><p>利用栈存储数字，判断如果是符号，则取栈中元素出来计算。</p>
<p>但要判断第二个取出来元素 是&#x2F; - 于第一个元素的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String token: tokens)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;+-*/&quot;</span>.contains(token))&#123;  <span class="comment">// 判断符号</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> stack.pop(),b = stack.pop();</span><br><span class="line">                <span class="keyword">switch</span>(token)&#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                    stack.push(a + b);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                    stack.push(b - a);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                    stack.push(a *b);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                    stack.push(b / a);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stack.push(Integer.valueOf(token));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></h2><p>和上一题差不多思路，**<font style="color:rgb(38, 38, 38);background-color:rgb(245, 245, 245);">每个右括号 </font><strong><code>**&lt;font style=&quot;color:rgb(233, 105, 0);background-color:rgb(245, 245, 245);&quot;&gt;)&lt;/font&gt;**</code></strong><font style="color:rgb(38, 38, 38);background-color:rgb(245, 245, 245);"> 的左边必须有一个左括号 </font><strong><code>**&lt;font style=&quot;color:rgb(233, 105, 0);background-color:rgb(245, 245, 245);&quot;&gt;(&lt;/font&gt;**</code></strong><font style="color:rgb(38, 38, 38);background-color:rgb(245, 245, 245);"> 和它匹配</font>**<font style="color:rgb(38, 38, 38);background-color:rgb(245, 245, 245);">。</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span> || c==<span class="string">&#x27;&#123;&#x27;</span>)stack.push(c);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(!stack.isEmpty() &amp;&amp; stack.peek() == left(c))&#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">left</span><span class="params">(<span class="type">char</span> c)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(c ==<span class="string">&#x27;)&#x27;</span>)<span class="keyword">return</span> <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;]&#x27;</span>)<span class="keyword">return</span> <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#123;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1472-设计浏览器历史记录"><a href="#1472-设计浏览器历史记录" class="headerlink" title="1472. 设计浏览器历史记录"></a><a href="https://leetcode.cn/problems/design-browser-history/">1472. 设计浏览器历史记录</a></h2><p>双栈实现，通过一个新栈存储返回历史记录数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BrowserHistory</span> &#123;</span><br><span class="line">    Stack&lt;String&gt; stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    Stack&lt;String&gt; stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BrowserHistory</span><span class="params">(String homepage)</span> &#123;</span><br><span class="line">        stack1.push(homepage);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(String url)</span> &#123;</span><br><span class="line">        stack1.push(url);</span><br><span class="line">        stack2.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">back</span><span class="params">(<span class="type">int</span> steps)</span> &#123;</span><br><span class="line">       <span class="keyword">while</span>(steps-- &gt; <span class="number">0</span> &amp;&amp; stack1.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        stack2.push(stack1.pop());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> stack1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">forward</span><span class="params">(<span class="type">int</span> steps)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(steps-- &gt; <span class="number">0</span> &amp;&amp; stack2.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            stack1.push(stack2.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1209-删除字符串中的所有相邻重复项-II"><a href="#1209-删除字符串中的所有相邻重复项-II" class="headerlink" title="1209. 删除字符串中的所有相邻重复项 II"></a><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string-ii/">1209. 删除字符串中的所有相邻重复项 II</a></h2><p>迭代字符串：</p>
<pre><code>- 如果当前字符与前一个相同，栈顶元素加 1。
- 否则，往栈中压入 1。
    * 如果栈顶元素等于 k，则从字符串中删除这 k 个字符，并将 k 从栈顶移除。
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s);</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>; i &lt; sb.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> || sb.charAt(i) != sb.charAt(i - <span class="number">1</span>))&#123;</span><br><span class="line">                stack.push(<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">inc</span> <span class="operator">=</span> stack.pop() + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(inc == k)&#123;</span><br><span class="line">                    sb.delete(i - k + <span class="number">1</span>, i + <span class="number">1</span>);</span><br><span class="line">                    i = i - k;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    stack.push(inc); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1249-移除无效的括号"><a href="#1249-移除无效的括号" class="headerlink" title="1249. 移除无效的括号"></a><a href="https://leetcode.cn/problems/minimum-remove-to-make-valid-parentheses/">1249. 移除无效的括号</a></h2><p>用一个ok数组记录无效括号的位置</p>
<p>遍历字符串</p>
<p>如果是( 则进入数组 并且标记为无效，因为只有一个括号而已</p>
<p>如果是）判断栈是否为空，</p>
<p>是的话则说明它是无效数组</p>
<p>不是的话，则找到他前一个括号的位置，标记为有效数组</p>
<p>然后利用StringBuilder存储数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minRemoveToMakeValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">boolean</span>[] ok = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length()];</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">                ok[i] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">                    ok[i] = <span class="literal">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ok[stack.pop()] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!ok[i])&#123;</span><br><span class="line">                res.append(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="735-小行星碰撞"><a href="#735-小行星碰撞" class="headerlink" title="735. 小行星碰撞"></a><a href="https://leetcode.cn/problems/asteroid-collision/">735. 小行星碰撞</a></h2><p>遍历数组</p>
<p>设置boolean ok判断是否成功</p>
<p>当ok，栈不为空，并且栈顶 &gt; 0 数组小于0</p>
<p>如果栈顶元素 &gt;&#x3D; 数组元素 ，就说明数组元素的行星被撞碎了;退出循环</p>
<p>如果栈顶元素 &lt;&#x3D; 数组元素，栈顶元素的行星被撞碎了</p>
<p>如果还是ok 则把行星添加进去</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] asteroidCollision(<span class="type">int</span>[] ast) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : ast)&#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">ok</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">while</span>(ok &amp;&amp; !stack.isEmpty() &amp;&amp; stack.peek() &gt; <span class="number">0</span> &amp;&amp; i &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.peek() + i &gt;= <span class="number">0</span>)ok = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(stack.peek() + i &lt;= <span class="number">0</span>)stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ok)stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> stack.size();</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())res[--size] = stack.pop();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h1><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></h2><p>遍历数组，如果map中存在target - nums[i] 就说明 </p>
<p>target - nums[i] 和 nums[i] 是我们要找的数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt; <span class="number">2</span>)<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target - nums[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i,map.get(target - nums[i])&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a><a href="https://leetcode.cn/problems/longest-consecutive-sequence/">128. 最长连续序列</a></h2><p>1.将数组放进set中，去重</p>
<p>2.遍历set</p>
<p>如果set包含n - 1，说明他不是起点，continue</p>
<p>如果不包含，说明他是起点， 循环找出最长序列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestConsecutive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> n : nums)&#123;</span><br><span class="line">            set.add(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> n : set)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.contains(n - <span class="number">1</span>))&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> n;</span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(set.contains(num + <span class="number">1</span>))&#123;</span><br><span class="line">                    num += <span class="number">1</span>;</span><br><span class="line">                    len += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                res = Math.max(res, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146. LRU 缓存"></a><a href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存</a></h2><p>每次获取时，判断是否存在该元素，需要将数据重新放置最后的位置，标记最近使用</p>
<p>每次添加元素，需考虑是不是原有数据，是的话删除，重新放置</p>
<p>考虑容量，删除最旧最未使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    LinkedHashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> cap;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cap = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(key))<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">        map.remove(key);</span><br><span class="line">        map.put(key,val);</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">            map.remove(key);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">if</span>(map.size() &gt;= cap)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">old</span> <span class="operator">=</span> map.keySet().iterator().next();</span><br><span class="line">            map.remove(old);</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(key,value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="73-矩阵置零"><a href="#73-矩阵置零" class="headerlink" title="73. 矩阵置零"></a><a href="https://leetcode.cn/problems/set-matrix-zeroes/">73. 矩阵置零</a></h2><p>先遍历一次，找到等于0的位置</p>
<p>在遍历一次，把含有0的位置的行列全置0</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setZeroes</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">       HashSet&lt;Integer&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">       HashSet&lt;Integer&gt; set2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">       <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                set1.add(i);</span><br><span class="line">                set2.add(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(set1.contains(i) || set2.contains(j))&#123;</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="380-O-1-时间插入、删除和获取随机元素"><a href="#380-O-1-时间插入、删除和获取随机元素" class="headerlink" title="380. O(1) 时间插入、删除和获取随机元素"></a><a href="https://leetcode.cn/problems/insert-delete-getrandom-o1/">380. O(1) 时间插入、删除和获取随机元素</a></h2><ul>
<li><code>&lt;font style=&quot;color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);&quot;&gt;insert&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 操作：使用哈希表判断 </font><code>&lt;font style=&quot;color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);&quot;&gt;val&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 是否存在，存在的话返回 </font><code>&lt;font style=&quot;color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);&quot;&gt;false&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">，否则将其添加到 </font><code>&lt;font style=&quot;color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);&quot;&gt;nums&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">，更新 </font><code>&lt;font style=&quot;color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);&quot;&gt;idx&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">，同时更新哈希表；</font></li>
<li><code>&lt;font style=&quot;color:rgba(38, 38, 38, 0.75);&quot;&gt;remove&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 操作：使用哈希表判断 </font><code>&lt;font style=&quot;color:rgba(38, 38, 38, 0.75);&quot;&gt;val&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 是否存在，不存在的话返回 </font><code>&lt;font style=&quot;color:rgba(38, 38, 38, 0.75);&quot;&gt;false&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">，否则从哈希表中将 </font><code>&lt;font style=&quot;color:rgba(38, 38, 38, 0.75);&quot;&gt;val&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 删除，同时取出其所在 </font><code>&lt;font style=&quot;color:rgba(38, 38, 38, 0.75);&quot;&gt;nums&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 的下标 </font><code>&lt;font style=&quot;color:rgba(38, 38, 38, 0.75);&quot;&gt;loc&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">，然后将 </font><code>&lt;font style=&quot;color:rgba(38, 38, 38, 0.75);&quot;&gt;nums[idx]&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 赋值到 </font><code>&lt;font style=&quot;color:rgba(38, 38, 38, 0.75);&quot;&gt;loc&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 位置，并更新 </font><code>&lt;font style=&quot;color:rgba(38, 38, 38, 0.75);&quot;&gt;idx&lt;/font&gt;</code><font style="color:rgba(38, 38, 38, 0.75);">（</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">含义为将原本处于 </font><code>&lt;font style=&quot;color:rgba(38, 38, 38, 0.75);&quot;&gt;loc&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 位置的元素删除），同时更新原本位于 </font><code>&lt;font style=&quot;color:rgba(38, 38, 38, 0.75);&quot;&gt;idx&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 位置的数在哈希表中的值为 </font><code>&lt;font style=&quot;color:rgba(38, 38, 38, 0.75);&quot;&gt;loc&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">（若 </font><code>&lt;font style=&quot;color:rgba(38, 38, 38, 0.75);&quot;&gt;loc&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 与 </font><code>&lt;font style=&quot;color:rgba(38, 38, 38, 0.75);&quot;&gt;idx&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 相等，说明删除的是最后一个元素，这一步可跳过）；</font></li>
<li><code>&lt;font style=&quot;color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);&quot;&gt;getRandom&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 操作：由于我们人为确保了 </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">[0,</font><em><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">idx</font></em><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">]</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 均为存活值，因此直接在 </font><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">[0,</font><em><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">idx</font></em><font style="color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);">+1)</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 范围内进行随机即可。</font></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RandomizedSet</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">200010</span>];</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RandomizedSet</span><span class="params">()</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(val))&#123;</span><br><span class="line">            map.put(val, ++idx);</span><br><span class="line">            nums[idx] = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(val))&#123;</span><br><span class="line">            <span class="type">int</span> loc= map.remove(val);</span><br><span class="line">            <span class="keyword">if</span>(loc != idx)map.put(nums[idx], loc);  <span class="comment">// 不是最后的位置</span></span><br><span class="line">            nums[loc] = nums[idx--];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRandom</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[random.nextInt(idx +<span class="number">1</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="350-两个数组的交集-II"><a href="#350-两个数组的交集-II" class="headerlink" title="350. 两个数组的交集 II"></a><a href="https://leetcode.cn/problems/intersection-of-two-arrays-ii/">350. 两个数组的交集 II</a></h2><p>1.首先判断最大数组，重新进入函数，减少哈希空间</p>
<p>2.遍历最大数组，计算每个元素的count值</p>
<p>3.遍历小数组，发现是否出现相同元素</p>
<p>如果count &gt;0 则存在相同，count - 1，添加元素进入临时输入</p>
<p>如果还大于1， 修改count值</p>
<p>不是的话，删除该元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersect(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1.length &lt; nums2.length)&#123;</span><br><span class="line">            intersect(nums2, nums1);</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums1)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">            map.put(num, count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] innums = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums2)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> map.getOrDefault(num, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(count &gt; <span class="number">0</span> )&#123;</span><br><span class="line">                 count--;</span><br><span class="line">                innums[idx++] = num;</span><br><span class="line">                <span class="keyword">if</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    map.put(num, count);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    map.remove(num);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(innums, <span class="number">0</span> , idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a><a href="https://leetcode.cn/problems/group-anagrams/">49. 字母异位词分组</a></h2><p>map的value存的是对应单词的所有类型</p>
<p>遍历strs，对每个单词进行排序获得最简单的单词，找到存在map里的链表，如果没有则创建新的链表，然后把原来的strs存入链表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        HashMap&lt;String, ArrayList&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String s : strs)&#123;</span><br><span class="line">            <span class="type">char</span>[] c = s.toCharArray();</span><br><span class="line">            Arrays.sort(c);</span><br><span class="line">            <span class="type">String</span> <span class="variable">t</span> <span class="operator">=</span> String.valueOf(c);</span><br><span class="line">            map.putIfAbsent(t,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            map.get(t).add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(map.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h2><p>先遍历左边界，并且判断是否和target一致，不一致则返回-1</p>
<p>再遍历左边界。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span>  <span class="operator">=</span> searchL(nums, <span class="number">0</span> , nums.length - <span class="number">1</span>, target);</span><br><span class="line">        <span class="keyword">if</span>(i == -<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> searchR(nums, <span class="number">0</span> , nums.length - <span class="number">1</span>,target);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i,j&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchL</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l , <span class="type">int</span> r, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l ) / <span class="number">2</span>;</span><br><span class="line">             <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[l] == target)<span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchR</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l , <span class="type">int</span> r, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l  + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></h2><p>设 x&#x3D;nums[mid] 是我们现在二分取到的数。</p>
<p>现在需要判断 x 和 target 的位置关系，谁在左边，谁在右边？</p>
<p>核心思路</p>
<p>如果 x 和 target 在不同的递增段：</p>
<p>如果 target 在第一段（左），x 在第二段（右），说明 x 在 target 右边；</p>
<p>如果 target 在第二段（右），x 在第一段（左），说明 x 在 target 左边。</p>
<p>如果 x 和 target 在相同的递增段：比较 x 和 target 的大小即可。</p>
<p>下面只讨论 x 在 target 右边，或者等于 target 的情况。其余情况 x 一定在 target 左边。</p>
<p>如果 x&gt;nums[n−1]，说明 x 在第一段中，那么 target 也必须在第一段中（否则 x 一定在 target 左边）且 x 必须大于等于 target。</p>
<p>写成代码就是 _<strong>target &gt; nums[n - 1] &amp;&amp; x &gt;&#x3D; target</strong>_。</p>
<p>如果 x≤nums[n−1]，说明 x 在第二段中（或者 nums 只有一段），那么 target 可以在第一段，也可以在第二段。</p>
<p>如果 target 在第一段，那么 x 一定在 target 右边。</p>
<p>如果 target 在第二段，那么 x 必须大于等于 target。</p>
<p>写成代码就是 _<strong>target &gt; nums[n - 1] || x &gt;&#x3D; target</strong>_。</p>
<p>根据这两种情况，去判断 x 和 target 的位置关系，从而不断地缩小 target 所在位置的范围，二分找到 target。</p>
<p>细节</p>
<p>二分的范围可以是 [0,n−2]。</p>
<p>这是因为，如果 target 在数组中的位置是 n−1，那么上面分类讨论中的代码，计算结果均为 false。这意味着每次二分更新的都是 left，那么最终答案自然就是 n−1。</p>
<h2 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a><a href="https://leetcode.cn/problems/search-insert-position/">35. 搜索插入位置</a></h2><p>普通二分查找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span> || nums[<span class="number">0</span>] &gt;= target)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[nums.length - <span class="number">1</span>] &lt; target)<span class="keyword">return</span> nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>,  r = nums.length -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m] &lt; target)&#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r = m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="240-搜索二维矩阵-II"><a href="#240-搜索二维矩阵-II" class="headerlink" title="240. 搜索二维矩阵 II"></a><a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II</a></h2><p>也是二分查找，只是条件不一样了</p>
<p>从矩阵的左下角开始查找，</p>
<p>如果大于target，则行数-1；<br>       如果小于target，则列数+1；直到遍历结束</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span>  <span class="operator">=</span> matrix.length  -<span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &lt; matrix[<span class="number">0</span>].length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] &gt;target)i--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] &lt; target)j++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287. 寻找重复数"></a><a href="https://leetcode.cn/problems/find-the-duplicate-number/">287. 寻找重复数</a></h2><table>
<thead>
<tr>
<th>nums</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody><tr>
<td>cnt</td>
<td>1</td>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
</tbody></table>
<p>从上面数组分析，m &#x3D; 2， 经历遍历后 count &#x3D; 3, </p>
<p>coumt &gt; 3，说明重复数在左边，</p>
<p>反之 重复数在右边。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (l + r)/ <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> num: nums)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num &lt;= m)</span><br><span class="line">                    count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count &gt; m)r = m;</span><br><span class="line">            <span class="keyword">else</span> l = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h2><p>当 <code>nums[i]</code>&gt;<code>nums[j]</code> 时： <code>nums[i]</code> 可以接在 <code>nums[j]</code> 之后（此题要求严格递增），此情况下最长上升子序列长度为 dp[j]+1 ；</p>
<p>当 <code>nums[i]</code>&lt;&#x3D;<code>nums[j]</code> 时： <code>nums[i]</code> 无法接在<code>nums[j]</code>之后，此情况上升子序列不成立，跳过。</p>
<p>上述所有 1. 情况 下计算出的 <code>dp[j]+1</code> 的最大值，为直到 i 的最长上升子序列长度（即 dp[i] ）。实现方式为遍历 j 时，每轮执行 <code>dp[i]=max(dp[i],dp[j]+1)</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        Arrays.fill(dp,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &lt; nums[i])dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(dp[i], res );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a><a href="https://leetcode.cn/problems/container-with-most-water/">11. 盛最多水的容器</a></h2><p>先计算容量长度length<br>然后判断哪边矮一点，然后利用矮的作用存储容量</p>
<p>最后移动矮的指针</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span><span class="number">0</span>, r = height.length -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> r - l;</span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Math.min(height[l], height[r]);</span><br><span class="line">            res = Math.max(res, max * length );</span><br><span class="line">            <span class="keyword">if</span>(height[l] &gt; height[r])r--;</span><br><span class="line">            <span class="keyword">else</span> l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></h2><p>这道题其实就算3个数之和为0，边界条件多一点而已，</p>
<p>首先如果num[0] &gt; 0 , 说明后面的数都是&gt; 0的，或者数组长度  &lt;  3直接返回。</p>
<p>然后开始遍历数组，设置头尾指针开始遍历，</p>
<p>如果找到了一个符合条件，存入链表，还要查找是否存在指针的数据，迭代到下个不存在的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>] &gt; <span class="number">0</span> || nums.length &lt; <span class="number">3</span>)<span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>, k = nums.length -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; k)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] + nums[i] + nums[k] == <span class="number">0</span>)&#123;</span><br><span class="line">                    res.add(Arrays.asList(nums[i], nums[j],nums[k]));</span><br><span class="line">                    <span class="keyword">while</span>(j &lt; k &amp;&amp; nums[j] == nums[j + <span class="number">1</span>])j++;</span><br><span class="line">                    <span class="keyword">while</span>(j &lt; k &amp;&amp; nums[k] == nums[k - <span class="number">1</span>])k--;</span><br><span class="line">                    j++; k--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[j] + nums[i] + nums[k] &lt; <span class="number">0</span>) j++;</span><br><span class="line">                <span class="keyword">else</span> k--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h2><p>先遍历n个元素，使得cur2移动n次</p>
<p>然后再次遍历，让cur1和cur2一起移动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur1</span> <span class="operator">=</span> p;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur2</span> <span class="operator">=</span> p;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(cur2.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur1.next = cur1.next.next;</span><br><span class="line">        <span class="keyword">return</span> p.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a><a href="https://leetcode.cn/problems/next-permutation/">31. 下一个排列</a></h2><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2024/gif/34596451/1731373952133-94205cd1-8a54-4b58-8f05-e4f3eb276e5c.gif"></h2><p>首先从后面遍历，直至前一个小于后一个元素，说明此处是转换位置记为i</p>
<p>然后又重新从后面遍历，与nums[i]进行比较，如果存在小于元素，说明是该元素与i互换位置，换转位置后，i位置后的元素需重新排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nextPermutation</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="number">1</span>])&#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[j])&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, i , j);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(nums, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> i , <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            swap(nums, left, right);</span><br><span class="line">            left++;right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p><a href="https://leetcode.cn/problems/sort-colors/">75. 颜色分类</a><br>快排</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortColors</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        sort(nums, <span class="number">0</span> , nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[]nums, <span class="type">int</span> l , <span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l - <span class="number">1</span>,j = r + <span class="number">1</span>,x = nums[l];</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">do</span> i++; <span class="keyword">while</span>(nums[i] &lt; x);</span><br><span class="line">            <span class="keyword">do</span> j--; <span class="keyword">while</span>(nums[j] &gt; x);</span><br><span class="line">            <span class="keyword">if</span>(i &lt; j) swap(nums, i , j);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nums, l, j);</span><br><span class="line">        sort(nums, j + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="141-环形链表-1"><a href="#141-环形链表-1" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></h2><p> 使用快慢指针即可，注意循环条件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">       <span class="keyword">while</span>(fast!= <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="keyword">if</span>(fast == slow)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a>  </p>
<p>首先找到环开始的地方，然后让slow重新开始和fast一起遍历，如果重叠说明是环结束的地方</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        ListNode fast, slow;</span><br><span class="line">        fast = slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != slow)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="148-排序链表-1"><a href="#148-排序链表-1" class="headerlink" title="148. 排序链表"></a><a href="https://leetcode.cn/problems/sort-list/">148. 排序链表</a></h2><ul>
<li><strong><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">分割 cut 环节：</font></strong><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 找到当前链表 </font><code>&lt;font style=&quot;color:rgba(38, 38, 38, 0.75);&quot;&gt;中点&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">，并从 </font><code>&lt;font style=&quot;color:rgba(38, 38, 38, 0.75);&quot;&gt;中点&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 将链表断开（以便在下次递归 </font><code>&lt;font style=&quot;color:rgba(38, 38, 38, 0.75);&quot;&gt;cut&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 时，链表片段拥有正确边界）；</font><ul>
<li><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">我们使用 </font><code>&lt;font style=&quot;color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);&quot;&gt;fast,slow&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 快慢双指针法，奇数个节点找到中点，偶数个节点找到中心左边的节点。</font></li>
<li><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">找到中点 </font><code>&lt;font style=&quot;color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);&quot;&gt;slow&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 后，执行 </font><code>&lt;font style=&quot;color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);&quot;&gt;slow.next = None&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 将链表切断。</font></li>
<li><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">归分割时，输入当前链表左端点 </font><code>&lt;font style=&quot;color:rgba(38, 38, 38, 0.75);&quot;&gt;head&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 和中心节点 </font><code>&lt;font style=&quot;color:rgba(38, 38, 38, 0.75);&quot;&gt;slow&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 的下一个节点 </font><code>&lt;font style=&quot;color:rgba(38, 38, 38, 0.75);&quot;&gt;tmp&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">(因为链表是从 </font><code>&lt;font style=&quot;color:rgba(38, 38, 38, 0.75);&quot;&gt;slow&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 切断的)。</font></li>
<li><strong><font style="background-color:rgb(240, 240, 240);">cut 递归终止条件：</font></strong><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 当 </font><code>&lt;font style=&quot;color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);&quot;&gt;head.next == None&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 时，说明只有一个节点了，直接返回此节点。</font></li>
</ul>
</li>
<li><strong><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">合并 merge 环节：</font></strong><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 将两个排序链表合并，转化为一个排序链表。</font><ul>
<li><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">双指针法合并，建立辅助 ListNode </font><code>&lt;font style=&quot;color:rgba(38, 38, 38, 0.75);&quot;&gt;h&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 作为头部</font></li>
<li><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">设置两指针 </font><code>&lt;font style=&quot;color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);&quot;&gt;left&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">, </font><code>&lt;font style=&quot;color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);&quot;&gt;right&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 分别指向两链表头部，比较两指针处节点值大小，由小到大加入合并链表头部，指针交替前进，直至添加完两个链表。</font></li>
<li><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">返回辅助ListNode</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><code>&lt;font style=&quot;color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);&quot;&gt;h&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">作为头部的下个节点</font><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> </font><code>&lt;font style=&quot;color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);&quot;&gt;h.next&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">。</font></li>
<li><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">时间复杂度 </font><code>&lt;font style=&quot;color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);&quot;&gt;O(l + r)&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">，</font><code>&lt;font style=&quot;color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);&quot;&gt;l, r&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 分别代表两个链表长度。</font></li>
</ul>
</li>
<li><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);">当题目输入的 </font><code>&lt;font style=&quot;color:rgba(38, 38, 38, 0.75);background-color:rgb(240, 240, 240);&quot;&gt;head == None&lt;/font&gt;</code><font style="color:rgb(38, 38, 38);background-color:rgb(240, 240, 240);"> 时，直接返回 None。</font></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)<span class="keyword">return</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next, slow = head;</span><br><span class="line">        <span class="keyword">if</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next !=<span class="literal">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> slow.next;</span><br><span class="line">        slow.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">left</span> <span class="operator">=</span> sortList(head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">right</span> <span class="operator">=</span> sortList(tmp);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> h;</span><br><span class="line">        <span class="keyword">while</span>(left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(left.val &lt; right.val)&#123;</span><br><span class="line">                h.next = left;</span><br><span class="line">                left = left.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                h.next = right;</span><br><span class="line">                right = right.next;</span><br><span class="line">            &#125;</span><br><span class="line">            h = h.next;</span><br><span class="line">        &#125;</span><br><span class="line">        h.next = left != <span class="literal">null</span> ? left : right;</span><br><span class="line">        <span class="keyword">return</span> res.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="160-相交链表-1"><a href="#160-相交链表-1" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h2><p> 遍历两个链表，如果为空说明到底了，从对面链表开始。<img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1732063322222-515254af-a0f7-42b6-ba6a-3221802e4ad3.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">a</span> <span class="operator">=</span> headA;</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">b</span> <span class="operator">=</span> headB;</span><br><span class="line">       <span class="keyword">while</span>(a != b)&#123;</span><br><span class="line">            a = a != <span class="literal">null</span> ? a.next : headB;</span><br><span class="line">            b = b != <span class="literal">null</span> ? b.next : headA;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a href="https://leetcode.cn/problems/palindrome-linked-list/">234. 回文链表</a></h2><p>这道题关键是判断这个链表是奇数还是偶数，<br>因此首先遍历链表找到中位数，然后反转后面的链表即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast != <span class="literal">null</span>) slow = slow.next;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">r</span> <span class="operator">=</span> reverse(slow);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(r != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(r.val != l.val)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            r = r.next;</span><br><span class="line">            l = l.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>, cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next =  pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a href="https://leetcode.cn/problems/move-zeroes/">283. 移动零</a></h2><p>双指针遍历，先遍历有数据的，再遍历0</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span> ; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                nums[j++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(; j &lt; nums.length; j++)&#123;</span><br><span class="line">            nums[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="287-寻找重复数-1"><a href="#287-寻找重复数-1" class="headerlink" title="287. 寻找重复数"></a><a href="https://leetcode.cn/problems/find-the-duplicate-number/">287. 寻找重复数</a></h2><p>这题思路是二分查找</p>
<p>设置一个cnt，找到nums中小于等于mid 的元素，如果cnt &gt; mid 说明，cnt里面存在重复元素，否则的话说明在另外一个区间里面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (l + r )/ <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">             <span class="comment">// nums 中小于等于 mid 的元素的个数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> num: nums)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num &lt;= m)cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt &gt; m)r = m;</span><br><span class="line">            <span class="keyword">else</span> l = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="581-最短无序连续子数组"><a href="#581-最短无序连续子数组" class="headerlink" title="581. 最短无序连续子数组"></a><a href="https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/">581. 最短无序连续子数组</a></h2><p>设置最大值max，最小值min，左边界l，右边界r</p>
<p>首先从头开始遍历，找到非单调递增区域，</p>
<p>如果存在nums[i] &lt; max ，则可以认为i当前存在于非单调递增区域。所以存起来一直遍历，刷新r的位置。</p>
<p>同理可得：</p>
<p>l为非单调递增区域的最前位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findUnsortedSubarray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> nums[n - <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; max)&#123;</span><br><span class="line">                r = i;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                max = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; min)&#123;</span><br><span class="line">                l = i;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                min = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r -l + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p><strong><font style="color:rgb(29, 29, 32);">动态规划是一种“从底至顶”的方法</font></strong><font style="color:rgb(29, 29, 32);">：从最小子问题的解开始，迭代地构建更大子问题的解，直至得到原问题的解。</font></p>
<p><font style="color:rgb(29, 29, 32);">由于动态规划不包含回溯过程，因此只需使用循环迭代实现，无须使用递归。</font><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1732687794410-121b3ddd-0dfb-4000-a451-774b33495746.png"><font style="color:rgb(29, 29, 32);">与回溯算法一样，动态规划也使用“状态”概念来表示问题求解的特定阶段，每个状态都对应一个子问题以及相应的局部最优解。例如，爬楼梯问题的状态定义为当前所在楼梯阶数</font><code>&lt;font style=&quot;color:rgb(29, 29, 32);&quot;&gt; &lt;/font&gt;&lt;font style=&quot;color:rgb(29, 29, 32);&quot;&gt;i&lt;/font&gt;</code><font style="color:rgb(29, 29, 32);"> 。</font></p>
<p><font style="color:rgb(29, 29, 32);">根据以上内容，我们可以总结出动态规划的常用术语。</font></p>
<ul>
<li><font style="color:rgb(29, 29, 32);">将数组 </font><code>dp</code><font style="color:rgb(29, 29, 32);"> 称为 </font><code>&lt;u&gt;&lt;font style=&quot;color:rgb(29, 29, 32);&quot;&gt;dp&lt;/font&gt;&lt;/u&gt;</code><u><font style="color:rgb(29, 29, 32);"> 表</font></u><font style="color:rgb(29, 29, 32);">，</font><code>&lt;font style=&quot;color:rgb(29, 29, 32);&quot;&gt;dp[i]&lt;/font&gt;</code><font style="color:rgb(29, 29, 32);"> 表示状态 </font><code>&lt;font style=&quot;color:rgb(29, 29, 32);&quot;&gt;i&lt;/font&gt;&lt;font style=&quot;color:rgb(29, 29, 32);&quot;&gt; &lt;/font&gt;</code><font style="color:rgb(29, 29, 32);">对应子问题的解。</font></li>
<li><font style="color:rgb(29, 29, 32);">将最小子问题对应的状态（第</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">1</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">阶和第</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">2</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">阶楼梯）称为</font><u><font style="color:rgb(29, 29, 32);">初始状态</font></u><font style="color:rgb(29, 29, 32);">。</font></li>
<li><font style="color:rgb(29, 29, 32);">将递推公式 </font><code>&lt;font style=&quot;color:rgb(29, 29, 32);&quot;&gt;dp[i]=dp[i−1]+dp[i−2]&lt;/font&gt;</code><font style="color:rgb(29, 29, 32);"> 称为</font><u><font style="color:rgb(29, 29, 32);">状态转移方程</font></u><font style="color:rgb(29, 29, 32);">。</font></li>
</ul>
<h2 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯</a></h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1732689847755-37f61466-e51a-4a0b-a2d9-38a5a58d8e3f.png"></p>
<p><font style="color:rgb(29, 29, 32);">设</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">d</font><font style="color:rgb(29, 29, 32);">p</font><font style="color:rgb(29, 29, 32);">[</font><font style="color:rgb(29, 29, 32);">i</font><font style="color:rgb(29, 29, 32);">]</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">为爬到第</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">i</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">阶累计付出的代价，由于第</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">i</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">阶只可能从</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">i</font><font style="color:rgb(29, 29, 32);">−</font><font style="color:rgb(29, 29, 32);">1</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">阶或</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">i</font><font style="color:rgb(29, 29, 32);">−</font><font style="color:rgb(29, 29, 32);">2</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">阶走来，因此</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">d</font><font style="color:rgb(29, 29, 32);">p</font><font style="color:rgb(29, 29, 32);">[</font><font style="color:rgb(29, 29, 32);">i</font><font style="color:rgb(29, 29, 32);">]</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">只可能等于</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">d</font><font style="color:rgb(29, 29, 32);">p</font><font style="color:rgb(29, 29, 32);">[</font><font style="color:rgb(29, 29, 32);">i</font><font style="color:rgb(29, 29, 32);">−</font><font style="color:rgb(29, 29, 32);">1</font><font style="color:rgb(29, 29, 32);">]</font><font style="color:rgb(29, 29, 32);">+</font><font style="color:rgb(29, 29, 32);">c</font><font style="color:rgb(29, 29, 32);">o</font><font style="color:rgb(29, 29, 32);">s</font><font style="color:rgb(29, 29, 32);">t</font><font style="color:rgb(29, 29, 32);">[</font><font style="color:rgb(29, 29, 32);">i</font><font style="color:rgb(29, 29, 32);">]</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">或</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">d</font><font style="color:rgb(29, 29, 32);">p</font><font style="color:rgb(29, 29, 32);">[</font><font style="color:rgb(29, 29, 32);">i</font><font style="color:rgb(29, 29, 32);">−</font><font style="color:rgb(29, 29, 32);">2</font><font style="color:rgb(29, 29, 32);">]</font><font style="color:rgb(29, 29, 32);">+</font><font style="color:rgb(29, 29, 32);">c</font><font style="color:rgb(29, 29, 32);">o</font><font style="color:rgb(29, 29, 32);">s</font><font style="color:rgb(29, 29, 32);">t</font><font style="color:rgb(29, 29, 32);">[</font><font style="color:rgb(29, 29, 32);">i</font><font style="color:rgb(29, 29, 32);">]</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">。为了尽可能减少代价，我们应该选择两者中较小的那一个：</font></p>
<p><code>&lt;font style=&quot;color:rgb(29, 29, 32);&quot;&gt;dp[i]=min(dp[i−1],dp[i−2])+cost[i]&lt;/font&gt;</code></p>
<p><font style="color:rgb(29, 29, 32);">这便可以引出最优子结构的含义：</font><strong><font style="color:rgb(29, 29, 32);">原问题的最优解是从子问题的最优解构建得来的</font></strong><font style="color:rgb(29, 29, 32);">。</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cost.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = cost[<span class="number">1</span>]; dp[<span class="number">0</span>] = cost[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="comment">// 找到最优解</span></span><br><span class="line">            dp[i] = Math.min(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>]) + cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(dp[n], dp[n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><a href="https://leetcode.cn/problems/minimum-path-sum/">64. 最小路径和</a></h2><p>每一次都会让棋子让右或者往下走一步，设当前格子为[i , j]， 则往下或往右则变为[i + 1,j]或者[i , j + 1]<br>因此需要利用两个属性存储数据。<img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1732690207753-75ed64d5-11ff-41a2-8406-9f12d50f9b6f.png"></p>
<p>然后找出最优解，<font style="color:rgb(29, 29, 32);">对于状态</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">[</font><font style="color:rgb(29, 29, 32);">i</font><font style="color:rgb(29, 29, 32);">,</font><font style="color:rgb(29, 29, 32);">j</font><font style="color:rgb(29, 29, 32);">]</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">，它只能从上边格子</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">[</font><font style="color:rgb(29, 29, 32);">i</font><font style="color:rgb(29, 29, 32);">−</font><font style="color:rgb(29, 29, 32);">1</font><font style="color:rgb(29, 29, 32);">,</font><font style="color:rgb(29, 29, 32);">j</font><font style="color:rgb(29, 29, 32);">]</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">和左边格子</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">[</font><font style="color:rgb(29, 29, 32);">i</font><font style="color:rgb(29, 29, 32);">,</font><font style="color:rgb(29, 29, 32);">j</font><font style="color:rgb(29, 29, 32);">−</font><font style="color:rgb(29, 29, 32);">1</font><font style="color:rgb(29, 29, 32);">]</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">转移而来。因此最优子结构为：到达</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">[</font><font style="color:rgb(29, 29, 32);">i</font><font style="color:rgb(29, 29, 32);">,</font><font style="color:rgb(29, 29, 32);">j</font><font style="color:rgb(29, 29, 32);">]</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">的最小路径和由</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">[</font><font style="color:rgb(29, 29, 32);">i</font><font style="color:rgb(29, 29, 32);">,</font><font style="color:rgb(29, 29, 32);">j</font><font style="color:rgb(29, 29, 32);">−</font><font style="color:rgb(29, 29, 32);">1</font><font style="color:rgb(29, 29, 32);">]</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">的最小路径和与</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">[</font><font style="color:rgb(29, 29, 32);">i</font><font style="color:rgb(29, 29, 32);">−</font><font style="color:rgb(29, 29, 32);">1</font><font style="color:rgb(29, 29, 32);">,</font><font style="color:rgb(29, 29, 32);">j</font><font style="color:rgb(29, 29, 32);">]</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">的最小路径和中较小的那一个决定。</font></p>
<p><font style="color:rgb(29, 29, 32);">根据以上分析，可推出图 14-12 所示的状态转移方程：</font></p>
<p><code> dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];</code></p>
<p><strong><font style="color:rgb(29, 29, 32);">确定边界条件和状态转移顺序</font></strong></p>
<p><font style="color:rgb(29, 29, 32);">在本题中，处在首行的状态只能从其左边的状态得来，处在首列的状态只能从其上边的状态得来，因此首行</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">i</font><font style="color:rgb(29, 29, 32);">&#x3D;</font><font style="color:rgb(29, 29, 32);">0</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">和首列</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">j</font><font style="color:rgb(29, 29, 32);">&#x3D;</font><font style="color:rgb(29, 29, 32);">0</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">是边界条件。</font></p>
<p><font style="color:rgb(29, 29, 32);">如图 14-13 所示，由于每个格子是由其左方格子和上方格子转移而来，因此我们使用循环来遍历矩阵，外循环遍历各行，内循环遍历各列。</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1732690308258-dda67089-1408-432f-bc18-c2e553d02585.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length, m = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][m];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>] + grid[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            dp[j][<span class="number">0</span>] = dp[j - <span class="number">1</span>][<span class="number">0</span>] + grid[j][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; m; j++)&#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1732760507297-9a250285-c1d9-4fa6-a173-c11997e70ea9.png"></p>
<p>由图所得，物品i对应的重量wgt[i]和价值val[i],每一个物品只能放一次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 0-1 背包：动态规划 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">knapsackDP</span><span class="params">(<span class="type">int</span>[] wgt, <span class="type">int</span>[] val, <span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> wgt.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][cap + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= cap; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(wgt[i] &gt; j)&#123;</span><br><span class="line">                <span class="comment">// 超重</span></span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 不选物品和选物品进行比较</span></span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - wgt[i - <span class="number">1</span>] + val[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][cap];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p>和0-1背包不同的是，它的物品可以放多次，<img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1732765797466-38d9c0eb-5ff0-49b0-82f3-818822426df4.png"><font style="color:rgb(29, 29, 32);">在完全背包问题的规定下，状态</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">[</font><font style="color:rgb(29, 29, 32);">i</font><font style="color:rgb(29, 29, 32);">,</font><font style="color:rgb(29, 29, 32);">c</font><font style="color:rgb(29, 29, 32);">]</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">的变化分为两种情况。</font></p>
<ul>
<li><strong><font style="color:rgb(29, 29, 32);">不放入物品 </font>****<font style="color:rgb(29, 29, 32);">i</font></strong><font style="color:rgb(29, 29, 32);"> ：与 0-1 背包问题相同，转移至 </font><code>&lt;font style=&quot;color:rgb(29, 29, 32);&quot;&gt;[i−1,c] &lt;/font&gt;</code><font style="color:rgb(29, 29, 32);">。</font></li>
<li><strong><font style="color:rgb(29, 29, 32);">放入物品 </font>****<font style="color:rgb(29, 29, 32);">i</font></strong><font style="color:rgb(29, 29, 32);"> ：与 0-1 背包问题不同，转移至 </font><code>&lt;font style=&quot;color:rgb(29, 29, 32);&quot;&gt;[i,c−wgt[i−1]] 。&lt;/font&gt;</code></li>
</ul>
<p><font style="color:rgb(29, 29, 32);">从而状态转移方程变为：</font></p>
<p><code>&lt;font style=&quot;color:rgb(29, 29, 32);&quot;&gt;dp[i,c]=max(dp[i−1,c],dp[i,c−wgt[i−1]]+val[i−1])&lt;/font&gt;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 完全背包：动态规划 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">unboundedKnapsackDP</span><span class="params">(<span class="type">int</span>[] wgt, <span class="type">int</span>[] val, <span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> wgt.length;</span><br><span class="line">    <span class="comment">// 初始化 dp 表</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][cap + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">1</span>; c &lt;= cap; c++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (wgt[i - <span class="number">1</span>] &gt; c) &#123;</span><br><span class="line">                <span class="comment">// 若超过背包容量，则不选物品 i</span></span><br><span class="line">                dp[i][c] = dp[i - <span class="number">1</span>][c];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不选和选物品 i 这两种方案的较大值</span></span><br><span class="line">                dp[i][c] = Math.max(dp[i - <span class="number">1</span>][c], dp[i][c - wgt[i - <span class="number">1</span>]] + val[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][cap];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></h2><p>看作完全背包的另一种思路，但求得是最小值</p>
<p><code>&lt;font style=&quot;color:rgb(29, 29, 32);&quot;&gt;dp[i,a]=min(dp[i−1,a],dp[i,a−coins[i−1]]+1)&lt;/font&gt;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 零钱兑换：动态规划 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">coinChangeDP</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amt)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> coins.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">MAX</span> <span class="operator">=</span> amt + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 初始化 dp 表</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][amt + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 状态转移：首行首列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>; a &lt;= amt; a++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][a] = MAX;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 状态转移：其余行和列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>; a &lt;= amt; a++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (coins[i - <span class="number">1</span>] &gt; a) &#123;</span><br><span class="line">                <span class="comment">// 若超过目标金额，则不选硬币 i</span></span><br><span class="line">                dp[i][a] = dp[i - <span class="number">1</span>][a];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不选和选硬币 i 这两种方案的较小值</span></span><br><span class="line">                dp[i][a] = Math.min(dp[i - <span class="number">1</span>][a], dp[i][a - coins[i - <span class="number">1</span>]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][amt] != MAX ? dp[n][amt] : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="518-零钱兑换-II"><a href="#518-零钱兑换-II" class="headerlink" title="518. 零钱兑换 II"></a><a href="https://leetcode.cn/problems/coin-change-ii/">518. 零钱兑换 II</a></h2><p><font style="color:rgb(29, 29, 32);">本题目标是求组合数量，因此子问题变为：</font><strong><font style="color:rgb(29, 29, 32);">前</font><strong><strong><font style="color:rgb(29, 29, 32);"> </font></strong></strong><font style="color:rgb(29, 29, 32);">i</font><strong><strong><font style="color:rgb(29, 29, 32);"> </font></strong></strong><font style="color:rgb(29, 29, 32);">种硬币能够凑出金额</font><strong><strong><font style="color:rgb(29, 29, 32);"> </font></strong></strong><font style="color:rgb(29, 29, 32);">a</font><strong><strong><font style="color:rgb(29, 29, 32);"> </font></strong></strong><font style="color:rgb(29, 29, 32);">的组合数量</font></strong><font style="color:rgb(29, 29, 32);">。而</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">d</font><font style="color:rgb(29, 29, 32);">p</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">表仍然是尺寸为</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">(</font><font style="color:rgb(29, 29, 32);">n</font><font style="color:rgb(29, 29, 32);">+</font><font style="color:rgb(29, 29, 32);">1</font><font style="color:rgb(29, 29, 32);">)</font><font style="color:rgb(29, 29, 32);">×</font><font style="color:rgb(29, 29, 32);">(</font><font style="color:rgb(29, 29, 32);">a</font><font style="color:rgb(29, 29, 32);">m</font><font style="color:rgb(29, 29, 32);">t</font><font style="color:rgb(29, 29, 32);">+</font><font style="color:rgb(29, 29, 32);">1</font><font style="color:rgb(29, 29, 32);">)</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">的二维矩阵。</font></p>
<p><font style="color:rgb(29, 29, 32);">当前状态的组合数量等于不选当前硬币与选当前硬币这两种决策的组合数量之和。状态转移方程为：</font></p>
<p><code>&lt;font style=&quot;color:rgb(29, 29, 32);&quot;&gt;dp[i,a]=dp[i−1,a]+dp[i,a−coins[i−1]]&lt;/font&gt;</code></p>
<p><font style="color:rgb(29, 29, 32);">当目标金额为 </font><font style="color:rgb(29, 29, 32);">0</font><font style="color:rgb(29, 29, 32);"> 时，无须选择任何硬币即可凑出目标金额，因此应将首列所有 </font><font style="color:rgb(29, 29, 32);">dp[i,0]</font><font style="color:rgb(29, 29, 32);"> 都初始化为 </font><font style="color:rgb(29, 29, 32);">1</font><font style="color:rgb(29, 29, 32);"> 。当无硬币时，无法凑出任何 </font><font style="color:rgb(29, 29, 32);">&gt;0</font><font style="color:rgb(29, 29, 32);"> 的目标金额，因此首行所有 </font><font style="color:rgb(29, 29, 32);">dp[0,a]</font><font style="color:rgb(29, 29, 32);"> 都等于 </font><font style="color:rgb(29, 29, 32);">0</font><font style="color:rgb(29, 29, 32);"> 。</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 零钱兑换 II：动态规划 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">coinChangeIIDP</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amt)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> coins.length;</span><br><span class="line">    <span class="comment">// 初始化 dp 表</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][amt + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 初始化首列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>; a &lt;= amt; a++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (coins[i - <span class="number">1</span>] &gt; a) &#123;</span><br><span class="line">                <span class="comment">// 若超过目标金额，则不选硬币 i</span></span><br><span class="line">                dp[i][a] = dp[i - <span class="number">1</span>][a];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不选和选硬币 i 这两种方案之和</span></span><br><span class="line">                dp[i][a] = dp[i - <span class="number">1</span>][a] + dp[i][a - coins[i - <span class="number">1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][amt];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a><a href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离</a></h2><p><font style="color:rgb(29, 29, 32);">输入两个字符串</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">s</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">和</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">t</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">，返回将</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">s</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">转换为</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">t</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">所需的最少编辑步数。</font></p>
<p><font style="color:rgb(29, 29, 32);">你可以在一个字符串中进行三种编辑操作：插入一个字符、删除一个字符、将字符替换为任意一个字符。</font></p>
<ul>
<li><font style="color:rgb(29, 29, 32);">若 s[n−1] 和 t[m−1] 相同，我们可以跳过它们，直接考虑 s[n−2] 和 t[m−2] 。</font></li>
<li><font style="color:rgb(29, 29, 32);">若 s[n−1] 和 t[m−1] 不同，我们需要对 s 进行一次编辑（插入、删除、替换），使得两字符串尾部的字符相同，从而可以跳过它们，考虑规模更小的问题。</font></li>
</ul>
<p>不同的操作：</p>
<ol>
<li><font style="color:rgb(29, 29, 32);">在 s[i−1] 之后添加 t[j−1] ，则剩余子问题 dp[i,j−1] 。</font></li>
<li><font style="color:rgb(29, 29, 32);">删除</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">s</font><font style="color:rgb(29, 29, 32);">[</font><font style="color:rgb(29, 29, 32);">i</font><font style="color:rgb(29, 29, 32);">−</font><font style="color:rgb(29, 29, 32);">1</font><font style="color:rgb(29, 29, 32);">]</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">，则剩余子问题</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">d</font><font style="color:rgb(29, 29, 32);">p</font><font style="color:rgb(29, 29, 32);">[</font><font style="color:rgb(29, 29, 32);">i</font><font style="color:rgb(29, 29, 32);">−</font><font style="color:rgb(29, 29, 32);">1</font><font style="color:rgb(29, 29, 32);">,</font><font style="color:rgb(29, 29, 32);">j</font><font style="color:rgb(29, 29, 32);">]</font><font style="color:rgb(29, 29, 32);"> </font><font style="color:rgb(29, 29, 32);">。</font></li>
<li><font style="color:rgb(29, 29, 32);">将 s[i−1] 替换为 t[j−1] ，则剩余子问题 dp[i−1,j−1] 。</font></li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1732850457021-05776b8b-9ccc-4fd6-a17f-26eba829f32d.png"><font style="color:rgb(29, 29, 32);">可得最优子结构：dp[i,j] 的最少编辑步数等于 dp[i,j−1]、dp[i−1,j]、dp[i−1,j−1] 三者中的最少编辑步数，再加上本次的编辑步数 1 。对应的状态转移方程为：</font></p>
<p><code>&lt;font style=&quot;color:rgb(29, 29, 32);&quot;&gt;dp[i,j]=min(dp[i,j−1],dp[i−1,j],dp[i−1,j−1])+1&lt;/font&gt;</code></p>
<p><font style="color:rgb(29, 29, 32);"></font></p>
<p><strong><font style="color:rgb(29, 29, 32);">确定边界条件和状态转移顺序</font></strong></p>
<p><font style="color:rgb(29, 29, 32);">当两字符串都为空时，编辑步数为 0 ，即 dp[0,0]&#x3D;0 。</font><strong><font style="color:rgb(29, 29, 32);">当 s 为空但 t 不为空时</font></strong><font style="color:rgb(29, 29, 32);">，最少编辑步数等于 t 的长度，即首行</font><code>&lt;font style=&quot;color:rgb(29, 29, 32);&quot;&gt; dp[0,j]=j&lt;/font&gt;</code><font style="color:rgb(29, 29, 32);"> 。</font><strong><font style="color:rgb(29, 29, 32);">当 s 不为空但 t 为空时</font></strong><font style="color:rgb(29, 29, 32);">，最少编辑步数等于 s 的长度，即首列 </font><code>&lt;font style=&quot;color:rgb(29, 29, 32);&quot;&gt;dp[i,0]=i&lt;/font&gt;</code><font style="color:rgb(29, 29, 32);"> 。</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> word1.length(), m = word2.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j&lt;= m; j++)&#123;</span><br><span class="line">                <span class="comment">// 如果字符相等</span></span><br><span class="line">                <span class="keyword">if</span>(word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]),dp[i - <span class="number">1</span>][j - <span class="number">1</span>])+ <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="674-最长连续递增序列"><a href="#674-最长连续递增序列" class="headerlink" title="674. 最长连续递增序列"></a><a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/">674. 最长连续递增序列</a></h2><p>前一个和后一个比较，小了+1，大了重新排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLengthOfLCIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt; <span class="number">1</span>)<span class="keyword">return</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i + <span class="number">1</span>] &gt; nums[i])&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = count &gt; ans ? count : ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a href="https://leetcode.cn/problems/unique-paths/">62. 不同路径</a></h2><p>跟背包差不多</p>
<p>如果是边界为0的话，则步数 + 1，不是的话等于上面的值+左边的值 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">       <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m ;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**<br>**</p>
<p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/"><strong><font style="background-color:rgb(240, 240, 240);">121. 买卖股票的最佳时机</font></strong></a>**<font style="background-color:rgb(240, 240, 240);"><br></font>**想卖出最大利润，则需要计算股价最小值，使用min统计，由于只能进行一次买卖，所以使用res维护最大值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> prices[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            res = Math.max(res, prices[i] - min);</span><br><span class="line">            min = Math.min(min, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a href="https://leetcode.cn/problems/jump-game/">55. 跳跃游戏</a></h2><p>如果i   &gt; c 说明没法跳跃了或者c &#x3D; 0，返回false</p>
<p>计算跳跃位置 从i 跳跃到 i + nums[i]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(i &gt; c)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           c = Math.max(c, i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45. 跳跃游戏 II"></a><a href="https://leetcode.cn/problems/jump-game-ii/">45. 跳跃游戏 II</a></h2><p>这道题应该是贪心做法比较好，但这里举出dp形式的</p>
<p>注意 i + j &lt; n;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[]dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        Arrays.fill(dp,Integer.MAX_VALUE);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">// 这里从可0遍历到最远地方.判断最小次数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= nums[i] &amp;&amp; i + j &lt; nums.length; j++)&#123;</span><br><span class="line">                dp[i + j] = Math.min(dp[i + j], dp[i] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍</a></h2><p>跳格偷钱，如果拿了i 家的钱，下一家就必须是i + 2,因此有</p>
<p>dp[i] &#x3D; Math.max(dp[i - 1], dp[i - 2] + nums[i - 1]）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>],dp[i - <span class="number">2</span>] + nums[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="337-打家劫舍-III"><a href="#337-打家劫舍-III" class="headerlink" title="337. 打家劫舍 III"></a><a href="https://leetcode.cn/problems/house-robber-iii/">337. 打家劫舍 III</a></h2><p>和上一题相比这道题是使用树节点，这次抢了就要跳过下家，去下下家</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    HashMap&lt;TreeNode, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(root))&#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> root.val + (root.left == <span class="literal">null</span> ? <span class="number">0</span> : rob(root.left.left) + rob(root.left.right))</span><br><span class="line">        + (root.right == <span class="literal">null</span> ? <span class="number">0</span> : rob(root.right.left) + rob(root.right.right));</span><br><span class="line">        <span class="type">int</span> <span class="variable">nd</span> <span class="operator">=</span> rob(root.left) + rob(root.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Math.max(d, nd);</span><br><span class="line">        map.put(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/"><font style="color:rgb(38, 38, 38);">121. 买卖股票的最佳时机</font></a></h2><font style="background-color:rgb(240, 240, 240);">  
</font><font style="color:rgb(38, 38, 38);">想卖出最大利润，则需要计算股价最小值，使用min统计，由于只能进行一次买卖，所以使用res维护最大值</font>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> prices[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            res = Math.max(res, prices[i] - min);</span><br><span class="line">            min = Math.min(min, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 给第一次赋值</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="comment">// 计算卖出最佳时机</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            <span class="comment">// 计算买入费用</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="309-买卖股票的最佳时机含冷冻期"><a href="#309-买卖股票的最佳时机含冷冻期" class="headerlink" title="309. 买卖股票的最佳时机含冷冻期"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 买卖股票的最佳时机含冷冻期</a></h2><p>这道题比上一道多了一个冷却时间，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            dp[i + <span class="number">2</span>][<span class="number">0</span>] = Math.max(dp[i + <span class="number">1</span>][<span class="number">0</span>],dp[i + <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i + <span class="number">2</span>][<span class="number">1</span>] = Math.max(dp[i + <span class="number">1</span>][<span class="number">1</span>],dp[i][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n + <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>复习</tag>
      </tags>
  </entry>
  <entry>
    <title>资料网站</title>
    <url>/2023/09/27/%E8%B5%84%E6%96%99%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<p><a href="https://javabetter.cn/">主页 | 二哥的Java进阶之路 (javabetter.cn)</a></p>
<p><a href="https://javaguide.cn/">Java 面试指南 | JavaGuide</a></p>
<p><a href="https://xiaolincoding.com/">小林coding (xiaolincoding.com)</a></p>
<p><a href="https://chat.gptapi.us/#/">NextChat (gptapi.us)</a></p>
<p><a href="https://juejin.cn/post/7057537968923213837">(一)JVM成神路之初识虚拟机 - 探寻Java虚拟机的前世今生之秘 - 掘金 (juejin.cn)</a></p>
<p><a href="https://topjavaer.cn/">主页 | Java学习&amp;面试指南-程序员大彬 (topjavaer.cn)</a></p>
<p><a href="https://www.pdai.tech/">| Java 全栈知识体系 (pdai.tech)</a></p>
]]></content>
      <tags>
        <tag>复习</tag>
      </tags>
  </entry>
  <entry>
    <title>面经</title>
    <url>/2024/11/24/%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<p>没回答出来用❌标注<br>重复出现用🌟标注</p>
<h2 id="介绍自己"><a href="#介绍自己" class="headerlink" title="介绍自己"></a>介绍自己</h2><p>我是XXX，XX 届学生，目前就读xxx，本科学历，就读的专业是软件工程，很荣幸参加贵公司的面试。 我会的技能是MySQL、Redis、Spring、Spring MVC、Spring Boot、RabbitMQ 等技术栈。我曾经在校参加过 中国机器人及人工智能大赛获得全国二等奖，以及学校一等奖学金。 我使用 Spring boot +  MySQL + Redis + RabbitMQ 总共做过 3 个项目，其中有两个项目我已经写在简历上了并且附上了gitee地址，等会您有任何关于项目或技能点的问题都可以问我。因为我的技术栈和公司的技术栈非常匹配，所以来了之后就能直接干活，大大节省了新人培养成本。</p>
<h2 id="限流工具类怎么实现？"><a href="#限流工具类怎么实现？" class="headerlink" title="限流工具类怎么实现？"></a>限流工具类怎么实现？</h2><p>先介绍主流的几种限流方式：</p>
<ul>
<li><p><strong>固定窗口计数器</strong>，优点是实现简单、易于理解和部署，缺点是可能存在时间不对称以及难以应对突发流量</p>
</li>
<li><p><strong>滑动窗口计数器</strong>，优点是能更好应对突发流量，缺点是实现复杂、需要维护窗口的状态</p>
</li>
<li><p><strong>令牌桶算法</strong>，优点是能够很好地平滑流量，允许一定程度的突发流量，缺点是需要更多资源来维护令牌桶状态、不能处理长时间的突发流量</p>
</li>
<li><p><strong>漏桶算法</strong>，优点是可以按照恒定的速率限制请求且算法相对简单，缺点是不够灵活、无法应对突发流量、可能导致请求延迟</p>
</li>
</ul>
<p>再说（我采用的是<strong>固定窗口计数器限流</strong>）</p>
<ul>
<li>加了一个继承自HttpFilter的限流过滤器在CORS过滤器之后</li>
<li>采用filrer对来自同个IP的请求计数（每次请求前加HTTP过滤器）</li>
<li>限流工具类的Redis的key是ip地址，value是访问次数</li>
<li>编写了多个逻辑的方法以供不同目的的限流，如<ul>
<li>针对单次频率限制，请求成功后一段时间不得再发起请求（如点击请求邮件或者手机验证码）</li>
<li>针对一段时间内多次请求的频率限制（如3秒内最多允许20次请求，例如论坛的评论）</li>
<li>针对于需要采取阶段封禁的频率限制（如防止用户频繁申请JWT令牌，如果已经提示无法登录而用户还在请求，那么就封禁更长时间）</li>
</ul>
</li>
</ul>
<h2 id="为什么要用mq进行发送验证码呢？"><a href="#为什么要用mq进行发送验证码呢？" class="headerlink" title="为什么要用mq进行发送验证码呢？"></a>为什么要用mq进行发送验证码呢？</h2><p>使用mq可以做持久化功能，防止验证码没发成功或者发送一般宕机情况发生，在大量请求过来的情况下，发邮件本身就是一个比较耗时的操作，线程可能存在被占用完的情况。</p>
<h2 id="“楼中楼”评论是如何做的？"><a href="#“楼中楼”评论是如何做的？" class="headerlink" title="“楼中楼”评论是如何做的？"></a>“楼中楼”评论是如何做的？</h2><p>答：<strong>数据库中额外的引用字段</strong></p>
<ul>
<li>数据库comment表中有一个quote字段和root字段，如果是一级评论（也就是直接评论帖子）则quote，root字段值均为-1（无效值）</li>
<li>如果是评论的评论，那么子评论的quote字段的值为父评论的ID，root字段值为根评论的ID</li>
</ul>
<h2 id="如何在1000个子评论中找到我回复的那个人最上层的子评论，找到整个评论链？"><a href="#如何在1000个子评论中找到我回复的那个人最上层的子评论，找到整个评论链？" class="headerlink" title="如何在1000个子评论中找到我回复的那个人最上层的子评论，找到整个评论链？"></a>如何在1000个子评论中找到我回复的那个人最上层的子评论，找到整个评论链？</h2><p>先查当前评论的引用id，然后递归查询最上面那条，直接他的根，引用id都为根评论id</p>
<h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>布隆过滤器是一种数据结构，用于快速判断一个元素是否存在一个集合中，它牺牲一定的准确性为代价，换取了存储空间的极大节省和查询速度的显著提升。在当前项目中我初始化了一个可以存储1百万个元素的布隆过滤器，误码率在0.001，太高的误码率肯呢个会导致性能的缺失，因此我选择了这个，<br>在创建链接的同时判断布隆过滤器是否存在这个短连接，存在则抛出异常，否则的话，布隆过滤器添加该短连接。</p>
<h2 id="缓存3大问题？"><a href="#缓存3大问题？" class="headerlink" title="缓存3大问题？"></a>缓存3大问题？</h2><ul>
<li><strong>缓存击穿</strong>：热点数据过期（也就是<strong>热点key问题</strong>处理）<ul>
<li>互斥锁更新数据</li>
<li>热点数据永不过期</li>
</ul>
</li>
<li><strong>缓存穿透</strong>：请求数据既不在缓存，也不在数据库<ul>
<li>缓存空值或者默认值（占用内存大）</li>
<li>使用<strong>布隆过滤器</strong>快速判断数据是否存在（实现复杂）</li>
</ul>
</li>
<li><strong>缓存雪崩</strong>：大量缓存数据同时过期，或者redis故障<ul>
<li>均匀设置过期时间</li>
<li>互斥锁更新数据</li>
</ul>
</li>
<li><strong>Redis故障宕机</strong><ul>
<li>服务熔断</li>
<li>请求限流</li>
<li>构建Redis集群</li>
</ul>
</li>
</ul>
<h2 id="redis如何保证消息队列消费业务仅一次？"><a href="#redis如何保证消息队列消费业务仅一次？" class="headerlink" title="redis如何保证消息队列消费业务仅一次？"></a>redis如何保证消息队列消费业务仅一次？</h2><p>即使消息队列保证了“至少一次”消费，也可能导致同一条消息被多次投递。网络故障可能导致消息被重新发送。捉着在分布式系统中，多个消费者可能同时处理消息。通过 Redis，我们可以在消费前检查UUID是否已经处理过。即使消息队列保证了“至少一次”消费，</p>
]]></content>
  </entry>
  <entry>
    <title>软件架构设计复习</title>
    <url>/2024/12/09/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="软件危机"><a href="#软件危机" class="headerlink" title="软件危机"></a><font style="color:rgb(0,176,240);">软件危机</font></h1><p><font style="color:rgb(0,176,240);">了解软件危机的表现形式，及其根源。了解老化软件的四个特性。</font></p>
<p><font style="color:rgb(255,0,0);">软件危机的表现形式：</font>①软件不能按时完成；</p>
<p>②软件超出预算；</p>
<p>③软件不能正常运行；</p>
<p>④软件难以维护（使用周期短）；</p>
<p><font style="color:rgb(255,0,0);">软件危机的问题根源：</font>①开发效率低；</p>
<p>②产品质量差；</p>
<p>③产品难维护；</p>
<p><font style="color:rgb(255,0,0);">软件老化的四个特性：</font>①过于僵硬（rigidity）；</p>
<p>②过于脆弱（fragility)；</p>
<p>③复用率低（immobility）；</p>
<p>④黏性高（viscosity）；</p>
<h1 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h1><p><strong>六字基本原则：</strong>高内聚、低耦合</p>
<p>类模块中高内聚、低耦合体现在<font style="color:rgb(255,0,0);">：</font></p>
<ul>
<li>信息隐藏（降低类之间的耦合）</li>
<li>概念完整性（提高类的内聚性）</li>
</ul>
<h3 id="图类"><a href="#图类" class="headerlink" title="图类"></a>图类</h3><p>他们分别是:依赖、关联、聚合、组合、继承、实现。他们的耦合度依次增强</p>
<p><font style="color:rgb(255,0,0);">依赖：</font>方法参数或局部变量为另一个类<img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1733385747822-35cefcda-45f3-4a60-a426-8cf9f45c7894.png"></p>
<p>依赖关系的定义为：对于两个相对独立的对象，当一个对象负责构造另一个对象的实例，或者依赖另一个对象的服务时，这两个对象之间主要体现为依赖关系。定义比较晦涩难懂，但在java中的表现还是比较直观的：类A当中使用了类B，其中类B是作为类A的方法参数、方法中的局部变量、或者静态方法调用。类上面的图例中：People类依赖于Book类和Food类，Book类和Food类是作为类中方法的参数形式出现在People类中的。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1733385741741-cd99f8ea-524c-4914-b02d-a8344c687da0.png"></p>
<h4 id="关联："><a href="#关联：" class="headerlink" title="关联："></a><font style="color:rgb(255,0,0);">关联：</font></h4><p>成员类型为另一个类<img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1733385753664-66840cec-b626-446e-8085-604234a4f151.png"><br>对于两个相对独立的对象，当一个对象的实例与另一个对象的一些特定实例存在固定的对应关系时，这两个对象之间为关联关系。关联关系分为单向关联和双向关联。在java中，单向关联表现为：类A当中使用了类B，其中类B是作为类A的成员变量。双向关联表现为：类A当中使用了类B作为成员变量；同时类B中也使用了类A作为成员变量。<img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1733385764730-0a0001cb-4702-4fdf-b911-079e979ecd40.png"></p>
<h4 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a><font style="color:#DF2A3F;">聚合</font><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1733385812272-2e1304bf-72f7-45ac-8db2-76b1480f69fb.png"></h4><p>聚合关系是关联关系的一种，耦合度强于关联，他们的代码表现是相同的，仅仅是在语义上有所区别：关联关系的对象间是相互独立的，而聚合关系的对象之间存在着包容关系，他们之间是“整体-个体”的相互关系。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1733385818423-f46c0d9a-7981-4b10-9949-94216ad1fd62.png"></p>
<h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合<img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1733385832006-54be8602-0abd-4842-9c93-c88652731da6.png"></h4><p> 相比于聚合，组合是一种耦合度更强的关联关系。存在组合关系的类表示“整体-部分”的关联关系，“整体”负责“部分”的生命周期，他们之间是共生共死的；并且“部分”单独存在时没有任何意义。在下图的例子中，People与Soul、Body之间是组合关系，当人的生命周期开始时，必须同时有灵魂和肉体；当人的生命周期结束时，灵魂肉体随之消亡；无论是灵魂还是肉体，都不能单独存在，他们必须作为人的组成部分存在。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1733385842143-36f8b3a6-611b-4af3-8525-2426054f39be.png"></p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承<img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1733385857983-ccf52cdb-9f63-4c39-912a-94aa2feb533f.png"></h4><p> 继承表示类与类（或者接口与接口）之间的父子关系。在java中，用关键字extends表示继承关系。UML图例中，继承关系用实线+空心箭头表示，箭头指向父类。<img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1733385872550-7fa09911-131d-4599-a264-afec884c55b5.png"></p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>符号：<img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1733385913331-87c816fc-56da-449c-ad6b-85ff529eea24.png">定义：表示一个类实现一个或多个接口的方法。接口定义好操作的集合，由实现类去完成接口的具体操作。在java中使用implements表示。UML图例中，实现关系用虚线+空心箭头表示，箭头指向接口。<img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1733385917281-87fe2dab-64bd-4f58-a94d-0c61e78a26c2.png"></p>
<h1 id="设计思维"><a href="#设计思维" class="headerlink" title="设计思维"></a>设计思维</h1><p><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1733385977222-51a36811-98da-4e42-86a7-8fbd50c112a8.png"></p>
<h2 id="契约设计含义"><a href="#契约设计含义" class="headerlink" title="契约设计含义"></a>契约设计含义</h2><p><font style="color:rgb(255,0,0);"></font>契约通过方法的前置条件、后置条件以及类的不变量描述。</p>
<ul>
<li>前置条件：需要方法的调用者保证。</li>
<li>后置条件：需要方法的提供者保证。</li>
<li>不变量：是类范围定义的，类的每个实例都必须保持或满足</li>
</ul>
<p><font style="color:rgb(0,176,240);">理解基于契约设计能够保证软件正确性的特点，软件设计的三大质量目标中每一项分别通过哪些来保证</font><font style="color:rgb(0,176,240);">?</font></p>
<p><font style="color:rgb(255,0,0);">正确性：</font>正确性软件的基本要求,往往通过契约式编程来保障。</p>
<p><font style="color:rgb(255,0,0);">三大质量目标：</font>重用性、扩展性、兼容性</p>
<p><font style="color:rgb(255,0,0);">三大质量目标的保证：</font>通过SOLID原则和其他设计原则来保证。</p>
<h2 id="SOLID原则"><a href="#SOLID原则" class="headerlink" title="SOLID原则"></a>SOLID原则</h2><p>SOLID原则：要想将OOP的长处发挥出来，要想有贯彻总的设计理念，要想解决具体的设计问题，需要像SOLID原则来提供这种具体的行动准则和思考方法。</p>
<p>单一职责原则（SRP）：一个类绝不要因为多于一个原因变化。</p>
<p>开闭原则（OCP）：对软件实体(类、模块、函数)等扩展开放对修改关闭</p>
<p>里氏替换原则（LSP）：引用了基类的功能，在使用派生类对象代替基类后应不受影响，</p>
<p>且不须知道具体为何种派生类。</p>
<p>接口隔离原则（ISP）：客户不应该被强迫去依赖他们不使用的接口。</p>
<p>依赖倒置原则（DIP）：高层模块不应依赖低层模块。不仅如此，二者都要依赖于抽象。</p>
<p><font style="color:rgb(0,176,240);">理解和掌握面向对象方法的优点。</font></p>
<p><font style="color:rgb(255,0,0);">优点：</font>①提高软件产品的审美标准</p>
<pre><code> ②提高软件的各项特性

 ③延长软件的生命周期
</code></pre>
<p><font style="color:rgb(0,176,240);">理解和掌握瀑布、迭代模型两种主要的开发过程及其涵义。</font></p>
<p><font style="color:rgb(255,0,0);">瀑布模型：</font>需求分析-&gt;设计-&gt;构建-&gt;系统集成与测试—&gt;系统维护</p>
<p>理想化开发方式（线性过程）</p>
<p><font style="color:rgb(255,0,0);">迭代模型：</font></p>
<p>现实化开发方式（反复过程）</p>
<p><font style="color:rgb(255,0,0);">RUP迭代过程：</font>业务建模-&gt;需求-&gt;分析及设计-&gt;实现-&gt;测试-&gt;部署</p>
<h2 id="三种注入方式"><a href="#三种注入方式" class="headerlink" title="三种注入方式"></a>三种注入方式</h2><p><strong>依赖查找：</strong>一个对象在运行时与另一个对象建立链接，以便在运行时可以根据名称找到另一个对象。</p>
<p>**<font style="color:#262626;">依赖注入：</font>**一个对象并不能依赖查找那主动在注册中查到链接，而是被动地等待相关的关联。</p>
<p>**<font style="color:#262626;">三种形式的注入：</font>**构造注入、依赖注入、接口注入</p>
<h2 id="架构定义"><a href="#架构定义" class="headerlink" title="架构定义"></a>架构定义</h2><p>**<font style="color:#262626;">架构：</font>**针对特定问题给出的可复用架构设计方案。参考架构只是设计方案，供解决类似问题时参考。</p>
<p>**<font style="color:#262626;">架构模式：</font>**解决架构问题的已被证实有效的解决方案。架构模式是架构设计经验的总结。</p>
<p>**<font style="color:#262626;">设计模式：</font>**一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。</p>
<h3 id="架构设计五步"><a href="#架构设计五步" class="headerlink" title="架构设计五步"></a>架构设计五步</h3><ul>
<li><font style="color:#262626;">识别架构目标</font></li>
<li><font style="color:#262626;">识别关键场景</font></li>
<li><font style="color:#262626;">建立应用概貌</font></li>
<li><font style="color:#262626;">识别关键问题</font></li>
<li><font style="color:#262626;">定义候选方案</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1733386069559-8336e239-4d0c-4720-a8da-1d11b74311cd.png"></p>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a><font style="color:#262626;">AOP</font></h3><p>**<font style="color:#262626;">横切关注点：</font>**可能适用于所有逻辑层、组件和物理层的设计特性</p>
<p><font style="color:#262626;">例子：</font>身份认证与授权、缓存、通信、配置管理、异常管理、日志、验证</p>
<h1 id="设计模式："><a href="#设计模式：" class="headerlink" title="设计模式："></a>设计模式：</h1><h2 id="适配者模式"><a href="#适配者模式" class="headerlink" title="适配者模式"></a>适配者模式</h2><p><font style="color:rgb(44, 62, 80);">把一个类接口转换成另一个用户需要的接口。</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1733386637214-b6c0085b-efc4-4c46-8006-a58de1e1bec5.png"></p>
<p>鸭子(Duck)和火鸡(Turkey)拥有不同的叫声，Duck 的叫声调用 quack() 方法，而 Turkey 调用 gobble() 方法。</p>
<p>要求将 Turkey 的 gobble() 方法适配成 Duck 的 quack() 方法，从而让火鸡冒充鸭子！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">quack</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Turkey</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">gobble</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WildTurkey</span> <span class="keyword">implements</span> <span class="title class_">Turkey</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">gobble</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;gobble!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TurkeyAdapter</span> <span class="keyword">implements</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">    Turkey turkey;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TurkeyAdapter</span><span class="params">(Turkey turkey)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.turkey = turkey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quack</span><span class="params">()</span> &#123;</span><br><span class="line">        turkey.gobble();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Turkey</span> <span class="variable">turkey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WildTurkey</span>();</span><br><span class="line">        <span class="type">Duck</span> <span class="variable">duck</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TurkeyAdapter</span>(turkey);</span><br><span class="line">        duck.quack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p>动态地扩展一个对象的功能，而不需要改变原始类代码的一种成熟模式。</p>
<p><font style="color:rgb(255,0,0);">案例：</font>实现机动车接口（IAuto）的有敞篷车（Comvetible）和豪华轿车（Lumousine）；对于任何类型汽车都可以加装不同配件(Equipment)类，有导航系统（Navigation），空调（AirConditioner），以及侧面气囊系统（SideAirBag）；而且配件可以随意进行组合和搭配。并且支持扩展新的车辆或配件种类。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1733386762948-eac8e130-4de7-4224-83a9-d390e3642f9b.png"></p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p><font style="color:rgb(44, 62, 80);">控制对其它对象的访问。</font></p>
<p>通过代理对象增加一层间接性。代理对象实现与主题对象相同的接口，并且负责控制和增强对主题对象的访问。</p>
<ul>
<li>远程代理(Remote Proxy): 控制对远程对象(不同地址空间)的访问，它负责将请求及其参数进行编码，并向不同地址空间中的对象发送已经编码的请求。</li>
<li>虚拟代理(Virtual Proxy): 根据需要创建开销很大的对象，它可以缓存实体的附加信息，以便延迟对它的访问，例如在网站加载一个很大图片时，不能马上完成，可以用虚拟代理缓存图片的大小信息，然后生成一张临时图片代替原始图片。</li>
<li>保护代理(Protection Proxy): 按权限控制对象的访问，它负责检查调用者是否具有实现一个请求所必须的访问权限。</li>
<li>智能代理(Smart Reference): 取代了简单的指针，它在访问对象时执行一些附加操作: 记录对象的引用次数；当第一次引用一个持久化对象时，将它装入内存；在访问一个实际对象前，检查是否已经锁定了它，以确保其它对象不能改变它。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1733386808121-9b9e50e9-6299-45ce-bc16-82621134e69c.png"></p>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a><font style="color:#262626;">组合模式</font></h2><p>将对象形成树形结构来表现整体和部分的层次结构的成熟模式。</p>
<p>类图：</p>
<p>组件(Component)类是组合类(Composite)和叶子类(Leaf)的父类，可以把组合类看成是树的中间节点。组合对象拥有一个或者多个组件对象，因此组合对象的操作可以委托给组件对象去处理，而组件对象可以是另一个组合对象或者叶子对象。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1733386879222-c09192ce-fe52-4ded-9876-995e5a269178.png"></p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a><font style="color:#262626;">观察者模式</font></h2><p>涉及到多个对象都对一个特殊对象中的数据变化感兴趣，而且这多个对象都希望跟踪那个特殊对象中的数据变化。</p>
<p>类图</p>
<p>主题(Subject)具有注册和移除观察者、并通知所有观察者的功能，主题是通过维护一张观察者列表来实现这些操作的。观察者(Observer)的注册功能需要调用主题的 registerObserver() 方法。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1733386947785-144968cb-11ff-4e29-9694-3d56dd9e9b50.png"></p>
<h2 id="工厂"><a href="#工厂" class="headerlink" title="工厂"></a>工厂</h2><h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">    Integer <span class="title function_">cash</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">implements</span> <span class="title class_">Fruit</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">cash</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Banana</span> <span class="keyword">implements</span> <span class="title class_">Fruit</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">cash</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Fruit <span class="title function_">getFruit</span><span class="params">(<span class="type">int</span> type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Banana</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Factory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Factory</span>();</span><br><span class="line">        <span class="type">Fruit</span> <span class="variable">fruit</span> <span class="operator">=</span> factory.getFruit(<span class="number">1</span>);</span><br><span class="line">        <span class="type">Fruit</span> <span class="variable">fruit2</span> <span class="operator">=</span> factory.getFruit(<span class="number">2</span>);</span><br><span class="line">        System.out.println(fruit.cash());</span><br><span class="line">        System.out.println(fruit2.cash());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这个简单工厂不符合太符合开闭原则的，因为工厂实际上是针对于调用方提供的，所以我们应该尽可能对修改关闭。</p>
<h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p><font style="color:rgb(44, 62, 80);">在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由子类来创建对象。</font></p>
<p><font style="color:rgb(55, 65, 81);">定义一个创建对象的接口，但让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1733306031191-5203157f-dfaf-4638-ae03-3109ae6bea95.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> Fruit <span class="title function_">getFruit</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppleFactory</span> <span class="keyword">extends</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Fruit <span class="title function_">getFruit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><p><font style="color:rgb(55, 65, 81);">提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。缺陷在于每添加一个新产品就要在抽象类进行修改，违反了开闭原则</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1733387066308-e76e5a6f-c85c-45c1-a728-cac1f2f9b02a.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractProductA</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractProductB</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductA1</span> <span class="keyword">extends</span> <span class="title class_">AbstractProductA</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductA2</span> <span class="keyword">extends</span> <span class="title class_">AbstractProductA</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductB1</span> <span class="keyword">extends</span> <span class="title class_">AbstractProductB</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductB2</span> <span class="keyword">extends</span> <span class="title class_">AbstractProductB</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> AbstractProductA <span class="title function_">createProductA</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">abstract</span> AbstractProductB <span class="title function_">createProductB</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFactory1</span> <span class="keyword">extends</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    AbstractProductA <span class="title function_">createProductA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductA1</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AbstractProductB <span class="title function_">createProductB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductB1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFactory2</span> <span class="keyword">extends</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    AbstractProductA <span class="title function_">createProductA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductA2</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AbstractProductB <span class="title function_">createProductB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductB2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AbstractFactory</span> <span class="variable">abstractFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteFactory1</span>();</span><br><span class="line">        <span class="type">AbstractProductA</span> <span class="variable">productA</span> <span class="operator">=</span> abstractFactory.createProductA();</span><br><span class="line">        <span class="type">AbstractProductB</span> <span class="variable">productB</span> <span class="operator">=</span> abstractFactory.createProductB();</span><br><span class="line">        <span class="comment">// do something with productA and productB</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><p>单例模式分为两种，一种为饿汉式，一种为懒汉式，</p>
<p>饿汉式采用直接实例化 Singleton 的方式，但这样如果在不使用的情况下会<strong>消耗</strong>资源</p>
<p>懒汉式采用的后面实例化，从而达到<strong>节约</strong>资源，当有多<strong>个线程</strong>访问进去的时候，为了保证获取到的都是同一个 Singleton.class，通过对其进行<strong>上锁</strong>，保证只有<strong>一个线程</strong>可以进去获取实例化，当实例化结束后，<strong>其他线程获取到的都是已经被实例化好的singleton</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1733387212589-110ccdf3-f6c7-4968-8a50-fb812fe5fd60.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">simple</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> simple instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">simple</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> simple <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (simple.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance=  <span class="keyword">new</span> <span class="title class_">simple</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象池模式"><a href="#对象池模式" class="headerlink" title="对象池模式"></a>对象池模式</h2><p>使用一个对象池类专门负责管理这种对象。客户类需要使用对象时，向对象池申请；客户类使用完毕，向对象池归还对象。对象池可以限制对象的数量，让希望获取对象使用的客户类排队等候；对象池也节省了创建对象的时间。</p>
<p>案例：<strong>出租车中心调度程序</strong></p>
<p>内容：出租车中心需要管理出租车，中心需要给想坐出租车的乘客分派空车，使用后出租车回归到对象池。（典型的出租车中心调度应用），通过对象池模式解决。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1733387201003-33bc2738-2bea-45aa-919b-c23ce3ba9a06.png"></p>
<p><strong><font style="color:#262626;">创建型模式总结</font></strong></p>
<ul>
<li><font style="color:rgb(255,0,0);">工厂方法模式：</font>解决在框架代码或者其他地方无法创建具体对象，需要将对象的创建推迟到框架的应用代码或者扩展代码中完成。工厂方法模式因使用工厂方法而得名。叫虚构造器也很贴切。</li>
<li><font style="color:rgb(255,0,0);">抽象工厂模式：</font>解决需要使用的多种产品，在不同的系列中要配套出现和使用的问题。使用一个构造器类创建一个系列的多种产品。增加一个产品系列则添加一个具体构造器类。</li>
<li><font style="color:rgb(255,0,0);">单实例模式：</font>解决在应用中需要确保某个类只有一个实例的问题。确保一个类只有一个实例是为了节省资源或者保证数据的一致性和实现全局的共享。</li>
<li><font style="color:rgb(255,0,0);">对象池模式：</font>解决需要创建的对象比较耗时，同时往往又有数量限制（远程连接数，数据库连接数等）。对象池可以节省对象创建时间，同时也可以很好控制对象的总数。</li>
</ul>
<p><strong><font style="color:#262626;">设计模式总结</font></strong></p>
<p>设计模式一般是为了得到某方面<font style="color:rgb(255,0,0);">灵活性</font>、<font style="color:rgb(255,0,0);">可变性</font>。使用设计模式的效果是想要某方面可以变化而不用重新设计。</p>
<p>依据要达到的变化性目的，可将设计模式分为<font style="color:rgb(255,0,0);">创建型模式</font>、<font style="color:rgb(255,0,0);">结构型模式</font>和<font style="color:rgb(255,0,0);">行为模式</font>。</p>
<p>从使用范围分，设计模式主要用于类就是<font style="color:rgb(255,0,0);">类模式</font>，通过<font style="color:rgb(255,0,0);">继承关系</font>实现，是<font style="color:rgb(255,0,0);">静态</font>的；主要用于对象，就是<font style="color:rgb(255,0,0);">对象模式</font>，通过<font style="color:rgb(255,0,0);">关联实现</font>，是<font style="color:rgb(255,0,0);">动态</font>的。</p>
<p>所学模式中，<font style="color:rgb(0,176,240);">模板方法</font>和<font style="color:rgb(0,176,240);">工厂方法</font>是<font style="color:rgb(255,0,0);">类模式</font>。<font style="color:rgb(0,176,240);">适配器模式</font>可以用<font style="color:rgb(255,0,0);">类继承实现，也可以用关联实现</font>。<font style="color:rgb(0,176,240);">其他所有模式</font>都是<font style="color:rgb(255,0,0);">对象模式</font>。</p>
<p><font style="color:rgb(255,0,0);">适配器：</font>让适用的接口变成可用；</p>
<p><font style="color:rgb(255,0,0);">桥梁：</font>让抽象和对抽象的实现分开，二者可以独立演化；</p>
<p><font style="color:rgb(255,0,0);">装饰：</font>动态地为类添加功能；</p>
<p><font style="color:rgb(255,0,0);">外观：</font>为子系统提供简化的接口；</p>
<p><font style="color:rgb(255,0,0);">组合：</font>对树形结构中的简单类和复合类用统一的方法处理。</p>
<p><font style="color:rgb(255,0,0);">代理：</font>代理对象隐藏了真实对象，实现了真实对象接口。他可以将功能委托给真实对象实现，也可以为真实对象提供附加功能；</p>
<p><font style="color:rgb(255,0,0);">模板方法：</font>在基类中规定算法结构或步骤，子类扩展可变步骤；</p>
<p><font style="color:rgb(255,0,0);">命令：</font>用类封装命令，允许命令的生成和执行分离；</p>
<p><font style="color:rgb(255,0,0);">观察者：</font>允许一个对象将自己状态变化通知给以来于其状态的对象</p>
<p><font style="color:rgb(255,0,0);">策略：</font>对算法进行封装，进而可以替换；</p>
<p><font style="color:rgb(255,0,0);">中介者：</font>允许对象之间通过中介者进行交流，减少同事类的耦合，进而可以独立变化；</p>
<p><font style="color:rgb(255,0,0);">状态：</font>用类封装状态，依赖于状态的对象与状态类相关联并可实现状态的转变；</p>
<p><font style="color:rgb(255,0,0);">角色：</font>允许一个对象动态地改变角色，并可以同时充当多种角色，或由多个对象充当一种角色。采用角色类关联主题类的设计；</p>
<p><font style="color:rgb(255,0,0);">访问者：</font>通过双向依赖实现不同数据结构上不同处理方法的双委派</p>
<p><font style="color:rgb(255,0,0);">迭代器：</font>在客户类不了解数据结构组成方式的情况下，遍历数据结构中的每个元素。</p>
<h1 id="架构模式："><a href="#架构模式：" class="headerlink" title="架构模式："></a><font style="color:#262626;">架构模式：</font></h1><ul>
<li>逻辑架构模式:分层模式，管道与过滤器模式，黑板模式</li>
<li>物理架构模式:C&#x2F;S架构，三层架构，B&#x2F;S架构，面向服务的架构，中介模式，微服务模式等。</li>
<li>扩展模式:插件架构模式</li>
<li>交互模式:MVC模式，表现-抽象-控制模式</li>
</ul>
<h3 id="SOA"><a href="#SOA" class="headerlink" title="SOA"></a>SOA</h3><p><strong><font style="color:#262626;">SOA模式：</font></strong><font style="color:#262626;">松耦合、跨平台、易重用、易扩展</font></p>
<p><strong><font style="color:#262626;">分布式系统架构</font></strong><font style="color:#262626;">：服务提供者、服务使用者和服务目录三种角色构成（cloud alibaba）</font></p>
<p><font style="color:#262626;">优点：</font></p>
<ul>
<li><font style="color:#262626;">服务组件封装了一项业务功能，加强了业务与技术之间的结合。</font></li>
<li><font style="color:#262626;">将系统功能分解成小的服务，实现了模块化</font></li>
<li><font style="color:#262626;">服务基于接口定义，大规模复用方便。</font></li>
<li><font style="color:#262626;">跨平台性。</font></li>
</ul>
<p><font style="color:#262626;">缺点：</font></p>
<ul>
<li><font style="color:#262626;">系统层次结构复杂；</font></li>
<li><font style="color:#262626;">需要使用多种协议，增加了通信开销；</font></li>
<li><font style="color:#262626;">对数据传输速率要求较高；</font></li>
<li><font style="color:#262626;">服务定义基于业务的细分。业务建模影响了架构的成败。</font></li>
</ul>
<h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>**<font style="color:#262626;">MVC模式：</font>**将图形界面程序分成模型、视图、控制器三个模块。数据及数据处理由模型负责；视图用于显示数据；对用户输入的处理业务逻辑由控制器处理。三者实现了关注点分离。</p>
<ul>
<li><strong><font style="color:#262626;">模型(model)</font></strong><font style="color:#262626;">：由领域类构成。领域类封装(表示)了存储在数据库或文件中的应用数据及相关处理逻辑；</font></li>
<li><strong><font style="color:#262626;">视图(view)：</font></strong><font style="color:#262626;">呈现模型数据的界面。当模型变化时，视图会跟着变；相同的模型状态可以有多个视图。</font></li>
<li><strong><font style="color:#262626;">控制器(controller)：</font></strong><font style="color:#262626;">负责接受用户的输入，将输入进行解析并反馈给模型，通常一个视图具有一个控制器。</font></li>
</ul>
<p><font style="color:#262626;">优点：</font></p>
<p><font style="color:#262626;">一个模型可以有多个视图。</font></p>
<p><font style="color:#262626;">模型可复用。</font></p>
<p><font style="color:#262626;">可提高开发效率和质量。</font></p>
<h1 id="图类-1"><a href="#图类-1" class="headerlink" title="图类"></a>图类</h1><p><font style="color:rgb(255,0,0);">静态模型：</font>类图、对象图、组件图、部署图、包图</p>
<h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a><font style="color:#262626;">类图</font></h3><p><font style="color:#262626;">类图：用来描述系统中各种类之间的静态结构。</font></p>
<p><font style="color:#262626;">类之间的关系：关联、依赖、继承实现等</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1733386245099-2d944336-f4af-4a0b-93f8-42cd61f6b0ca.png"></p>
<h3 id="对象图"><a href="#对象图" class="headerlink" title="对象图"></a><font style="color:rgb(77, 77, 77);">对象图</font></h3><p><font style="color:rgb(77, 77, 77);">和类图一样反映系统的静态过程，但它是从实际的或原型化的情景来表达的。对象图显示某时刻对象和对象之间的关系。一个UML对象图可看成一个类图的特殊用例，实例和类可在其中显示。</font><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1733386423826-95c68ff7-6709-45a6-a176-b915bc759095.png"></p>
<h3 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h3><p><font style="color:rgb(77, 77, 77);">用例图是从用户（角色）的角度出发，描述角色和用例之间的关系。即：谁要使用系统，一级他们使用系统可以做什么。简单来说就是：谁，可以用此系统做什么。</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1733386365342-966cab99-c159-4ab0-9b08-f53890f82f7f.png"></p>
<h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a><font style="color:#262626;">时序图</font></h3><p><font style="color:rgb(77, 77, 77);">序列图是用来显示你的参与者如何以一系列顺序的步骤与系统的对象交互的模型。顺序图可以用来展示对象之间是如何进行交互的。序列图将显示的重点放在消息序列上，即强调消息是如何在对象之间被发送和接收的。</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1733386331511-28d9d2fb-afcf-4b17-81ba-404567f37bd5.png"></p>
<h3 id="活动图"><a href="#活动图" class="headerlink" title="活动图"></a><strong><font style="color:rgb(77, 77, 77);">活动图</font></strong></h3><p><font style="color:rgb(77, 77, 77);">活动图描述用例要求所要进行的活动，以及活动间的约束关系，有利于识别并行活动。能够演示出系统中哪些地方存在功能，以及这些功能和系统中其他组件的功能如何共同满足前面使用用例图的业务需求。</font></p>
<h3 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1733386456482-80431c24-7967-4298-bcdd-246217e742b9.png"></h3>]]></content>
  </entry>
  <entry>
    <title>面试总结</title>
    <url>/2024/06/17/%E9%9D%A2%E7%BB%8F%E9%AB%98%E9%A2%91%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>介绍一下你的XX项目？</p>
<h3 id="介绍是什么？"><a href="#介绍是什么？" class="headerlink" title="介绍是什么？"></a>介绍是什么？</h3><ul>
<li>青轻论坛是一个实现大学生交流平台，实现<strong>用户发帖交流评论</strong>，实现了<strong>富文本发帖、回帖以及楼中楼回复</strong>、<strong>点赞收藏</strong>、<strong>消息通知</strong>等功能</li>
<li>服务器监控运维系统是一个实时在线监控服务器运行状态以及详细信息的网站，能够做到<strong>服务器状态和信息监控</strong>、<strong>一键SSH远程登录</strong>、<strong>子用户分配具体服务器</strong>等操作</li>
<li>小马链接方便大学生分享网页提供便利简洁性，实现了跳转链接，链接数据记录，分组管理，链接修改灯功能</li>
</ul>
<h3 id="介绍主体功能？"><a href="#介绍主体功能？" class="headerlink" title="介绍主体功能？"></a>介绍主体功能？</h3><h4 id="社区"><a href="#社区" class="headerlink" title="社区"></a>社区</h4><ul>
<li>进入系统前的<strong>注册 &#x2F; 登录</strong>功能（JWT &#x2F; rabbitmq发验证码 &#x2F; redis存验证码）</li>
<li>最主要的<strong>帖子相关功能</strong>：富文本发帖 &#x2F; 评论帖子 &#x2F; 楼中楼回复 &#x2F; 收藏点赞帖子 &#x2F; 隐私展示 &#x2F; 评论提醒</li>
<li>工具类 接口限流的<strong>基于Redis的固定窗口计数器限流</strong></li>
</ul>
<h4 id="小马链接"><a href="#小马链接" class="headerlink" title="小马链接"></a>小马链接</h4><ul>
<li>最主要是链接功能：跳转链接&#x2F;修改链接&#x2F;添加链接&#x2F;链接监控记录</li>
<li>确认消费工具类：<strong>保证消息队列消费确认</strong></li>
</ul>
<h4 id="服务器监控运维系统"><a href="#服务器监控运维系统" class="headerlink" title="服务器监控运维系统"></a>服务器监控运维系统</h4><ul>
<li>介绍三个模块：<strong>服务端、客户端、网页端</strong></li>
<li>服务端：生成token展示在网页端，接收来自客户端的数据并发给网页端展示（并用influxdb存储起来）</li>
<li>客户端：安装在被监控主机上，携带token向服务端注册后定时自动进行数据收集并上报</li>
<li>网页端：展示实时最新数据以及历史一小时的折线图数据等等，并且可以进行SSH连接客户端</li>
<li>另外：管理员可以在网页端进行子用户创建并为其分配可操作的服务器</li>
</ul>
<h4 id="青轻小镇"><a href="#青轻小镇" class="headerlink" title="青轻小镇"></a>青轻小镇</h4><ul>
<li>优惠券抢购 </li>
<li>点赞关注功能</li>
</ul>
<h3 id="🌟项目有什么难点？"><a href="#🌟项目有什么难点？" class="headerlink" title="🌟项目有什么难点？"></a>🌟项目有什么难点？</h3><h4 id="社区内容（点赞和收藏）的数据存储问题"><a href="#社区内容（点赞和收藏）的数据存储问题" class="headerlink" title="社区内容（点赞和收藏）的数据存储问题"></a>社区内容（点赞和收藏）的数据存储问题</h4><blockquote>
<p>由于社区交互数据(如点赞、收藏等) 的更新会非常频繁，更新信息实时到MySQL不太现实，所以需要用Redis做缓冲并在合适的时机一次性入库一段时间内的全部数据</p>
<p>核心点：<strong>线程池</strong>、<strong>Redis 哈希结构</strong>、<strong>定时任务</strong>、<strong>同步锁</strong>、<strong>数据同步 &#x2F; 一致性</strong></p>
</blockquote>
<ul>
<li><strong>获取</strong>交互信息：从Redis中获取交互信息，如果Redis中没有则从MySQL中获取</li>
<li><strong>更新</strong>交互信息：<strong>加锁</strong>写入Redis，并且开启定时的入库任务（如果已经开启了，那么仅更新Redis不开启新的）</li>
<li><strong>存储</strong>交互信息：采用Redis的Hash，key为<code>交互的类型(点赞/收藏)</code>，hashkey为<code>用户ID+交互帖子ID</code>，hashvalue即为<code>交互的目标状态(false/true)</code>，并使用线程池往Redis中写入数据</li>
<li><strong>同步</strong>交互信息（<strong>入库</strong>）：设定每3s进行一次Redis中的数据同步到MySQL（同样需要<strong>加锁</strong>写入），<strong>入库后清除</strong>相关交互信息的缓存</li>
<li>🌟🌟🌟为什么<strong>更新Redis</strong>和<strong>入库MySQL</strong>需要<strong>加锁</strong>？</li>
</ul>
<blockquote>
<p>这里加锁加的是<code>synchronized(type.intern())</code>type是交互类型（点赞&#x2F;收藏）</p>
</blockquote>
<p>为了防止发生：入库MySQL的同时来了新的交互数据更新，此时会发生丢失这段新的数据因此需要加锁来让入库的时候，新的交互数据等待入库完毕再写入Redis</p>
<ul>
<li>🌟如何保障Redis和MySQL的<strong>数据一致性</strong>？<ul>
<li>仅从redsi中获取数据，只有不存在的时候才去mysql中取</li>
<li>入库和更新不会同时进行（加锁）、入库后删除所有交互数据</li>
</ul>
</li>
</ul>
<h4 id="接口限流问题"><a href="#接口限流问题" class="headerlink" title="接口限流问题"></a>接口限流问题</h4><p>先介绍主流的几种限流方式：</p>
<ul>
<li><strong>固定窗口计数器</strong>，优点是实现简单、易于理解和部署，缺点是可能存在时间不对称以及难以应对突发流量</li>
<li><strong>滑动窗口计数器</strong>，优点是能更好应对突发流量，缺点是实现复杂、需要维护窗口的状态</li>
<li><strong>令牌桶算法</strong>，优点是能够很好地平滑流量，允许一定程度的突发流量，缺点是需要更多资源来维护令牌桶状态、不能处理长时间的突发流量</li>
<li><strong>漏桶算法</strong>，优点是可以按照恒定的速率限制请求且算法相对简单，缺点是不够灵活、无法应对突发流量、可能导致请求延迟</li>
</ul>
<p>再说（我采用的是<strong>固定窗口计数器限流</strong>）</p>
<ul>
<li>加了一个继承自HttpFilter的限流过滤器在CORS过滤器之后</li>
<li>采用filrer对来自同个IP的请求计数（每次请求前加HTTP过滤器）</li>
<li>限流工具类的Redis的key是ip地址，value是访问次数</li>
<li>编写了多个逻辑的方法以供不同目的的限流，如<ul>
<li>针对单次频率限制，请求成功后一段时间不得再发起请求（如点击请求邮件或者手机验证码）</li>
<li>针对一段时间内多次请求的频率限制（如3秒内最多允许20次请求，例如论坛的评论）</li>
<li>针对于需要采取阶段封禁的频率限制（如防止用户频繁申请JWT令牌，如果已经提示无法登录而用户还在请求，那么就封禁更长时间）</li>
</ul>
</li>
</ul>
<h4 id="Feed流推拉结合问题"><a href="#Feed流推拉结合问题" class="headerlink" title="Feed流推拉结合问题"></a>Feed流推拉结合问题</h4><p>Feed 指的是根据用户与用户之间的关注关系来召回Feed，然后基于发布时间排序的简单信息流系统。</p>
<p>发表帖子</p>
<ul>
<li>当用户发表一篇帖子时，将帖子写入到topic表，</li>
<li>然后调用follow表获取粉丝id</li>
<li>异步将内容写入到每个粉丝的inbox列表，并以时间排序</li>
<li>我用inbox表存储uid，fid，tid。uid表示关注的大Vid，fid表示用户id</li>
</ul>
<p>读取帖子</p>
<ul>
<li>用户获取feed列表，根据自身id匹配inbox列表中的uid读出所有feed</li>
</ul>
<p>推拉结合</p>
<ol>
<li>发布帖子时，如果是大V则仅写入到自身的发件箱中，uid和fid一致</li>
<li>发布帖子时，如果是普通用户，则进行写放大的推模式，uid为自己，fid为粉丝</li>
<li>读取Feed时，读取关注列表，从中识别出哪些是大V用户，并行的读取自身的收件箱，然后读取其他大V的收件箱，拿到topic list后进行合并，返回最新的feed数据。</li>
</ol>
<h4 id="关注Feed流顺序消息"><a href="#关注Feed流顺序消息" class="headerlink" title="关注Feed流顺序消息"></a>关注Feed流顺序消息</h4><p>因为关注需要添加近7天的feed进用户的inbox当中，如果不保证顺序消息很可能导致数据库报错问题，</p>
<ol>
<li>传统 &#x2F; 简单 做法：单一消费者，缺点是并发度较高的时候效率很低</li>
</ol>
<blockquote>
<p>顺序消费和多线程本身就矛盾，多线程意义就是不在乎顺序、所以才多线程，现在既要顺序又要多线程</p>
</blockquote>
<ol start="2">
<li>解决办法：将需要保证顺序的消息放在一块，进行分组然后由单一的消费者消费相当于给单独需要保证顺序的消息加标识，放在单独的queue里由单一消费者消费，其余queue正常多线程消费</li>
<li>我采用的是生产者发送消息，给每个消息指定一个特定路由键，mq会根据路由键将消息发送到不同的Exchange中，消费者通过绑定指定的队列和路由键来接受消息。</li>
</ol>
<p>- </p>
<h1 id="🌟项目八股"><a href="#🌟项目八股" class="headerlink" title="🌟项目八股"></a>🌟项目八股</h1><h2 id="🌟社区"><a href="#🌟社区" class="headerlink" title="🌟社区"></a>🌟社区</h2><h3 id="springboot3，相比2有什么不同？"><a href="#springboot3，相比2有什么不同？" class="headerlink" title="springboot3，相比2有什么不同？"></a>springboot3，相比2有什么不同？</h3><ol>
<li><strong>最低Java环境</strong>。SpringBoot3使用Java17作为最低版本，且基于Spring6，而spring boot2最低版本是Java8且基于Spring5</li>
<li><strong>GraalVM支持</strong>。相比 SpringBoot2，SpringBoot3 的 Spring Native 也是升级的一个重大特性，支持使用 GraalVM 将 Spring 的应用程序编译成本地可执行的镜像文件，提升启动速度、峰值性能以及减少内存使用</li>
</ol>
<h3 id="Java8-17有什么新特性？"><a href="#Java8-17有什么新特性？" class="headerlink" title="Java8-17有什么新特性？"></a>Java8-17有什么新特性？</h3><h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><blockquote>
<p>匿名内部类，当且仅当接口内部仅有一个抽象方法（可以有多个，但是其他方法必须有默认实现）</p>
<p>写成 <code>() -&gt; &#123;&#125;</code></p>
</blockquote>
<h4 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h4><blockquote>
<p>更“优雅”地处理<strong>空指针问题</strong>，使用Optional类可以<strong>避免显式的null值判断</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span>(str != <span class="literal">null</span>)&#123;   <span class="comment">//不使用optional</span></span><br><span class="line">    list.add(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Optional</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">Optional&lt;String&gt; optional = Optional.ofNullable(str);   <span class="comment">//转换为Optional</span></span><br><span class="line">optional.ifPresent(System.out::println);  			   <span class="comment">//str非空时再执行方法</span></span><br></pre></td></tr></table></figure>

<h4 id="文本块"><a href="#文本块" class="headerlink" title="文本块"></a>文本块</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            你好</span></span><br><span class="line"><span class="string">            nihao</span></span><br><span class="line"><span class="string">            hallo</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">// 可以更好的书写HTML或者SQL语句了，无需写很多转义字符  </span></span><br></pre></td></tr></table></figure>

<h4 id="记录类型record"><a href="#记录类型record" class="headerlink" title="记录类型record"></a>记录类型record</h4><blockquote>
<p>相当于是官方出版的翻版“lombok”</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">Account</span><span class="params">(String username, String password)</span> &#123;	<span class="comment">// 字段直接写在括号里</span></span><br><span class="line">    <span class="comment">// 帮我们像lombok一样写好了 全参构造方法 getter hashcode equals toString等方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="密封类型sealed"><a href="#密封类型sealed" class="headerlink" title="密封类型sealed"></a>密封类型sealed</h4><blockquote>
<p>“人如其名”，就是密封了一个类，显式写明只有某些类可以继承这个密封类，其他类都不可以继承</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">permits</span> B&#123;   </span><br><span class="line">    <span class="comment">// 在class关键字前添加sealed关键字，表示此类为密封类型</span></span><br><span class="line">    <span class="comment">// permits后面跟上允许继承的类型，多个子类使用逗号隔开</span></span><br><span class="line">    <span class="comment">// 表明只有类B可以继承类A，并且必须有类继承A</span></span><br><span class="line">    <span class="comment">// 继承的子类必须显式标记为final、sealed或是non-sealed类型(非密封类，代表可以继承了)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="🌟介绍一下-JWT？和session比起来有什么优劣？"><a href="#🌟介绍一下-JWT？和session比起来有什么优劣？" class="headerlink" title="🌟介绍一下 JWT？和session比起来有什么优劣？"></a>🌟介绍一下 JWT？和session比起来有什么优劣？</h3><p>jwt（json web token）由三部分<strong>组成</strong>：</p>
<ul>
<li>标头(header)：包含一些元数据  例如JWT使用的加密算法 &#x2F; 类型</li>
<li>有效载荷(payload)：包括用户名称、令牌发布时间 &#x2F; 过期时间、JWT ID等，自定义的字段也存在这里</li>
<li>签名(signature)：根据服务端的密钥，再按照标头中指定的算法对标头和载荷加密后再进行base64编码得到（用于验证此token是否被篡改过）</li>
</ul>
<p>jwt的<strong>优点</strong>：</p>
<ul>
<li><strong>可扩展性好</strong>，分布式部署的情况下，session需要做多机数据共享，通常存在数据库或者redis，而jwt不需要</li>
<li><strong>无状态</strong>，jwt不在服务端存储任何状态，且jwt的载荷中可以存储一些常用的用户信息用于交换，有效使用jwt还可以降低服务器查询数据库的次数</li>
<li>安全性: JWT使用数字签名或加密算法保证token的完整性和安全性。每次请求都会验证token的合法性，防止伪造或篡改。</li>
</ul>
<p>jwt的<strong>缺点</strong>：</p>
<ul>
<li><strong>性能问题</strong>：由于是无状态使用jwt，所有的数据都放在jwt中，如果还有自定义字段，载荷会更大，cookie很可能放不下，所以一般都放在local storage里面，并且用户每一次http请求都需要在header里携带jwt，因此使用jwt请求比使用session的开销大</li>
<li><strong>无法即时失效</strong>：一旦签发一个jwt，到期之前始终有效，无法中途废弃。用户注销时或者jwt载荷里的用户信息需要更新时，签发了新的jwt，但旧的jwt还没过期，依然可以登录或者服务端拿到的载荷信息是过时的（为了解决这个问题，我的项目在后端编写了额外的逻辑，<strong>黑名单机制</strong>：一旦签发了新的jwt，就把旧的加入黑名单(比如存到redis里面)，避免被非法再次使用）</li>
<li><strong>续签麻烦</strong>：传统的cookie续签方案一般是框架自带，但jwt到期就需要签发新的jwt，因此需要前端需要配置JWT自动续签，在发起请求时如果令牌即将到期，那么就向后端发起续签请求得到一个新的JWT令牌</li>
</ul>
<h3 id="如果要统计一天之内论坛登录过的人数怎么做？"><a href="#如果要统计一天之内论坛登录过的人数怎么做？" class="headerlink" title="如果要统计一天之内论坛登录过的人数怎么做？"></a>如果要统计一天之内论坛登录过的人数怎么做？</h3><p>答：基于<strong>Redis</strong>或者<strong>数据库</strong> 存储登录过的用户ID</p>
<ul>
<li>基于Redis<ul>
<li><strong>BitSet</strong>（位集合，精准 但是占用空间更大） <code>setbit</code> 添加用户  <code>bitcount</code>统计用户</li>
<li><strong>HyperLogLog</strong>（更适合，但是有一些误差）<code>pfadd</code>添加  <code>pfcount</code>统计</li>
</ul>
</li>
<li>数据库简单存储一张表 每天定时清空再存新的即可</li>
</ul>
<h3 id="“楼中楼”评论是如何做的？"><a href="#“楼中楼”评论是如何做的？" class="headerlink" title="“楼中楼”评论是如何做的？"></a>“楼中楼”评论是如何做的？</h3><p>答：<strong>数据库中额外的引用字段</strong></p>
<ul>
<li>数据库comment表中有一个quote字段和root字段，如果是一级评论（也就是直接评论帖子）则quote，root字段值均为-1（无效值）</li>
<li>如果是评论的评论，那么子评论的quote字段的值为父评论的ID，root字段值为根评论的ID</li>
</ul>
<h3 id="delta是什么存储格式-？为什么用它？"><a href="#delta是什么存储格式-？为什么用它？" class="headerlink" title="delta是什么存储格式 ？为什么用它？"></a>delta是什么存储格式 ？为什么用它？</h3><ul>
<li>delta是quill（强大的开源富文本编辑器）存储文本内容及其样式的一种数据格式，本质上是一种JSON</li>
<li>delta相比html没有歧义和复杂（没有html的各种标签），缺点是前端从数据库中拿到帖子内容后需要解析</li>
<li>XSS，跨站脚本攻击（Cross-Site Scripting）（简称与css重合 因此叫xss）简单来说就是：想办法“教唆”用户的浏览器去执行一些这个网站中不存在的JS代码</li>
<li>delta可以降低xss攻击的风险，就是因为无法直接在前端页面中展示，需要经过额外处理，处理时可以筛掉非法的标签例如<code>&lt;srcipt&gt;</code>等</li>
</ul>
<h3 id="🌟为什么要用RabbitMQ？"><a href="#🌟为什么要用RabbitMQ？" class="headerlink" title="🌟为什么要用RabbitMQ？"></a>🌟为什么要用RabbitMQ？</h3><ul>
<li>🌟🌟🌟任何相关MQ的问题，优先答<strong>MQ的三大作用：异步、解耦、削峰</strong><ul>
<li><strong>异步</strong>，将消息写入消息队列，非必要的业务逻辑以异步的方式运行，不影响主流程业务。</li>
<li><strong>削峰填谷</strong>，当系统压力较大时，消息可以缓存起来逐渐处理，从而避免系统崩溃或过载</li>
<li><strong>解耦</strong>，当一个系统较为复杂，可以降低它的耦合度，提高他的扩展性。</li>
</ul>
</li>
<li><strong>相比多线程</strong><ul>
<li><strong>消息持久化</strong>，提高了系统的稳定性，系统down了，但消息存储在外部，不会丢失</li>
<li><strong>削峰填谷</strong>，当系统压力较大时，消息可以缓存起来逐渐处理，从而避免系统崩溃或过载</li>
<li><strong>解耦</strong>，当一个系统较为复杂，可以降低它的耦合度，提高他的扩展性。</li>
</ul>
</li>
<li><strong>对比其他主流消息队列</strong><ul>
<li><strong>简单易用</strong>：RabbitMQ 提供了简单易用的API，易于上手和部署</li>
<li><strong>灵活的路由和交换机机制</strong>：可以根据消息的特性和路由规则进行高效的消息分发</li>
<li><strong>自带的管理界面简单方便，社区活跃度高（文档齐全丰富）</strong></li>
<li><strong>缺点</strong>：用erlang开发，难以进行二次开发和维护，吞吐量相比rocketmq&#x2F;kafka低</li>
</ul>
</li>
</ul>
<h3 id="延时任务怎么实现的"><a href="#延时任务怎么实现的" class="headerlink" title="延时任务怎么实现的"></a>延时任务怎么实现的</h3><ul>
<li>我利用一个普通队列和一个死信队列，普通队列绑定死信交换机和死信路由key，设置ttl过期时间，在到达时间后，消息会根据死信交换机传送到相应绑定的队列进行消费。但是这个有所限制，这个ttl过期时间是固定的，无法修改，但可以用作订单超时自动取消。</li>
<li>优惠券则是通过coverAndSend的时候通过messageProperties的setExpiration过期时间来实现的</li>
</ul>
<h3 id="为什么选用MinIO存储图片？"><a href="#为什么选用MinIO存储图片？" class="headerlink" title="为什么选用MinIO存储图片？"></a>为什么选用MinIO存储图片？</h3><ul>
<li>MinIO是一个开源免费的<strong>对象存储</strong>服务器，核心功能是对象存储，并提供了多种API和SDK访问这些对象</li>
<li>参考官方文档就可以使用Minio官方提供的Java SDK进行操作，进行文件的存储</li>
<li>如何对接MySQL？<ul>
<li>MySQL中有一张表，表中存储上传图片的用户ID，和图片的存储路径、存储时间等</li>
<li>往MinIO里存储图片的同时，往表中插入数据，以便管理员端可以按需依靠索引快速访问图片数据</li>
</ul>
</li>
<li>🌟🌟🌟为什么不用MySQL直接存储图片？而非要用Minio？<ul>
<li>存储图片（或者任何大型二进制数据）时，使用MySQL直接存储会遇到以下挑战和限制：<ul>
<li><strong>性能不佳</strong>：由于图片等二进制数据体积较大，MySQL对于大型二进制数据的存储和检索性能不佳</li>
<li><strong>难以水平扩展</strong>：随着数据量增加，难以水平扩展</li>
<li><strong>难以备份和恢复</strong>：备份和恢复非常耗时，且需要大量存储空间</li>
</ul>
</li>
<li>相比来说，使用对象存储服务（如MinIO）存储图片等大型二进制数据，有以下优势：<ul>
<li>上面三条相反，性能好，可扩展，备份和恢复</li>
<li><strong>数据管理</strong>：对象存储服务通常提供了丰富的管理功能，如数据版本控制、访问控制、生命周期管理等，可以帮助用户更好地管理和保护数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="日志-雪花算法"><a href="#日志-雪花算法" class="headerlink" title="日志 雪花算法"></a>日志 雪花算法</h3><ul>
<li>雪花算法是一种分布式 ID 生成方案，它可以生成一个长度为 <strong>64 位的唯一ID</strong>，其中包含了<strong>时间戳</strong>、<strong>数据中心 ID</strong> 和<strong>机器 ID</strong> 等信息</li>
<li>编写请求日志过滤器，在每个HTTP请求之前，获取请求的接口URL、参数、远程IP地址、用户角色、ID等</li>
</ul>
<h3 id="过滤器和拦截器的区别"><a href="#过滤器和拦截器的区别" class="headerlink" title="过滤器和拦截器的区别"></a>过滤器和拦截器的区别</h3><ol>
<li>出身不同：过滤器来自于 Servlet，而拦截器来自于 Spring 框架</li>
<li>触发时机不同：<strong>请求进入容器 &gt; 进入过滤器 &gt; 进入 Servlet &gt; 进入拦截器 &gt; 执行控制器（Controller）</strong></li>
<li>实现不同：<strong>过滤器是基于方法回调实现的</strong>，<strong>拦截器是基于动态代理（底层是反射）实现的</strong>。</li>
<li>支持的项目类型不同：过滤器是 Servlet 规范中定义的，所以<strong>过滤器要依赖 Servlet 容器，它只能用在 Web 项目中</strong>；而<strong>拦截器是 Spring 中的一个组件，因此拦截器既可以用在 Web 项目中，同时还可以用在 Application 或 Swing 程序中</strong>。</li>
<li>使用的场景不同：因为拦截器更接近业务系统，所以<strong>拦截器主要用来实现项目中的业务判断的</strong>，比如：登录判断、权限判断、日志记录等业务。 而<strong>过滤器通常是用来实现通用功能过滤的</strong>，比如：敏感词过滤、字符集编码设置、响应数据压缩等功能。</li>
</ol>
<h2 id="小马链接-1"><a href="#小马链接-1" class="headerlink" title="小马链接"></a>小马链接</h2><h3 id="双重判定锁怎么实现的？"><a href="#双重判定锁怎么实现的？" class="headerlink" title="双重判定锁怎么实现的？"></a>双重判定锁怎么实现的？</h3><p>这是跳转短连接的功能，首先使用布隆过滤器对当前短链接进行判断是否存储，如果没有则直接跳转空页面，有的话再进行一次判断，从redis获取该短链接是否为空，如果是的话也跳转空页面，不是的话对短链接进行上锁，在进行redis判断，如果还是没有则进行跳转短连接操作，通过这个锁可以优化更新后或者失效场景查询数据库问题。因为短链接失效后布隆过滤器仍然存储该短链接需要利用redis进行判空处理，而如果布隆过滤器都没有的话则说明当前短链接肯定不存在直接跳转即可</p>
<h3 id="介绍一下布隆过滤器，怎么使用的？"><a href="#介绍一下布隆过滤器，怎么使用的？" class="headerlink" title="介绍一下布隆过滤器，怎么使用的？"></a>介绍一下布隆过滤器，怎么使用的？</h3><p>布隆过滤器是一种数据结构，用于快速判断一个元素是否存在一个集合中，它牺牲一定的准确性为代价，换取了存储空间的极大节省和查询速度的显著提升。在当前项目中我初始化了一个可以存储1百万个元素的布隆过滤器，误码率在0.001，太高的误码率肯呢个会导致性能的缺失，因此我选择了这个，<br>在创建链接的同时判断布隆过滤器是否存在这个短连接，存在则抛出异常，否则的话，布隆过滤器添加该短连接。</p>
<h3 id="先更新数据库后删除缓存，怎么保证缓存与数据库的一致性呢？"><a href="#先更新数据库后删除缓存，怎么保证缓存与数据库的一致性呢？" class="headerlink" title="先更新数据库后删除缓存，怎么保证缓存与数据库的一致性呢？"></a>先更新数据库后删除缓存，怎么保证缓存与数据库的一致性呢？</h3><p>在更新短连接的时候，我通过上锁和Transactional注解保证只有一个线程访问，我需要修改分组中的短链接数据，并且把goto表中原数据进行删除，添加新数据进去，否则可能导致访问错误短连接，然后按照时间判断，删除原来的短连接缓存，那下次访问的时候则会生成一个新的缓存跳转短连接，而不是读取旧的缓存。从而保证数据库与缓存的一致性</p>
<h3 id="RabbitMq怎么进行削峰？"><a href="#RabbitMq怎么进行削峰？" class="headerlink" title="RabbitMq怎么进行削峰？"></a>RabbitMq怎么进行削峰？</h3><p>因为每次点击短链接跳转的时候会记录很多数据，例如手机型号，ip地址，访问次数，浏览器类型等等数据，这样的话需要添加数据进多个表里面，在高访问场景下对数据库的压力比较大，因此将数据添加操作转移到消息队列中，进行实现削峰</p>
<h3 id="Redis怎么实现消息队列幂特性"><a href="#Redis怎么实现消息队列幂特性" class="headerlink" title="Redis怎么实现消息队列幂特性"></a>Redis怎么实现消息队列幂特性</h3><p>我实现了一个工具类，生产者发送数据时设置一个uuid，消费的时候首先从当前数据获取uuid，利用双重判断，先判断redis中是否存在该uuid，没有则设置该uuid为0，继续进行，如果存在，则继续判断该uuid是否被消费，消费了直接返回，如果消费过程中出现错误则抛出异常删除key，最后处理结束设置key为1并且带有过期时间，保证消息不被重复消费</p>
<h3 id="跳转短链接功能怎么实现的"><a href="#跳转短链接功能怎么实现的" class="headerlink" title="跳转短链接功能怎么实现的"></a>跳转短链接功能怎么实现的</h3><p>前端传来的参数是shortUri就是一个随机数，通过封装获取得到完整短链接，通过redis获取该短链接是否近期访问，然后统计数据跳转页面，利用双重判定锁保证数据可靠，如果gotolink不存在则进行上锁，再次进行redis判断，然后获取数据库goto表，就是完整短链接，如果没有则判空，存redis空，再查询link表，获取短链接实体类，根据日期判断，是否访问，监控短链接访问数据，跳转，设置redis</p>
<h2 id="服务器监控运维系统-1"><a href="#服务器监控运维系统-1" class="headerlink" title="服务器监控运维系统"></a>服务器监控运维系统</h2><h3 id="客户端用于定时任务调度的SpringQuartz是什么？怎么用的？"><a href="#客户端用于定时任务调度的SpringQuartz是什么？怎么用的？" class="headerlink" title="客户端用于定时任务调度的SpringQuartz是什么？怎么用的？"></a>客户端用于定时任务调度的SpringQuartz是什么？怎么用的？</h3><ul>
<li>是基于Spring的一个功能强大、开源的<strong>任务调度框架</strong>，核心要素主要为：<ul>
<li>Job：定时任务的主体，也是写业务逻辑的地方，如，我们在这里写收集客户端的运行信息</li>
<li>JobDetail：任务的详细信息，包含了任务的标识ID、任务描述、任务存储方式等等</li>
<li>Trigger：触发器，用来定义任务的执行规则，如几点执行，几点结束，多长时间执行一次等等</li>
<li>Scheduler：用来调度任务的，一个Scheduler就是一个调度容器，可以调度多个JobDetail和Trigger</li>
</ul>
</li>
<li>在项目中，我主要使用SpringQuartz实现客户端每十秒钟向服务端报告自身信息</li>
</ul>
<h3 id="客户端的oshi框架是什么？都采集了什么信息？"><a href="#客户端的oshi框架是什么？都采集了什么信息？" class="headerlink" title="客户端的oshi框架是什么？都采集了什么信息？"></a>客户端的oshi框架是什么？都采集了什么信息？</h3><ul>
<li>Oshi 框架是一个用于<strong>获取系统信息</strong>的 Java 库</li>
<li>它允许开发人员查询和获取有关计算机硬件和操作系统的各种信息，它<strong>和Java自带的包</strong>相比起来，可以获取<strong>更丰富的信息</strong>，且具有<strong>跨平台性</strong>，并且使用<strong>简单</strong></li>
<li>我利用Oshi框架获取了客户端的<strong>操作系统名称和架构以及版本</strong>、<strong>CPU名称和核心数</strong>（以及<strong>CPU使用率</strong>）、<strong>内存大小</strong>（包括已用）、<strong>硬盘大小</strong>（包括已用）、<strong>IP地址</strong>，以及<strong>网络的上传 &#x2F; 下载速度</strong>，<strong>磁盘读写速度</strong>等</li>
</ul>
<h3 id="怎么实现的前端shell操作？简要介绍一下websocket？"><a href="#怎么实现的前端shell操作？简要介绍一下websocket？" class="headerlink" title="怎么实现的前端shell操作？简要介绍一下websocket？"></a>怎么实现的前端shell操作？简要介绍一下websocket？</h3><ul>
<li>采用<strong>Xterm.js</strong>作为前端伪终端实现，然后基于websocket连接实现前端shell操作</li>
<li>🌟<strong>WebSocket</strong> 是一种在单个 TCP 连接上进行全双工通信的协议，它是<strong>应用层</strong>协议<ul>
<li><strong>全双工通信</strong>：客户端和服务器之间可以同时发送和接收数据，实现真正的双向通信</li>
<li><strong>低延迟</strong>： 使用单个 TCP 连接，减少了建立连接和发送数据的延迟，实现更快的数据传输速度</li>
<li><strong>持久连接</strong>：WebSocket 连接是持久性的，与 HTTP 连接不同，它不需要在每次通信时重新建立连接，可以在连接保持的情况下连续发送数据</li>
<li><strong>与HTTP兼容</strong>：WebSocket 握手过程与 HTTP 兼容，可以通过标准的 HTTP 端口（通常是 80 和 443）进行通信，并且可以在现有的基础设施上轻松部署</li>
</ul>
</li>
<li>与WebSocket不同，<strong>Socket套接字</strong>，是位于<strong>应用层和传输层</strong>之间的一组<strong>接口</strong>，它是为了方便使用TCP&#x2F;UDP而抽象出来的，相当于使用了设计模式中的<strong>外观模式</strong>把复杂的TCP&#x2F;IP协议族隐藏，用它即可</li>
<li>总的来说，<strong>WebSocket 是一种高层次的协议，专门用于实时通信的 Web 应用程序</strong>，而 <strong>Socket 则是一种通用的底层网络通信接口，可以用于各种网络通信场景</strong>。WebSocket 可以看作是在 Socket 的基础上实现的一种高层次的应用层协议</li>
</ul>
<h3 id="为什么有mysql还要用influxdb存储信息？"><a href="#为什么有mysql还要用influxdb存储信息？" class="headerlink" title="为什么有mysql还要用influxdb存储信息？"></a>为什么有mysql还要用influxdb存储信息？</h3><ul>
<li><strong>场景适合</strong>：InfluxDB 是一种专门用于存储和处理时序数据的数据库，非常适合这种物联网存储历史信息场景</li>
<li><strong>特殊优化</strong>：它针对时间序列数据进行了优化，提供了高效的存储和查询方式，对于需要处理大量时间序列数据的场景比MySQL更合适</li>
<li><strong>按ID以及字段存取方便</strong>：相比MySQL关系型数据库采取表格存储，它使用标签(tag)和字段(field)来存储数据，这种存储方式适合存储大量根据时间且需要根据不同主键的数据，在我的项目中，标签即可代表服务器ID、字段代表每台服务器不同类型的信息</li>
</ul>
<h3 id="你的管理员用户-子用户-权限校验是怎么做的？"><a href="#你的管理员用户-子用户-权限校验是怎么做的？" class="headerlink" title="你的管理员用户 子用户 权限校验是怎么做的？"></a>你的管理员用户 子用户 权限校验是怎么做的？</h3><ul>
<li>在SecurityConfig中配置，任何操作子用户的接口都需要admin角色</li>
<li>并且，在数据库的用户表中加入角色和可操作的服务器列表</li>
<li>当用户对服务器进行增删改查的时候，对用户进行鉴权，查看其是否拥有此服务器的操作权限</li>
</ul>
<h1 id="JavaSE"><a href="#JavaSE" class="headerlink" title="JavaSE"></a>JavaSE</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="JDK、JRE、JVM有什么区别？"><a href="#JDK、JRE、JVM有什么区别？" class="headerlink" title="JDK、JRE、JVM有什么区别？"></a>JDK、JRE、JVM有什么区别？</h3><ul>
<li>JVM（Java虚拟机）是Java程序的运行环境，它负责将Java源代码编译成的字节码在各种操作系统上执行，并且不同平台都有对应的JVM实现，从而实现跨平台。</li>
</ul>
<blockquote>
<p>JVM是用于执行Java程序的核心模块，但是它并不能单独安装到我们的电脑上，我们一般都是下载安装JDK或JRE，它们包含了JVM和一些其他的东西</p>
</blockquote>
<ul>
<li>JRE（Java运行环境）包含了JVM和Java类库，面向客户和使用者，可以用来运行已经编译完成的Java程序。在不需要进行Java开发的情况下，仅需要安装JRE即可运行Java程序即可。</li>
<li>JDK（Java开发工具包）是Java开发的核心工具包，面向开发者，它不仅包含了JRE的全部内容，还额外包含了编译器（javac）、调试器（jdb）、Java库（Java API）等适用于我们开发人员使用的相关工具。</li>
</ul>
<p><img src="https://s2.loli.net/2024/03/10/Hfe5qt12RZB8gsU.png"></p>
<h3 id="🌟字节码"><a href="#🌟字节码" class="headerlink" title="🌟字节码"></a>🌟字节码</h3><h4 id="什么是字节码？"><a href="#什么是字节码？" class="headerlink" title="什么是字节码？"></a>什么是字节码？</h4><p>Java字节码就是程序编译之后的一种中间代码，它由Java编译器生成，可以在Java虚拟机（JVM）上运行。Java源代码在经过编译后会被转换为字节码文件（以.class为文件扩展名），而不是直接编译成平台相关的机器代码。</p>
<p><img src="https://s2.loli.net/2024/03/10/QY1Cf3VEBuAPgpR.png"></p>
<h4 id="使用字节码好处是什么？"><a href="#使用字节码好处是什么？" class="headerlink" title="使用字节码好处是什么？"></a>使用字节码好处是什么？</h4><p>便于实现<strong>跨平台</strong>，因为JVM上可以读取并执行字节码，而不同平台都有对应的JVM，这样就可以实现跨平台通用了</p>
<h4 id="Java是如何实现跨平台的？"><a href="#Java是如何实现跨平台的？" class="headerlink" title="Java是如何实现跨平台的？"></a>Java是如何实现跨平台的？</h4><p>由于Java程序编译后会变成字节码文件，它有着统一的标准，无论在哪里编译出来都是一样的。同时，不同系统都有对应的JVM实现，无论放在哪个平台上的JVM执行，都是一样的，这样就可以做到一次编译到处运行了</p>
<h3 id="Java是编译型还是解释型语言？"><a href="#Java是编译型还是解释型语言？" class="headerlink" title="Java是编译型还是解释型语言？"></a>Java是编译型还是解释型语言？</h3><p>先看什么是编译型什么是解释型：</p>
<blockquote>
<p>简单来说：编译型语言在运行前需要整体编译成机器语言或者中间代码，而解释型语言则是在运行时逐行解释并执行源代码</p>
</blockquote>
<ul>
<li><strong>编译型语言：</strong>优点是计算机直接运行，性能高；缺点是与平台密切相关，在一种操作系统上编译的程序，无法在其他非同类操作系统上运行，比如Windows下的exe程序在Mac上就无法运行。</li>
<li><strong>解释型语言：</strong> 只需要通过解释器代为执行即可，不需要进行编译。优点是可以跨平台，缺点是需要依靠解释器解释执行，效率肯定没直接编译成机器指令运行的快，并且会产生额外的资源占用。</li>
</ul>
<p>Java需要先编译为字节码再由JVM解释为机器指令执行，可见，它同时具备两种类型的特性，因此<strong>Java既是编译型也是解释型语言</strong></p>
<h4 id="JIT即时编译是什么？"><a href="#JIT即时编译是什么？" class="headerlink" title="JIT即时编译是什么？"></a>JIT即时编译是什么？</h4><blockquote>
<p>JIT编译器（是JVM的一部分）负责<strong>将频繁执行的字节码转换为本地机器代码</strong>，从而提高程序的执行速度</p>
<p>简单来说就是，没有JIT，JVM就一句一句翻译字节码并执行，有了JIT就可以直接大段的直接进行“预翻译”并直接执行，让程序执行的更快。（<strong>编译和解释并存</strong>）</p>
</blockquote>
<h2 id="🌟面向对象"><a href="#🌟面向对象" class="headerlink" title="🌟面向对象"></a>🌟面向对象</h2><h3 id="面向对象三大特性都是什么？"><a href="#面向对象三大特性都是什么？" class="headerlink" title="面向对象三大特性都是什么？"></a>面向对象三大特性都是什么？</h3><p>封装 继承 多态</p>
<h3 id="什么是重载什么是重写？"><a href="#什么是重载什么是重写？" class="headerlink" title="什么是重载什么是重写？"></a>什么是重载什么是重写？</h3><blockquote>
<p>重载是多个同名方法，重写是子类Override重写父类方法</p>
</blockquote>
<ul>
<li><strong>重载（Overload）</strong> 是指在同一个类中可以存在多个<strong>同名方法</strong>，但参数列表不同，返回类型可以相同也可以不同的情况（注意，不能是参数相同仅返回值不同）在调用重载方法时，根据传入的参数类型和个数来确定调用哪个重载方法（提高代码复用性和灵活性</li>
<li><strong>重写（Override）<strong><strong>是指</strong></strong>子类重新定义父类中已经有的同名、同参数列表和返回类型的方法</strong>。在使用多态时，调用子类对象的该方法时会执行子类中的方法而不是父类中的方法。重写可以实现子类对父类方法的个性化定制</li>
</ul>
<h3 id="🌟final字段有什么作用？"><a href="#🌟final字段有什么作用？" class="headerlink" title="🌟final字段有什么作用？"></a>🌟final字段有什么作用？</h3><ul>
<li>修饰变量：修饰的变量不可变，且必须被显式指定初始值</li>
</ul>
<blockquote>
<p> 此处不可变指的是<strong>引用不可变</strong> 如果是对象则不可以更改引用 但其中的值还可以修改</p>
</blockquote>
<ul>
<li>修饰方法：不可以被重写</li>
<li>修饰类：不可以被继承</li>
</ul>
<h3 id="访问修饰符？"><a href="#访问修饰符？" class="headerlink" title="访问修饰符？"></a>访问修饰符？</h3><table>
<thead>
<tr>
<th align="left">修饰符</th>
<th align="left">当前类</th>
<th align="left">同一包内</th>
<th align="left">子孙类(同一包)</th>
<th align="left">子孙类(不同包)</th>
<th align="left">其他包</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>public</code></td>
<td align="left">Y</td>
<td align="left">Y</td>
<td align="left">Y</td>
<td align="left">Y</td>
<td align="left">Y</td>
</tr>
<tr>
<td align="left"><code>protected</code></td>
<td align="left">Y</td>
<td align="left">Y</td>
<td align="left">Y</td>
<td align="left">Y&#x2F;N（<a href="https://www.runoob.com/java/java-modifier-types.html#protected-desc">说明</a>）</td>
<td align="left">N</td>
</tr>
<tr>
<td align="left"><code>default</code></td>
<td align="left">Y</td>
<td align="left">Y</td>
<td align="left">Y</td>
<td align="left">N</td>
<td align="left">N</td>
</tr>
<tr>
<td align="left"><code>private</code></td>
<td align="left">Y</td>
<td align="left">N</td>
<td align="left">N</td>
<td align="left">N</td>
<td align="left">N</td>
</tr>
</tbody></table>
<h4 id="子类会不会继承父类的private属性？"><a href="#子类会不会继承父类的private属性？" class="headerlink" title="子类会不会继承父类的private属性？"></a>子类会不会继承父类的private属性？</h4><p>父类的private属性子类无法直接访问，但是依然可以通过间接的形式去访问父类定义的属性，如果这个属性没有被继承，那么子类肯定是访问不到这个属性的，所以private是会被继承的</p>
<h3 id="抽象类和接口？"><a href="#抽象类和接口？" class="headerlink" title="抽象类和接口？"></a>抽象类和接口？</h3><blockquote>
<p>接口只是具有哪些能力的一个代表而已。而抽象类不同，抽象类再怎么抽象，它本质上也依然是一个类，类是可以具有属性的（但是二者都不可以被new实例化）</p>
</blockquote>
<ol>
<li>接口<ul>
<li>只能包含抽象方法</li>
<li>接口可以定义属性 但是默认为public static final的（后面的jdk版本）</li>
<li>实现接口必须实现所有方法</li>
<li>接口支持多继承（implements）</li>
</ul>
</li>
<li>抽象类<ul>
<li>可以同时包含抽象方法和普通方法</li>
<li>可以有构造方法 但是不能new实例化抽象类的对象</li>
<li>不支持多继承（extends）</li>
</ul>
</li>
</ol>
<p>区别：</p>
<ul>
<li>一个类只能继承一个父类，但是可以实现多个接口。</li>
<li>接口是对类的行为约束，抽象类主要是代码复用，可以继承属性，行为，方法。</li>
<li>接口中的成员变量只能是 public static final 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值</li>
</ul>
<h3 id="🌟🌟🌟-和-equals方法-的区别？"><a href="#🌟🌟🌟-和-equals方法-的区别？" class="headerlink" title="🌟🌟🌟&#x3D;&#x3D; 和 equals方法 的区别？"></a>🌟🌟🌟&#x3D;&#x3D; 和 equals方法 的区别？</h3><p>在Java中，<code>==</code>操作符和<code>equals()</code>方法都是用于比较两个对象，但它们在使用上有着本质区别：</p>
<ol>
<li>使用<code>==</code>运算符<ul>
<li><strong>基本类型</strong>：当用于基本数据类型比较时（如<code>int</code>，<code>char</code>等），<code>==</code>比较的是两个值是否相同</li>
<li><strong>对象类型</strong>：当用于对象比较时，<code>==</code>比较的是两个对象引用是否指向堆内存中的同一个位置。即它比较的是对象的内存地址，而非内容</li>
</ul>
</li>
<li>使用<code>equals()</code>方法<ul>
<li><code>equals()</code>方法用于比较两个对象的内容是否相等，默认情况下（例如在<code>Object</code>类中定义），<code>equals()</code>方法和<code>==</code>操作符的行为相同，都是比较对象的内存地址</li>
<li>但是，很多内置类（如<code>String</code>、<code>Integer</code>等包装类）中预先为我们重写了<code>equals()</code>方法，使其比较的是对象的内容而不是它们的引用。因此，即使是两个不同的对象，只要它们的内容相同，使用<code>equals()</code>方法比较时就会返回<code>true</code></li>
</ul>
</li>
</ol>
<h3 id="🌟🌟🌟equals-和-hashCode？"><a href="#🌟🌟🌟equals-和-hashCode？" class="headerlink" title="🌟🌟🌟equals 和 hashCode？"></a>🌟🌟🌟equals 和 hashCode？</h3><h4 id="什么是hashCode？"><a href="#什么是hashCode？" class="headerlink" title="什么是hashCode？"></a>什么是hashCode？</h4><p>在Java中，<code>hashCode()</code> 方法是用来返回对象的哈希码的。哈希码是一个整数，用来表示对象的唯一标识。Java中默认的 <code>hashCode()</code> 方法是从对象的内存地址计算出来的</p>
<h4 id="为什么要有hashCode？"><a href="#为什么要有hashCode？" class="headerlink" title="为什么要有hashCode？"></a>为什么要有hashCode？</h4><p>哈希码主要用于优化具有哈希结构的集合（如<code>HashMap</code>、<code>HashSet</code>等）的性能。当向这些集合中添加或检索元素时，Java会使用对象的哈希码来快速定位该对象可能存储的桶位置，<strong>提高对象比较的效率</strong></p>
<h4 id="为什么重写-equals-时必须重写-hashCode-⽅法？"><a href="#为什么重写-equals-时必须重写-hashCode-⽅法？" class="headerlink" title="为什么重写 equals 时必须重写 hashCode ⽅法？"></a>为什么重写 equals 时必须重写 hashCode ⽅法？</h4><blockquote>
<p>为了保证<code>equals()</code>方法和<code>hashCode()</code>方法之间的一致性，尤其是在使用<code>HashMap</code>、<code>HashSet</code>等集合的时候</p>
</blockquote>
<ol>
<li><strong>维护相等对象的一致性</strong>：如果两个对象的<code>equals()</code>方法判定相等，那么它们必须具有相同的哈希码，<code>hashCode()</code>方法默认根据对象自身的内存计算独特值，如果没有重写，那么相同类的两个对象的哈希值无论如何也不可能相等（即便两个对象数据一样）</li>
<li><strong>具有哈希结构的集合的实现依赖于hashCode()方法</strong>：如果两个相等的对象却具有不同的哈希码，那么哈希表将无法正确处理它们，可能会导致元素无法被正确存储或检索</li>
</ol>
<h3 id="Java是-值传递-还是-引用传递？"><a href="#Java是-值传递-还是-引用传递？" class="headerlink" title="Java是 值传递 还是 引用传递？"></a>Java是 值传递 还是 引用传递？</h3><p>Java语言是<strong>值传递</strong>，基本数据类型，还是引用数据类型，都是按照值传递的方式进行传递</p>
<ul>
<li><strong>基本类型:</strong> 当你传递一个基本类型给一个方法时，你实际上传递的是该变量值的拷贝，在方法内部对这个值的任何改变都不会影响原始值</li>
<li><strong>引用类型:</strong> 当传递一个引用类型（例如对象）时，传递的是对象引用（或者说指针）而不是对象本身，不过，如果在方法内部改变了引用所指向对象的状态（例如，改变了一个对象的属性）那么肯定原始对象也会被改变</li>
</ul>
<h3 id="什么是深拷贝-浅拷贝？"><a href="#什么是深拷贝-浅拷贝？" class="headerlink" title="什么是深拷贝 浅拷贝？"></a>什么是深拷贝 浅拷贝？</h3><ul>
<li><strong>浅拷贝(Shallow Copy)</strong> 浅拷贝是指创建一个新对象，但只复制原始对象的基本数据类型的数据值，而引用类型数据仍然指向原始对象的内存地址。（根据B复制了A但是B指向A，B修改会影响A）</li>
<li><strong>深拷贝(Deep Copy)</strong> 深拷贝同样是指创建一个新对象，但是此时复制的不仅仅是基本数据类型数据，同时引用类型所指向的对象也会被复制，得到一个新的对象并引用（根据B完全创造了A，AB之间互不关联了）</li>
</ul>
<h2 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h2><h3 id="String类可以被继承吗？"><a href="#String类可以被继承吗？" class="headerlink" title="String类可以被继承吗？"></a>String类可以被继承吗？</h3><p>不可以</p>
<ol>
<li>保存字符串的数组是被 final 修饰且私有的，且 String没有提供相关修改这个数组的方法。</li>
<li>String类 被 final 修饰导致不能被继承，进而达成 String 不可变。</li>
</ol>
<h3 id="String-StringBuilder-StringBuffer？"><a href="#String-StringBuilder-StringBuffer？" class="headerlink" title="String   StringBuilder   StringBuffer？"></a>String   StringBuilder   StringBuffer？</h3><blockquote>
<p>都是用于处理字符串的类，都实现了CharSequence接口</p>
</blockquote>
<ul>
<li>String：不可变，故而线程安全，但频繁的字符串拼接操作会产生大量临时对象，影响性能</li>
<li>StringBuffer：方法都使用<code>synchronized</code>关键字进行同步保证线程安全，但性能相对较低</li>
<li>StringBuilder：没有进行同步，不具备线程安全，性能更好，但需要自行保证线程安全</li>
</ul>
<h3 id="String-str1-new-String-“abc”-和String-str2-“abc”-和-区别？"><a href="#String-str1-new-String-“abc”-和String-str2-“abc”-和-区别？" class="headerlink" title="String str1 &#x3D; new String(“abc”)和String str2 &#x3D; “abc” 和 区别？"></a>String str1 &#x3D; new String(“abc”)和String str2 &#x3D; “abc” 和 区别？</h3><blockquote>
<p>运行时常量池位于<strong>方法区</strong>，字符串常量池位于<strong>堆</strong>，对象也位于<strong>堆</strong></p>
</blockquote>
<ul>
<li>两个语句都会去<strong>字符串常量池</strong>中检查是否已经存在 “abc”，如果有则直接使用，如果没有则会在常量池中创建 “abc” 对象</li>
<li>对于 <code>String str1 = new String(&quot;abc&quot;)</code>，无论字符串常量池中是否已经存在 <code>&quot;abc&quot;</code> 字符串，都会在堆内存中创建一个新的对象。因此，<code>str1</code> 和任何其他 <code>&quot;abc&quot;</code> 字符串对象都不会相等（除非是同一个对象的引用）</li>
</ul>
<h3 id="String的intern方法有什么作用？"><a href="#String的intern方法有什么作用？" class="headerlink" title="String的intern方法有什么作用？"></a>String的intern方法有什么作用？</h3><blockquote>
<p> 它返回的是<strong>字符串常量池中的引用</strong></p>
</blockquote>
<ul>
<li>如果常量池中已经存在等于此字符串对象的字符串，则返回常量池中的引用</li>
<li>否则，将此字符串对象添加到常量池中，并返回该对象的引用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1.intern(); <span class="comment">// 返回常量池中的引用</span></span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// 输出 false，因为s1和s2是两个不同的对象</span></span><br><span class="line">System.out.println(s2 == s3); <span class="comment">// 输出 true，因为s3是从常量池中返回的引用，与s2相同</span></span><br></pre></td></tr></table></figure>

<h3 id="Object类的常见方法？"><a href="#Object类的常见方法？" class="headerlink" title="Object类的常见方法？"></a>Object类的常见方法？</h3><p><img src="D:\desktop\面经高频问题.assets\image-20240409111259891.png"></p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><blockquote>
<p>值得注意的是：即便 try&#x2F;catch 里面 return 了 还是会执行 finally</p>
</blockquote>
<p><img src="D:\desktop\面经高频问题.assets\image-20240409111935653.png"></p>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><h4 id="什么是序列化？反序列化？"><a href="#什么是序列化？反序列化？" class="headerlink" title="什么是序列化？反序列化？"></a>什么是序列化？反序列化？</h4><p>序列化就是把Java对象转为二进制流，方便存储和传输</p>
<p>所以反序列化就是把二进制流恢复成对象</p>
<h4 id="Serializable接口有什么用？"><a href="#Serializable接口有什么用？" class="headerlink" title="Serializable接口有什么用？"></a>Serializable接口有什么用？</h4><p>Serializable接口是Java提供的一个标记接口，用于标识类可以被序列化。实现 Serializable接口的类可以将对象转换为字节流进行传输和存储，实现数据的持久化和 跨平台的数据交换</p>
<h4 id="serialVersionUID-有什么用？"><a href="#serialVersionUID-有什么用？" class="headerlink" title="serialVersionUID 有什么用？"></a>serialVersionUID 有什么用？</h4><p>serialVersionUID是Java中用于序列化和反序列化的一个特殊字段。它是一个静态常量，用于标识序列化类的版本号，它是一个64位的long类型数字，具有以下作用：</p>
<ul>
<li>版本控制</li>
<li>兼容性</li>
</ul>
<h4 id="Java-序列化不包含静态变量？"><a href="#Java-序列化不包含静态变量？" class="headerlink" title="Java 序列化不包含静态变量？"></a>Java 序列化不包含静态变量？</h4><p>Java序列化只会保存对象的非静态成员变量，不包含静态变量</p>
<h4 id="如果有些变量不想序列化，怎么办？"><a href="#如果有些变量不想序列化，怎么办？" class="headerlink" title="如果有些变量不想序列化，怎么办？"></a>如果有些变量不想序列化，怎么办？</h4><p>使用<code>transient</code>关键字修饰。</p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h3><blockquote>
<p><strong>动态地</strong>获取类信息、创建类实例、调用类方法这时候就要用到反射</p>
</blockquote>
<p><img src="D:\desktop\面经高频问题.assets\image-20240409111645066.png"></p>
<h3 id="反射的应用场景"><a href="#反射的应用场景" class="headerlink" title="反射的应用场景"></a>反射的应用场景</h3><p>像 Spring &#x2F; Spring Boot、MyBatis 等等框架中都大量使用了反射机制</p>
<p>Spring里的很多注解 ，它真正的功能实现就是利用反射</p>
<h3 id="反射的实现原理？"><a href="#反射的实现原理？" class="headerlink" title="反射的实现原理？"></a>反射的实现原理？</h3><blockquote>
<p>基于JVM的<strong>类加载机制和类对象模型</strong></p>
</blockquote>
<p>在Java 中，每个类都有一个对应的Class对象，该对象包含了类的名称、字段、方法等信息。通过反射，我们可以获取到这些信息，并在运行时动态地操作类和对象</p>
<h1 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h1><h3 id="🌟ArrayList和LinkedList的区别？"><a href="#🌟ArrayList和LinkedList的区别？" class="headerlink" title="🌟ArrayList和LinkedList的区别？"></a>🌟ArrayList和LinkedList的区别？</h3><ul>
<li>数据结构不同（前者<strong>动态数组</strong>，后者<strong>双向链表</strong>）</li>
<li>前者利于查找、后者利于增删</li>
<li>是否支持随机访问</li>
<li>内存占用（是否连续）</li>
</ul>
<h4 id="ArrayList扩容机制"><a href="#ArrayList扩容机制" class="headerlink" title="ArrayList扩容机制"></a>ArrayList扩容机制</h4><ul>
<li>ArrayList 默认大小是 10</li>
<li>ArrayList 默认是以空数组进行创建的，当真正对数组添加元素的时候，才真正分配容量。</li>
<li>当加入 n + 1 个元素时，进行扩容，定义一个newCapacity，这个新的容量是<strong>旧容量的 1.5 倍</strong>。进而调用 Array.copyOf()</li>
</ul>
<h3 id="线程安全的-List是如何实现线程安全的"><a href="#线程安全的-List是如何实现线程安全的" class="headerlink" title="线程安全的 List是如何实现线程安全的"></a>线程安全的 List是如何实现线程安全的</h3><p>CopyOnWriteArrayList底层通过数组保存数据，使用volatile关键字修饰数组，保证当前线程对数组对象重新赋值后，其他线程可见。<br>并且写入操作时，添加ReentrantLock保证线程安全。</p>
<h3 id="HashSet，LinkedHashSet，TreeSet的区别"><a href="#HashSet，LinkedHashSet，TreeSet的区别" class="headerlink" title="HashSet，LinkedHashSet，TreeSet的区别"></a>HashSet，LinkedHashSet，TreeSet的区别</h3><ul>
<li>都能保证元素唯一，并且都不是线程安全的。</li>
<li>HashSet 的底层数据结构是哈希表（基于 HashMap 实现）。</li>
<li>LinkedHashSet 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。</li>
<li>TreeSet 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li>
<li>HashSet 用于不需要保证元素插入和取出顺序的场景，LinkedHashSet 用于保证元素的插入和取出顺序满足 FIFO 的场景，TreeSet 用于支持对元素自定义排序规则的场景。</li>
</ul>
<h3 id="🌟快速失败-和-安全失败？"><a href="#🌟快速失败-和-安全失败？" class="headerlink" title="🌟快速失败 和 安全失败？"></a>🌟快速失败 和 安全失败？</h3><blockquote>
<p>两种“失败”源于<strong>在遍历集合的同时有对集合做修改</strong>，尤其是在面对<strong>多线程环境下</strong>的<strong>并发修改</strong>时所采取的不同策略</p>
</blockquote>
<h4 id="快速失败"><a href="#快速失败" class="headerlink" title="快速失败"></a>快速失败</h4><blockquote>
<p>位于<code>java.util</code>包下的<code>ArratList / LinkedList / HashMap</code>等都采用快速失败</p>
</blockquote>
<ul>
<li><strong>现象</strong>：如果在迭代过程中有线程（包括本身）对集合进行了修改（添加&#x2F;删除&#x2F;更新），那么会立刻检测到这个修改并<strong>迅速抛出异常</strong></li>
<li><strong>原理</strong>：通过<strong>维护一个内部计数器</strong>（如<code>modCount</code>）来跟踪集合结构的变化。每次对集合进行结构修改时，这个计数器会递增，迭代器在每次调用<code>next()</code>或<code>remove()</code>方法前检查当前计数器值与遍历开始时记录的预期值是否一致。如果不一致，说明集合已被并发修改，于是立即抛出异常</li>
<li><strong>如何解决</strong>？<ul>
<li><strong>删除元素</strong>：使用迭代器的<code>remove()</code>方法 &#x2F; 使用集合自带的<code>removeIf()</code>方法</li>
<li><strong>多线程</strong>：加锁修改，<strong>使用并发集合</strong>（如<code>CopyOnWriteArrayList / ConcurrentHashMap</code>等）</li>
</ul>
</li>
</ul>
<h4 id="安全失败"><a href="#安全失败" class="headerlink" title="安全失败"></a>安全失败</h4><blockquote>
<p>位于<code>java.util.concurrent</code>包下的<code>CopyOnWriteArrayList / ConcurrentHashMap</code>等都采用安全失败</p>
</blockquote>
<ul>
<li><strong>现象</strong>：在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历</li>
<li><strong>原理</strong>：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中所作的修改并不能被迭代器检测到，所以不会触发<strong>快速失败</strong>而抛出异常</li>
<li><strong>缺点</strong>：迭代器并不能访问到修改后的内容（开始遍历的那一刻就一直拿的是原始集合）</li>
</ul>
<h3 id="讲讲HashMap？"><a href="#讲讲HashMap？" class="headerlink" title="讲讲HashMap？"></a>讲讲HashMap？</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>数组+链表+红黑树</p>
<p>在jdk1.8 之后在解决 Hash 冲突的时候有了优化，当<strong>链表长度大于 8</strong> 且<strong>数组长度大于 64</strong> 时，将链表转换成红黑树。</p>
<h4 id="红黑树特点"><a href="#红黑树特点" class="headerlink" title="红黑树特点"></a>红黑树特点</h4><ul>
<li><strong>节点颜色</strong>：每个节点或者是黑色，或者是红色</li>
<li><strong>根节点和叶子节点</strong>：根节点和叶子节点（<code>NIL</code>）是黑色的</li>
<li><strong>颜色规则</strong>：如果一个节点是红色的，则它的父节点&#x2F;子节点必须是黑色的</li>
<li><strong>路径规则</strong>：从任意节点到其每个叶子节点的路径都包含相同数量的黑色节点</li>
</ul>
<h4 id="HashMap哈希函数怎么设计的？"><a href="#HashMap哈希函数怎么设计的？" class="headerlink" title="HashMap哈希函数怎么设计的？"></a>HashMap哈希函数怎么设计的？</h4><blockquote>
<p>这样设计达到高位低位混合的效果，增加哈希值随机性，降低哈希冲突概率</p>
</blockquote>
<ul>
<li>先通过hashCode获得key的哈希值（32位）</li>
<li>再将哈希值右移16位，与哈希值本身<strong>异或</strong></li>
</ul>
<h4 id="HashMap和Hashtable的区别？"><a href="#HashMap和Hashtable的区别？" class="headerlink" title="HashMap和Hashtable的区别？"></a>HashMap和Hashtable的区别？</h4><p>都实现了Map接口，但是有以下不同：</p>
<ul>
<li>HashMap可以接受<code>null</code>的key和value，Hashtable不行</li>
<li>HashMap是非线程安全的，HashTable是线程安全的</li>
<li>Hashtable很多方法是同步方法，在单线程环境下它比HashMap要慢</li>
<li>哈希值的使用不同，HashTable直接使用对象的hashCode，而HashMap重新计算hash值</li>
</ul>
<h4 id="LinkedHashMap和TreeMap是如何保证有序的？"><a href="#LinkedHashMap和TreeMap是如何保证有序的？" class="headerlink" title="LinkedHashMap和TreeMap是如何保证有序的？"></a>LinkedHashMap和TreeMap是如何保证有序的？</h4><p>前者双向链表，后者红黑树</p>
<h4 id="HashMap-多线程死循环了解吗"><a href="#HashMap-多线程死循环了解吗" class="headerlink" title="HashMap 多线程死循环了解吗"></a>HashMap 多线程死循环了解吗</h4><p>在 JDK1.8 之前，多线程的情况下，当一个桶位中有多个元素需要进行扩容，执行的<strong>头插法</strong>会导致链表中的节点指向错误，从而形成一个环形链表，死循环。</p>
<p>在 JDK1.8 之后，使用的是<strong>尾插法，</strong>新的元素永远在尾部，能避免死循环，但是多线程情况下还是使用 ConcurrentHashMap 合适。</p>
<h4 id="HashMap-为什么线程不安全"><a href="#HashMap-为什么线程不安全" class="headerlink" title="HashMap 为什么线程不安全"></a>HashMap 为什么线程不安全</h4><ul>
<li>多线程情况下，会导致<strong>数据丢失。</strong></li>
<li>JDK1.8 中，多个 KV 对有可能被分配到同一个桶中，多线程 put 的话会有数据被覆盖的风险。</li>
</ul>
<h3 id="ConcurrentHashMap了解多少？"><a href="#ConcurrentHashMap了解多少？" class="headerlink" title="ConcurrentHashMap了解多少？"></a>ConcurrentHashMap了解多少？</h3><blockquote>
<ul>
<li>相对于普通的HashMap，它提供了一种线程安全的HashMap实现。 底层数据结构是Node数据 + 链表&#x2F;红黑树，通过 synchronized + CAS 来实现线程安全</li>
</ul>
</blockquote>
<h4 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h4><blockquote>
<p>采用分段锁机制，一个Segment数组，相当于每个Segment都是一个HashMap（但是<strong>没有红黑树</strong> 只有链表），Segment之间相互不会受到影响</p>
</blockquote>
<ul>
<li>put 流程<ol>
<li>计算hash 定位到segment 为空就初始化</li>
<li>使用<strong>ReentrantLock</strong>加锁，获取锁失败旧尝试自旋，自旋超过次数旧阻塞获取保证一定成功</li>
<li>遍历HashEntry，和HashMap一样，尝试插入进node</li>
</ol>
</li>
<li>get 流程	get很简单，key通过hash定位到segment，再遍历链表定位到具体元素（注意：value是volatile的 所以get无需加锁）</li>
</ul>
<h4 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h4><blockquote>
<p>数据结构和HashMap是一样的，<strong>数组+链表+红黑树</strong>。通过 synchronized + CAS 来控制。它实现线程安全的关键点在于put流程</p>
</blockquote>
<ul>
<li>put 流程<ol>
<li>首先计算hash，遍历node数组，如果node是空的话，就通过 CAS+自旋 的方式初始化</li>
<li>如果当前数组位置是空则直接通过 CAS自旋 写入数据</li>
<li>如果hash&#x3D;&#x3D;MOVED，说明需要扩容，执行扩容</li>
<li>如果都不满足，就使用synchronized写入数据，写入数据同样判断链表、红黑树，链表写入和HashMap的方式一样，hash一样就覆盖，反之就尾插法，链表长度超过8就转换成红黑树</li>
</ol>
</li>
<li>get 流程get很简单，无锁化读取，和HashMap的get流程基本相同</li>
<li>JDK1.8 之后锁的颗粒度更细，只会锁当前链表或者红黑树的首节点，只要 Hash 不冲突，并不会产生并发也不影响其他 Node 的读写。</li>
</ul>
<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><blockquote>
<p>Spring 是一款开源的轻量级 Java 开发框架，旨在提高开发人员的开发效率以及系统的可维护性。</p>
</blockquote>
<h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><blockquote>
<p>使用IOC最主要的作用就是<strong>解耦</strong>，不再关心对象之间的依赖</p>
</blockquote>
<ul>
<li>IOC(Inversion of Control)：<strong>控制反转</strong>，控制对象生命周期的不再是引用它的对象，而是容器，由容器来负责控制对象的生命周期和对象间的关系（将对象管理的权力交给Spring）</li>
<li>比如当我们需要一个接口的实现时，由它根据配置文件来决定到底给我们哪一个实现类，这样，我们就可以不用再关心我们要去使用哪一个实现类了</li>
</ul>
<h3 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h3><blockquote>
<p><strong>依赖注入</strong>，指的是容器在实例化对象的时候把它依赖的类注入给它</p>
</blockquote>
<h4 id="有哪些方法可以依赖注入？"><a href="#有哪些方法可以依赖注入？" class="headerlink" title="有哪些方法可以依赖注入？"></a>有哪些方法可以依赖注入？</h4><ul>
<li>构造方法注入</li>
<li>属性注入</li>
<li>工厂方法注入<ul>
<li>非静态工厂</li>
<li>静态工厂</li>
</ul>
</li>
</ul>
<h4 id="Component和-Bean"><a href="#Component和-Bean" class="headerlink" title="@Component和 @Bean"></a>@Component和 @Bean</h4><ul>
<li>@Component 作用于类上，@Bean 作用在方法。</li>
<li>@Component 通常通过启动配置@ComponentScan扫描到的类，自动装配到了 Bean 容器中。而@Bean 是当需要的用到的时候，Spring 才给调用方。</li>
</ul>
<h4 id="Autowired和-Resourse有什么区别？"><a href="#Autowired和-Resourse有什么区别？" class="headerlink" title="@Autowired和@Resourse有什么区别？"></a>@Autowired和@Resourse有什么区别？</h4><ul>
<li>@Autowird 是Spring提供的，默认是 byType 的，优先匹配类型注入 Bean。</li>
<li>@Resource 是JDK提供的，默认是 ByName 的，如果找不到相对应的 Name 时，才会转成 byType。</li>
</ul>
<h4 id="Bean是线程安全的吗？"><a href="#Bean是线程安全的吗？" class="headerlink" title="Bean是线程安全的吗？"></a>Bean是线程安全的吗？</h4><ul>
<li>按原理来说是线程不安全的，通常 bean 的作用域是 Singleton 单例的，会存在资源的竞争。</li>
<li>大部分的 Bean 都是无状态的(都是不可变的成员变量)，既然是无状态的，也不存在安不安全的问题了。</li>
<li>解决方案：<ul>
<li>避免定义可变的成员变量。</li>
<li>在类中定义 ThreadLocal，将可变变量放到ThreadLocal里。</li>
</ul>
</li>
</ul>
<h4 id="循环依赖？"><a href="#循环依赖？" class="headerlink" title="循环依赖？"></a>循环依赖？</h4><blockquote>
<p>简单来说就是自己依赖自己，或者和别的Bean相互依赖（只存在于<strong>单例模式</strong>，原型模式会抛出异常）</p>
<p>注意：Spring可以自动解决：AB均采用属性注入、先构造器注入后属性注入，无法解决均构造器注入</p>
<p>Spring解决循环依赖主要依赖于其内部的<strong>“三级缓存”</strong>机制</p>
</blockquote>
<p><img src="/%E9%9D%A2%E7%BB%8F%E9%AB%98%E9%A2%91%E9%97%AE%E9%A2%98/1714998833431.png"></p>
<ul>
<li>Spring容器初始化Bean的过程：实例化、属性赋值（注入就发生在这一步）、初始化</li>
<li>“三级缓存”机制<ul>
<li><strong>一级缓存</strong>：存放完全初始化好（三个步骤都完成）的单例Bean对象</li>
<li><strong>二级缓存</strong>：存放完成了实例化但是并未初始化的单例对象。</li>
<li><strong>三级缓存</strong>：存放能够创建Bean实例的ObjectFactory对象</li>
</ul>
</li>
<li>如何用三级缓存解决循环依赖？（举例当A、B两个类都用属性注入发生循环依赖时）</li>
</ul>
<blockquote>
<p>所以，我们就知道为什么Spring能解决属性注入的循环依赖了，因为实例化和属性赋值是分开的，所以里面有操作的空间。如果都是构造器注入，那么都得在实例化这一步完成注入，所以自然是无法支持</p>
</blockquote>
<pre><code>- 创建A实例，把A对象工厂放入三级缓存，表示A开始实例化了
- A注入属性时，发现依赖B，但B还没有创建，就去实例化B
- 同样，B注入属性发现依赖A，就从缓存里找A，依次从一级到三级缓存查询A，从三级缓存通过对象工厂拿到A，但是A不太完善，就把A放入二级缓存，同时删掉三级缓存中的A，此时B完成属性注入，把完全初始化好的B放入一级缓存
- 接着A继续完成属性赋值，从一级缓存拿到完全初始化的B，删除二级中的A，放入一级
- 最后一级缓存中保存着完全初始化好的A和B对象
</code></pre>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><ul>
<li>简单说，就是把一些业务逻辑中的相同的代码抽取到一个独立的模块中，让业务逻辑更加清爽。</li>
<li>例如，每个模块都要有日志记录、数据校验等功能，就可以分离出来，在各个模块合适的地方植入即可</li>
<li>AOP的核心是<strong>动态代理</strong><ul>
<li>Spring在实现AOP时，会根据目标类是否实现接口自动选择使用JDK动态代理或CGLIB代理</li>
<li>默认情况下，如果目标类实现了接口，Spring会选择JDK代理；否则，会选择CGLIB代理（生成一个被代理类的子类作为对象）</li>
<li>用户也可以通过配置强制指定使用某种代理方式</li>
</ul>
</li>
</ul>
<blockquote>
<p>JDK动态代理适用于那些已实现接口且对代理类创建速度要求不高的情况，尤其适合遵循面向接口编程原则的项目。而CGLIB代理则适用于需要代理未实现接口的类，或者对代理类创建速度有较高要求的场景</p>
</blockquote>
<h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><blockquote>
<p>基于<strong>接口</strong>实现，目标类必须至少要实现一个接口</p>
</blockquote>
<ul>
<li><strong>原理</strong><ul>
<li>定义一个实现<code>java.lang.InvocationHandler</code>接口的类，该类包含一个<code>invoke</code>方法，用于处理代理对象上的方法调用，在此方法内，可以编写横切逻辑，并最终调用目标对象的实际方法</li>
<li>通过代理对象调用方法时，实际上会触发<code>InvocationHandler</code>的<code>invoke</code>方法，从而执行预设的横切逻辑和目标方法</li>
</ul>
</li>
<li><strong>优点</strong>：无需额外依赖、稳定性、面向接口有助于解耦</li>
<li><strong>缺点</strong>：仅能代理实现了接口的类、性能相较于CGLIB略逊一筹</li>
</ul>
<h4 id="CGLIB代理"><a href="#CGLIB代理" class="headerlink" title="CGLIB代理"></a>CGLIB代理</h4><blockquote>
<p>CGLIB并不依赖于目标类是否实现了接口，而是基于<strong>继承</strong></p>
</blockquote>
<ul>
<li><strong>原理</strong>：<ul>
<li>基于<strong>ASM字节码操作框架</strong>，能够在运行时动态<strong>生成目标类的子类作为代理对象</strong></li>
<li>这个子类重写了目标类的部分或全部方法，从而在方法调用时插入额外的操作</li>
</ul>
</li>
<li><strong>优点</strong>：无接口限制（适用范围更广）、性能比JDK动态代理快</li>
<li><strong>缺点</strong>：第三方依赖、继承局限（无法代理final类、无法覆盖final方法）</li>
</ul>
<h3 id="Spring事务传播行为？"><a href="#Spring事务传播行为？" class="headerlink" title="Spring事务传播行为？"></a>Spring事务传播行为？</h3><ul>
<li><strong>REQUIRED</strong>：如果当前存在事务，则加入这个事务，如果没有，则创建一个新的事务。</li>
<li><strong>REQUIRES_NEW：</strong>如果当前存在事务，直接挂起，开一个新的事务进行执行，两者互不干扰。</li>
<li><strong>MANDATORY</strong>：如果当前存在事务，则加入这个事务，反之直接抛出异常。</li>
<li>SUPPORTS：存在则加入，不存在，以非事务方式运行。</li>
<li>NOT_SUPPORTS：以非事务方式运行，存在事务则挂起。</li>
<li>NEVER：以非事务方式运行，存在事务则抛出异常。</li>
</ul>
<h4 id="导致Spring声明式事务失效的原因？"><a href="#导致Spring声明式事务失效的原因？" class="headerlink" title="导致Spring声明式事务失效的原因？"></a>导致Spring声明式事务失效的原因？</h4><ul>
<li>@Transactional 应用在非 public 修饰的方法上</li>
<li>@Transactional 注解属性 propagation（传播行为）设置错误</li>
<li>@Transactional 注解属性 rollbackFor （事务回滚的异常类型）设置错误</li>
<li>同一个类中方法调用，导致@Transactional失效</li>
</ul>
<h4 id="Bean生命周期"><a href="#Bean生命周期" class="headerlink" title="Bean生命周期"></a>Bean生命周期</h4><ul>
<li><strong>创建 Bean 的实例</strong>：找到配置文件中的Bean 定义，创建实例，分配内存空间</li>
<li><strong>Bean 属性赋值&#x2F;填充：</strong> 依赖注入，注解注入的对象、@value注入的值等属性填充。</li>
<li><strong>Bean 初始化</strong><ul>
<li>是否实现了 *.Aware() 接口，先执行</li>
<li>执行前置方法 postProcess<strong>Before</strong>Initialization()</li>
<li>执行 afterPropertiesSet() 方法，进行初始化</li>
<li>执行 init-method 属性中的指定方法</li>
<li>执行后置方法 postProcess<strong>After</strong>Initialization()</li>
</ul>
</li>
<li>销毁Bean：将销毁方法记录，将来要销毁时再执行<ul>
<li>实现了DisposableBean接口，执行destroy()方法</li>
<li>配置文件包含 destroy-method 属性，执行指定的销毁方法。</li>
</ul>
</li>
</ul>
<h3 id="BeanFactory-和-FactoryBean-和-ApplicationContext-了解吗？"><a href="#BeanFactory-和-FactoryBean-和-ApplicationContext-了解吗？" class="headerlink" title="BeanFactory 和 FactoryBean 和 ApplicationContext 了解吗？"></a>BeanFactory 和 FactoryBean 和 ApplicationContext 了解吗？</h3><p><strong>前者</strong></p>
<ul>
<li>BeanFactory：管理 Bean 的容器，Spring 生成的 Bean 都是通过这个接口实现管理的。</li>
<li>FactoryBean：用于创建复杂的 Bean，可以在创建 Bean 实例的时候提供更高的灵活性</li>
</ul>
<p><strong>后者</strong></p>
<ul>
<li>BeanFactory 是 Spring 中最底层的接口，包含各种 Bean 的定义、管理 Bean 的加载、初始化；ApplicationContext 接口是前者的派生，提供了更多功能入：国际化、资源文件统一访问、同时加载多个配置文件等。</li>
<li>BeanFactory 是延迟加载的方式注入 Bean 的，当调用了 getBean() 的时候，才对 Bean 进行加载实例化。而后者是容器启动的时候就一次性加载全部的 Bean。</li>
<li>创建方式的区别。BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。</li>
<li>注册方式的区别。BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。</li>
</ul>
<h3 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h3><h4 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h4><ul>
<li>DispatcherServlet：核心中央处理器，负责接受请求、分发，并且响应客户端。</li>
<li>HandlerMapping：处理器映射器，根据 URL 匹配对应的 Handler，并且将请求涉及的拦截器与 Handler 封装。</li>
<li>HandlerAdapter：处理器适配器，根据HandlerMapping 找到的 Handler，适配执行。</li>
<li>Handler：请求处理器，实际请求的处理器。</li>
<li>ViewResolver：视图解析器，根据 Handler 返回的逻辑视图，转换成真正视图。</li>
</ul>
<h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><ol>
<li>http 请求到DispatcherServlet</li>
<li>DispatcherServlet 发送 URL 到HandlerMapping中</li>
<li>HandlerMapping 找到相对应的 Handler，返回给 DispatcherServlet。</li>
<li>DispatcherServlet 告诉 HandlerAdapter要执行的 Handler</li>
<li>HandlerAdapter 调用 Handler 执行，并且返回ModelAndView 给 DispatcherServlet</li>
<li>DispatcherServlet 将 ModelAndView 给 ViewResolver 处理，返回真正的视图</li>
<li>DispatcherServlet 将真正的视图返回给浏览器</li>
</ol>
<h4 id="Spring用到哪些设计模式？"><a href="#Spring用到哪些设计模式？" class="headerlink" title="Spring用到哪些设计模式？"></a>Spring用到哪些设计模式？</h4><ul>
<li>工厂模式：通过 BeanFactory 创建 Bean 对象。</li>
<li>单例模式：Bean 默认的作用域就是单例模式创建的。</li>
<li>代理模式：AOP 就是通过代理模式实现的。</li>
<li>模板方法：JdbcTemplate 以Template 结尾的类都是模板方法。</li>
<li>适配器模式：在 Spring MVC 中的核心组件里就是适配器模式，可以根据不同的Controller 获取到对应类型。</li>
<li>装试者模式：可以动态地添加额外的属性或行为。</li>
</ul>
<h3 id="Spring-Boot？"><a href="#Spring-Boot？" class="headerlink" title="Spring Boot？"></a>Spring Boot？</h3><h4 id="介绍一下SpringBoot，它有哪些优点？"><a href="#介绍一下SpringBoot，它有哪些优点？" class="headerlink" title="介绍一下SpringBoot，它有哪些优点？"></a>介绍一下SpringBoot，它有哪些优点？</h4><p>Springboot用来简化Spring应用的创建、运行、调试、部署等。使用Spring Boot可以做到专注于Spring应用的开发，而无需过多关注XML的配置</p>
<ul>
<li>内置servlet容器，不需要在服务器部署 tomcat。只需要将项目打成jar包，使用java -jar xxx.jar一键式启动项目</li>
<li>SpringBoot提供了starter，把常用库聚合在一起，简化复杂的环境配置，快速搭建spring应用环境</li>
<li>SpringBoot无需再像Spring一样配置一堆繁琐的xml文件</li>
<li>可以快速整合常用依赖，创建独立运行的spring项目</li>
</ul>
<h4 id="SpringBoot自动配置原理了解吗？"><a href="#SpringBoot自动配置原理了解吗？" class="headerlink" title="SpringBoot自动配置原理了解吗？"></a>SpringBoot自动配置原理了解吗？</h4><ul>
<li>在 SpringBoot 项目启动类中，@EnableAutoConfiguration进行启动</li>
<li>通过 @AutoConfigurationPackage 将main同级的包下的所有组件注册到容器中 。AutoConfigurationImportSelector 扫描 <code>META-INF/spring.factories</code>文件，根据条件判断将满足条件的自动配置类导入到spring容器当中</li>
</ul>
<h4 id="SpringBoot启动原理了解吗"><a href="#SpringBoot启动原理了解吗" class="headerlink" title="SpringBoot启动原理了解吗"></a>SpringBoot启动原理了解吗</h4><p>JAR文件分为以下部分：</p>
<ul>
<li><strong>META-INF</strong> 文件夹：包含元数据。</li>
<li><strong>BOOT-INF</strong> 文件夹：包含依赖 JAR 和类文件。</li>
<li><strong>application.properties&#x2F;yml</strong> 文件：应用配置文件。</li>
</ul>
<ol>
<li>Spring Boot 应用通常有一个带有 main 方法的主类，这个类上标注了 <code>@SpringBootApplication</code> 注解，它是整个应用启动的入口。</li>
<li>调用 <code>SpringApplication.run()</code> 方法时,创建<code>ApplicationContext</code>管理Bean生命周期，加载yaml，初始化和加载Bean定义</li>
<li>启动内嵌的Web服务器</li>
</ol>
<h4 id="starter是什么？如何编写一个自己的starter？"><a href="#starter是什么？如何编写一个自己的starter？" class="headerlink" title="starter是什么？如何编写一个自己的starter？"></a>starter是什么？如何编写一个自己的starter？</h4><blockquote>
<p>Spring Boot Starter 是 Spring Boot 框架的一个重要特性，它旨在简化应用程序的初始设置和依赖管理。一个 Starter 是一个特殊的模块或库，它包含了实现特定功能所需的所有依赖项、自动配置类和可能的默认配置</p>
</blockquote>
<ol>
<li>创建一个新的 Maven 项目</li>
<li>添加 Spring Boot 相关依赖</li>
<li>创建自动化配置类 注解EnableAutoConfigurationProperties</li>
<li>定义属性类和Service层 ConfigurationProperties</li>
<li>打包并发布到私有或公共仓库</li>
</ol>
<p><strong>Spring Boot Starter 的主要特点包括：</strong></p>
<ol>
<li><strong>依赖聚合</strong>：Starter 封装了一组相关的库及其依赖，确保版本兼容性和减少版本冲突。例如，<code>spring-boot-starter-data-jpa</code> 不仅包含 Spring Data JPA，还包含了 Hibernate、Spring ORM 等必要依赖</li>
<li><strong>自动配置</strong>：每个 Starter 通常会附带一个或多个 <code>@Configuration</code> 类，这些类使用 Spring Boot 的条件化配置机制（<code>@ConditionalOnClass</code>, <code>@ConditionalOnMissingBean</code> 等注解）来自动配置 Bean 和属性，当满足特定条件（如类路径上有某些库存在）时，自动配置就会生效</li>
<li><strong>默认配置</strong>：Starter 可能会提供默认的配置属性，这些属性可以在 <code>application.properties</code> 或 <code>application.yml</code> 文件中轻松覆盖。Spring Boot 的 <code>spring-boot-configuration-processor</code> 插件还会为这些属性生成元数据，使得 IDE 能够提供智能提示和文档链接</li>
</ol>
<h3 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h3><h4 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h4><p>在请求时，如果出现了以下情况中的任意一种，那么它就是跨域请求：</p>
<ol>
<li><strong>协议不同，如 http 和 https；</strong></li>
<li><strong>域名不同；</strong></li>
<li><strong>端口不同。</strong></li>
</ol>
<p>也就是说，<strong>即使域名相同，如果一个使用的是 http，另一个使用的是 https，那么它们也属于跨域访问</strong>。</p>
<h4 id="解决跨域方法"><a href="#解决跨域方法" class="headerlink" title="解决跨域方法"></a>解决跨域方法</h4><ol>
<li>通过设置配置文件<ol>
<li>创建一个新配置文件</li>
<li>添加@Configuration 注解，实现 WebMvcConfigurer 接口；</li>
<li>重写写 addCorsMappings 方法，设置允许跨域的代码。</li>
</ol>
</li>
<li>通过CorsFilter跨域</li>
</ol>
<p>解决跨域方法其实只需要<strong>在返回头中设置“Access-Control-Allow-Origin”参数即可解决跨域问题，此参数就是用来表示允许跨域访问的原始域名的，当设置为“*”时，表示允许所有站点跨域访问</strong></p>
<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h3 id="介绍一下RabbitMQ"><a href="#介绍一下RabbitMQ" class="headerlink" title="介绍一下RabbitMQ?"></a>介绍一下RabbitMQ?</h3><p>RabbitMQ 是一个在 AMQP（Advanced Message Queuing Protocol ）基础上实现的，可复用的企业消息系统。它实现了一个 Broker 构架，这意味着消息在发送给客户端时先在中心队列排队，对路由(Routing)、负载均衡(Load balance)或者数据持久化都有很好的支持。</p>
<h4 id="exchange都有哪些类型？"><a href="#exchange都有哪些类型？" class="headerlink" title="exchange都有哪些类型？"></a>exchange都有哪些类型？</h4><ul>
<li><strong>direct</strong>：（默认的）<strong>全文匹配</strong>，按照routingkey发到指定队列</li>
<li><strong>topic</strong>：<strong>模糊匹配</strong>，根据通配符可将一个消息发到多个队列</li>
<li><strong>fanout</strong>：<strong>消息广播</strong>，直接将消息发到该交换机绑定的所有队列</li>
<li><strong>header</strong>：<strong>自定义消息头</strong>的key-value来判断是否发送到绑定的队列（性能很差，一般不用）</li>
</ul>
<h4 id="什么是死信队列？"><a href="#什么是死信队列？" class="headerlink" title="什么是死信队列？"></a>什么是死信队列？</h4><blockquote>
<p>存储那些不能被消费者成功消费并且被“拒绝”的消息队列。当队列消息达到限制、消息被拒、消息超过存活时间都会成为死信息，安排进入死信队列。</p>
</blockquote>
<p>消费失败的原因：</p>
<ul>
<li>消息被拒绝且消息没有重新入队</li>
<li>消息超时未被消费（超过设置的TTL）</li>
<li>队列满了（达到最大队列长度）</li>
</ul>
<h4 id="什么是延迟队列？"><a href="#什么是延迟队列？" class="headerlink" title="什么是延迟队列？"></a>什么是延迟队列？</h4><blockquote>
<p>延迟队列指的是存储对应的延迟消息，消息被发送之后，等待特定时间，消费者才能拿到这个消息。</p>
</blockquote>
<ul>
<li>实现方式<ul>
<li>使用死信队列 + TTL 实现。</li>
<li>高版本的 RabbitMQ 中提供了延迟队列插件</li>
</ul>
</li>
</ul>
<h3 id="🌟如何保证消息可靠性（不丢失）？"><a href="#🌟如何保证消息可靠性（不丢失）？" class="headerlink" title="🌟如何保证消息可靠性（不丢失）？"></a>🌟如何保证消息可靠性（不丢失）？</h3><blockquote>
<p>消息丢失场景：生产者 -&gt; MQ、MQ本身存储的消息、MQ -&gt; 消费者</p>
<p>三个方面来解决：<strong>生产者确认机制</strong>、<strong>消费者手动确认消息</strong>和<strong>消息持久化</strong></p>
</blockquote>
<h4 id="生产者确认机制"><a href="#生产者确认机制" class="headerlink" title="生产者确认机制"></a>生产者确认机制</h4><ul>
<li>事务机制：在一条消息发送之后会使发送端阻塞，等待RabbitMQ的回应，之后才能继续发送下一条消息（性能差）</li>
<li><strong>生产者确认机制</strong>：只要消息成功发送到交换机之后，RabbitMQ就会发送一个ack给生产者（即使消息没有Queue接收，也会发送ack），如果消息没有成功发送到交换机，就会发送一条nack消息，提示发送失败</li>
</ul>
<h4 id="路由不可达消息"><a href="#路由不可达消息" class="headerlink" title="路由不可达消息"></a>路由不可达消息</h4><blockquote>
<p>生产者确认机制 只能确保<strong>消息正确到达交换机</strong>，对于从交换机路由到queue失败的消息，就会被丢弃，导致消息丢失</p>
</blockquote>
<p>对于<strong>不可路由的消息</strong>，有两种处理方式</p>
<ul>
<li><strong>Return消息机制</strong>：提供回调函数，当消息从交换机路由到queue失败时回调这个方法（持久化或者重发） </li>
<li><strong>备份交换机</strong>：相当于是一个exchange，当消息没有匹配到queue时就自动转到备份交换机对应的queue，保证消息不丢失</li>
</ul>
<h4 id="消费者手动消息确认"><a href="#消费者手动消息确认" class="headerlink" title="消费者手动消息确认"></a>消费者手动消息确认</h4><blockquote>
<p>消费者默认采用自动ack，也就是消费者一收到消息就向MQ确认，MQ就会移除这条消息，但有可能消费者收到消息还没来得及处理时MQ就宕机了，因此采用<strong>消费者手动消息确认</strong></p>
</blockquote>
<ul>
<li>消费者处理完消费逻辑之后再给MQ回复ack，表示消息已经成功消费，可以移除</li>
<li>当消费者消费失败时，给MQ回复nack，再根据MQ配置决定消息重新入队还是移除，或者进入死信队列</li>
<li>（只要没收到消费者的确认，MQ就会一直保存这条消息，但也不会重新入队或者给其他的消费者消费）</li>
</ul>
<h4 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h4><blockquote>
<p>默认情况下，RabbitMQ的消息是不持久化的</p>
<p>内存中的消息持久化到硬盘上，即使MQ重启也不会丢失消息</p>
</blockquote>
<p>消息持久化需要满足：消息、队列、交换机全部设置了持久化</p>
<ul>
<li>当发布一条消息到交换机上时，Rabbit会<strong>先把消息写入持久化日志</strong>，然后才向生产者发送响应</li>
<li>一旦从队列中消费了一条消息的话并且做了确认，RabbitMQ会在持久化日志中移除这条消息</li>
<li>在消费消息前，如果RabbitMQ重启的话，服务器会自动重建交换机和队列，加载持久化日志中的消息到相应的队列或者交换机上，保证消息不会丢失</li>
</ul>
<h4 id="镜像队列（集群）"><a href="#镜像队列（集群）" class="headerlink" title="镜像队列（集群）"></a>镜像队列（集群）</h4><h3 id="🌟RabbitMQ如何保证高可用？"><a href="#🌟RabbitMQ如何保证高可用？" class="headerlink" title="🌟RabbitMQ如何保证高可用？"></a>🌟RabbitMQ如何保证高可用？</h3><blockquote>
<p>RabbitMQ基于<strong>主从</strong>做高可用性，有三种模式：单机、普通集群、镜像集群</p>
<p>普通集群只是提高系统吞吐量，让集群中多个节点服务某个Queue的读写操作</p>
<p>真正实现RabbitMQ高可用的是<strong>镜像集群模式</strong></p>
</blockquote>
<h4 id="普通集群"><a href="#普通集群" class="headerlink" title="普通集群"></a>普通集群</h4><blockquote>
<p>在多台机器上启动多个RabbitMQ实例，但你创建的<code>queue</code>只会放在一个实例上，但是每个实例都会同步这个queue的<strong>元数据</strong>（可以认为是queue的一些配置信息等，通过元数据可以找到queue所在的mq实例），消费的时候，如果连接到别的实例，就从queue所在实例上拉取消息过来</p>
<p>该方案主要是<strong>提高吞吐量</strong>，无法保证高可用</p>
</blockquote>
<p><img src="D:\desktop\面经高频问题.assets\image-20240412233459275.png"></p>
<h4 id="🌟镜像集群（真正高可用）"><a href="#🌟镜像集群（真正高可用）" class="headerlink" title="🌟镜像集群（真正高可用）"></a>🌟镜像集群（真正高可用）</h4><blockquote>
<p>与普通集群不一样的是，创建的<code>queue</code>，无论元数据还是消息都会存在于多个实例上</p>
<p>每次写消息到queue的时候，都会自动把消息同步到多个实例的<code>queue</code>上</p>
</blockquote>
<p><img src="D:\desktop\面经高频问题.assets\image-20240412233933375.png"></p>
<ul>
<li><strong>好处</strong><ul>
<li>任何一个节点宕机了，其他的节点还保存有<code>queue</code>的完整数据</li>
</ul>
</li>
<li><strong>坏处</strong><ul>
<li>性能消耗太大，所有节点都要进行消息同步</li>
<li>没有扩展性可言，如果一个queue负载很重，就算增加节点，新增节点还是包含所有数据，无法线性扩展</li>
</ul>
</li>
</ul>
<h3 id="如何保证不重复消费？"><a href="#如何保证不重复消费？" class="headerlink" title="如何保证不重复消费？"></a>如何保证不重复消费？</h3><blockquote>
<p>消费重复的原因有两个：生产时消息重复、消费时消息重复</p>
</blockquote>
<p>解决方法：</p>
<ul>
<li>保证消费逻辑的幂等</li>
<li>给消息加全局唯一ID，消费前查询是否消费过（可以存入 redis）</li>
</ul>
<h3 id="如何实现顺序消息？"><a href="#如何实现顺序消息？" class="headerlink" title="如何实现顺序消息？"></a>如何实现顺序消息？</h3><ol>
<li>传统 &#x2F; 简单 做法：单一消费者，缺点是并发度较高的时候效率很低</li>
</ol>
<blockquote>
<p>顺序消费和多线程本身就矛盾，多线程意义就是不在乎顺序、所以才多线程，现在既要顺序又要多线程</p>
</blockquote>
<ol start="2">
<li>解决办法：将需要保证顺序的消息放在一块，进行分组然后由单一的消费者消费相当于给单独需要保证顺序的消息加标识，放在单独的queue里由单一消费者消费，其余queue正常多线程消费</li>
<li>生产者发送消息，给每个消息指定一个特定路由键，mq会根据路由键将消息发送到不同的Exchange中，消费者通过绑定指定的队列和路由键来接受消息。</li>
</ol>
<h3 id="如何实现延迟消息？"><a href="#如何实现延迟消息？" class="headerlink" title="如何实现延迟消息？"></a>如何实现延迟消息？</h3><ol>
<li>传统 &#x2F; 简单 做法：死信队列，缺点是必须保证所有延迟消息延迟消息一致， 死信队列+TTL</li>
<li>另一种方法：本地存库，然后通过轮询来重新发送一次消息，缺点是性能上有损耗（但是更加灵活，算是取舍）</li>
</ol>
<h3 id="如何处理消息堆积？"><a href="#如何处理消息堆积？" class="headerlink" title="如何处理消息堆积？"></a>如何处理消息堆积？</h3><blockquote>
<p>原因（一般就如下两种）：消费者消费的慢、消费出现问题导致nack的消息太多</p>
</blockquote>
<p>解决办法：</p>
<ul>
<li>增加消费者（数量）</li>
<li>消费过程改为异步或多线程、增加消费者prefetch的数量（增强消费者能力）</li>
<li>新开topic，消费不了的发的新topic上，然后再单开一些消费者在这个新topic消费</li>
</ul>
<h3 id="🌟生产者生产的太多了，如何确保不把rabbitmq服务器挤爆？"><a href="#🌟生产者生产的太多了，如何确保不把rabbitmq服务器挤爆？" class="headerlink" title="🌟生产者生产的太多了，如何确保不把rabbitmq服务器挤爆？"></a>🌟生产者生产的太多了，如何确保不把rabbitmq服务器挤爆？</h3><ol>
<li>首先，先<strong>横向扩展</strong>，<strong>搭建集群</strong></li>
<li>其次，采用<strong>限流</strong>（如令牌桶、漏桶等）的方式，用<strong>redis进行缓存</strong>这些消息</li>
<li>最后，再<strong>按一定正常的速率</strong>分发给rabbitmq</li>
</ol>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="数据库引擎"><a href="#数据库引擎" class="headerlink" title="数据库引擎"></a>数据库引擎</h2><blockquote>
<p>主要就是MyISAM和InnoDB的区别</p>
<p>MyISAM适合查询以及插入为主的应用，InnoDB适合频繁修改以及涉及到安全性较高的应用</p>
</blockquote>
<ol>
<li><strong>事务支持</strong>：MyISAM不支持，InnoDB支持</li>
<li><strong>最小锁粒度</strong>：MyISAM只能添加表级锁，InnoDB支持行级锁</li>
<li>主键必需：InnoDB必需主键（没有则自己设一个隐藏的），MyISAM无必需</li>
<li>表的具体行数：MyISAM会在表里自存行数，InnoDB不会</li>
<li>外键支持：MyISAM不支持，InnoDB支持</li>
</ol>
<h2 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h2><ul>
<li><strong>第一范式1NF</strong>：确保数据库表字段的原子性。</li>
<li><strong>第二范式2NF</strong>：首先要满足第一范式，另外包含两部分内容，一是表必须有一个主键；二是非主键列必须完全依赖于主键，而不能只依赖于主键的一部分。</li>
<li><strong>第三范式3NF</strong>：首先要满足第二范式，另外非主键列必须直接依赖于主键，不能存在传递依赖。</li>
</ul>
<h2 id="🌟索引"><a href="#🌟索引" class="headerlink" title="🌟索引"></a>🌟索引</h2><h3 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h3><blockquote>
<p>索引是一种用于快速查询和检索数据的数据结构</p>
</blockquote>
<h4 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h4><ul>
<li>单列索引<ul>
<li><strong>NORMAL：</strong> <strong>普通</strong>的索引类型，完完全全相当于一本书的目录</li>
<li><strong>UNIQUE：</strong> <strong>唯一索引</strong>。一旦建立唯一索引，那么整个列中将不允许出现重复数据。每个表的主键列，都有一个特殊的唯一索引，叫做<code>Primary Key</code>，它不仅仅要求不允许出现重复，还要求不能为NULL，它还可以自动递增。每张表可以有多个唯一索引，但是只能有一个Primary索引</li>
<li><strong>SPATIAL：</strong> <strong>空间索引</strong>，空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON，不是很常用，这里不做介绍</li>
<li><strong>FULLTEXT：</strong> <strong>全文索引</strong>（MySQL 5.6 之后InnoDB才支持），它是<strong>模糊匹配</strong>的一种更好的解决方案，它的效率要比使用<code>like %</code>更高，并且它还支持多种匹配方式，灵活性也更加强大。只有字段的数据类型为 char、varchar、text 及其系列才可以建全文索引</li>
</ul>
</li>
<li>组合索引<ul>
<li>实际上就是将多行捆绑在一起，作为一个索引，它同样支持以上几种索引类型</li>
<li>注意组合索引在进行匹配时，遵循<strong>最左原则</strong></li>
</ul>
</li>
</ul>
<h4 id="索引方法"><a href="#索引方法" class="headerlink" title="索引方法"></a>索引方法</h4><blockquote>
<p>索引方法不是类型，它是实现上述索引类型的具体<strong>底层实现</strong>，主要有 **hash **和 <strong>b+tree</strong></p>
</blockquote>
<h4 id="explain关键字"><a href="#explain关键字" class="headerlink" title="explain关键字"></a>explain关键字</h4><blockquote>
<p>分析select查询语句到底有没有通过索引进行匹配</p>
</blockquote>
<p>主要关心字段：</p>
<ul>
<li><strong>type</strong>：MySQL决定如何查找对应的记录，效率从高到低：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all</li>
<li><strong>possible_keys</strong>：执行查询时可能会用到的索引</li>
<li><strong>key</strong>：实际使用的索引</li>
<li><strong>rows</strong>：扫描的行数</li>
</ul>
<h3 id="🌟聚簇索引与非聚簇索引的区别？"><a href="#🌟聚簇索引与非聚簇索引的区别？" class="headerlink" title="🌟聚簇索引与非聚簇索引的区别？"></a>🌟聚簇索引与非聚簇索引的区别？</h3><blockquote>
<p>聚簇索引不是一种新的索引，而是而是一种数据存储方式</p>
<p>聚簇表示数据行和相邻的键值紧凑地存储在一起</p>
</blockquote>
<ul>
<li>主键索引(聚簇索引)：<ul>
<li>叶子节点存储的是实际的数据。</li>
</ul>
</li>
<li>二级索引(非聚簇索引)：<ul>
<li>叶子节点存储的是主键的值。</li>
<li>查询的时候大概率需要回表操作，拿着找到的主键去主键索引找到实际的数据。</li>
</ul>
</li>
</ul>
<p>可以这么说：</p>
<ul>
<li>索引的数据结构是树，聚簇索引的索引和数据存储在一棵树上，树的叶子节点就是数据，非聚簇索引索引和数据不在一棵树上</li>
<li>聚簇索引：物理存储按照索引排序；非聚集索引：物理存储不按照索引排序</li>
<li>由于上述排序，因此聚簇索引一个表中只能拥有一个聚簇索引，而非聚簇索引一个表可以存在多个</li>
</ul>
<h3 id="回表是什么？"><a href="#回表是什么？" class="headerlink" title="回表是什么？"></a>回表是什么？</h3><blockquote>
<p>特指在<strong>使用非聚簇索引（辅助索引）执行查询</strong>时，需要根据索引查找到的主键值，<strong>返回到对应的聚簇索引中</strong>去获取完整的数据行的过程，它比基于聚簇索引（主键索引）的查询多扫描了一棵树，这个过程就叫<strong>回表</strong></p>
</blockquote>
<h3 id="什么时候需要-不需要创建索引？（创建索引注意什么？）"><a href="#什么时候需要-不需要创建索引？（创建索引注意什么？）" class="headerlink" title="什么时候需要 &#x2F; 不需要创建索引？（创建索引注意什么？）"></a>什么时候需要 &#x2F; 不需要创建索引？（创建索引注意什么？）</h3><ol>
<li>索引建立在<strong>频繁查询</strong>，而不是<strong>频繁增删改</strong>的字段上（索引提高查询效率，但有所降低增删改效率，因为需要动态维护索引）</li>
<li>控制索引的数量</li>
<li>不要在<strong>低区分度</strong>的字段上创建索引，且<strong>创建组合索引时把区分度高的字段放在前面</strong></li>
<li>不使用<strong>无序</strong>的值作为索引，推荐有<strong>唯一</strong>性的作为索引</li>
</ol>
<h3 id="有什么索引优化的方法？（也可以说上面的）"><a href="#有什么索引优化的方法？（也可以说上面的）" class="headerlink" title="有什么索引优化的方法？（也可以说上面的）"></a>有什么索引优化的方法？（也可以说上面的）</h3><ul>
<li>前缀索引优化</li>
<li>覆盖索引优化（<strong>索引包含查询所需全部列</strong>）</li>
<li>主键最好是自增的</li>
<li>防止索引失效（失效情况见下）</li>
</ul>
<h3 id="索引失效都有哪些情况？"><a href="#索引失效都有哪些情况？" class="headerlink" title="索引失效都有哪些情况？"></a>索引失效都有哪些情况？</h3><ul>
<li>使用<strong>左或者左右模糊匹配</strong>时，也就是<code>like %xx</code>、<code>like %xx%</code>（百分号只在右边不会失效）</li>
<li>查询条件中<strong>对索引列做了计算 &#x2F; 函数运算</strong></li>
<li>联合索引时未遵循<strong>最左匹配原则</strong></li>
<li>where查询时，<strong>索引列 or 非索引列</strong></li>
</ul>
<h4 id="最左前缀法则"><a href="#最左前缀法则" class="headerlink" title="最左前缀法则"></a>最左前缀法则</h4><p>如果索引关联了多列（联合索引），要遵守最左前缀法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。<br>如果跳跃某一列，索引将部分失效（后面的字段索引失效）。</p>
<p>联合索引中，出现范围查询（&lt;, &gt;），范围查询<strong>右侧的列索引失效。</strong>可以用&gt;&#x3D;或者&lt;&#x3D;来规避索引失效问题。</p>
<h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><p><font style="color:rgb(59, 67, 81);">在 MySQL 5.6 之前，只能从 字段 开始一个个回表。到主键索引上找出数据行，再对比字段值。</font></p>
<p><font style="color:rgb(59, 67, 81);">而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</font></p>
<p><strong><font style="color:rgb(77, 77, 76);background-color:rgb(247, 247, 247);">select</font></strong><font style="color:rgb(171, 86, 86);background-color:rgb(247, 247, 247);">*</font><strong><font style="color:rgb(77, 77, 76);background-color:rgb(247, 247, 247);">from</font></strong><font style="color:rgb(77, 77, 76);background-color:rgb(247, 247, 247);"> user </font><strong><font style="color:rgb(77, 77, 76);background-color:rgb(247, 247, 247);">where</font></strong><font style="color:rgb(77, 77, 76);background-color:rgb(247, 247, 247);"> name </font><strong><font style="color:rgb(77, 77, 76);background-color:rgb(247, 247, 247);">like</font></strong><font style="color:rgb(136, 0, 0);background-color:rgb(247, 247, 247);">‘张 %’</font><strong><font style="color:rgb(77, 77, 76);background-color:rgb(247, 247, 247);">and</font></strong><font style="color:rgb(77, 77, 76);background-color:rgb(247, 247, 247);"> age</font><font style="color:rgb(171, 86, 86);background-color:rgb(247, 247, 247);">&#x3D;</font><font style="color:rgb(136, 0, 0);background-color:rgb(247, 247, 247);">10</font><strong><font style="color:rgb(77, 77, 76);background-color:rgb(247, 247, 247);">and</font></strong><font style="color:rgb(77, 77, 76);background-color:rgb(247, 247, 247);"> ismale</font><font style="color:rgb(171, 86, 86);background-color:rgb(247, 247, 247);">&#x3D;</font><font style="color:rgb(136, 0, 0);background-color:rgb(247, 247, 247);">1</font><font style="color:rgb(77, 77, 76);background-color:rgb(247, 247, 247);">; 索引为（name,age）</font></p>
<p><font style="color:rgb(59, 67, 81);">5.6之前，这个过程 InnoDB 并不会去看 age 的值，只是按顺序把“name 第一个字是’张’”的记录一条条取出来回表。因此，需要回表 4 次。</font></p>
<p><font style="color:rgb(59, 67, 81);">5.6之后，InnoDB 在 (name,age) 索引内部就判断了 age 是否等于 10，对于不等于 10 的记录，直接判断并跳过。在我们的这个例子中，只需要对 ID4、ID5 这两条记录回表取数据判断，就只需要回表 2 次。</font></p>
<h3 id="为什么MySQL要采用B-树作为在-MySQL-5-6-之前，只能从-ID3-开始一个个回表。到主键索引上找出数据行，再对比字段值。"><a href="#为什么MySQL要采用B-树作为在-MySQL-5-6-之前，只能从-ID3-开始一个个回表。到主键索引上找出数据行，再对比字段值。" class="headerlink" title="为什么MySQL要采用B+树作为在 MySQL 5.6 之前，只能从 ID3 开始一个个回表。到主键索引上找出数据行，再对比字段值。"></a>为什么MySQL要采用B+树作为<font style="color:rgb(59, 67, 81);">在 MySQL 5.6 之前，只能从 ID3 开始一个个回表。到主键索引上找出数据行，再对比字段值。</font></h3><p><font style="color:rgb(59, 67, 81);">而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</font></p>
<h3 id="默认索引底层结构？（对比B-Tree-B-Tree-二叉树-hash）"><a href="#默认索引底层结构？（对比B-Tree-B-Tree-二叉树-hash）" class="headerlink" title="默认索引底层结构？（对比B+Tree&#x2F;B Tree&#x2F;二叉树&#x2F;hash）"></a>默认索引底层结构？（对比B+Tree&#x2F;B Tree&#x2F;二叉树&#x2F;hash）</h3><blockquote>
<p>B+ 树非叶子节点仅存储索引，所有数据都在叶子节点</p>
<p>B 树 每个节点都可以存索引和数据</p>
</blockquote>
<ul>
<li><strong>B+Tree vs B Tree</strong>：<ul>
<li>存储相同数据量的情况下，B+Tree树高度比B Tree低，磁盘I&#x2F;O次数更少</li>
<li>B+Tree叶子节点用双向链表串起来，适合范围查询，B Tree无法做到</li>
</ul>
</li>
<li><strong>B+Tree vs 二叉树</strong><ul>
<li>随着数据量的增加，二叉树高度越来越高，磁盘I&#x2F;O次数也更多，B+Tree在千万级数据量下，高度依然保持在3-4层</li>
</ul>
</li>
<li><strong>B+Tree vs Hash</strong><ul>
<li>Hash 等值查询效率巨高（近乎O(1)），但是无法做范围查询</li>
</ul>
</li>
</ul>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><blockquote>
<p>注意：InnoDB支持事务、MyISAM不支持</p>
</blockquote>
<h3 id="介绍一下事务四大特效，再说说什么靠什么保证的？"><a href="#介绍一下事务四大特效，再说说什么靠什么保证的？" class="headerlink" title="介绍一下事务四大特效，再说说什么靠什么保证的？"></a>介绍一下事务四大特效，再说说什么靠什么保证的？</h3><ul>
<li>A原子性：要么都做，要么都不做（通过**undo log(回滚日志)**保证）</li>
<li>C一致性：事务操作前后，数据库保持一致性状态</li>
<li>I隔离性：多个事务并发互不影响（通过<strong>MVCC</strong>或者<strong>锁机制</strong>保证）</li>
<li>D持久性：事务提交后，对数据的修改是永久的（通过**redo log(重做机制)**保证）</li>
</ul>
<h3 id="并发事务会引发什么问题？"><a href="#并发事务会引发什么问题？" class="headerlink" title="并发事务会引发什么问题？"></a>并发事务会引发什么问题？</h3><ul>
<li>脏读：读到其他事务<strong>未提交的数据</strong>、</li>
<li>不可重复读：前后<strong>读取的数据不一致</strong></li>
<li>幻读：前后读取的<strong>记录数量不一致</strong><ul>
<li>针对<strong>快照读</strong>（普通select语句）：通过<strong>MVCC</strong>方式解决幻读</li>
<li>针对<strong>当前读</strong>（select···for update语句）：通过<strong>next-key lock（记录锁+间隙锁）</strong>解决幻读</li>
</ul>
</li>
</ul>
<h3 id="事务隔离级别？"><a href="#事务隔离级别？" class="headerlink" title="事务隔离级别？"></a>事务隔离级别？</h3><ul>
<li><strong>UNCOMMITTED</strong>：<strong>读未提交</strong>，可以读取到未提交的数据变更，会导致脏读、幻读、不可重复读。</li>
<li><strong>COMMITTED</strong>：<strong>读已提交</strong>，允许读取到事务已经提交的数据，可以阻止脏读，但是幻读、不可重复读还是会发生。</li>
<li><strong>REPEATABLE-READ：可重复读</strong>，对同一个字段多次读取都是一样的结果，无法避免幻读。</li>
<li><strong>REPEATABLE-READ：可串行化</strong>，最高隔离级别，完全服从 ACID 原则。</li>
</ul>
<h3 id="🌟MVCC"><a href="#🌟MVCC" class="headerlink" title="🌟MVCC"></a>🌟MVCC</h3><blockquote>
<p>多版本并发控制，用于解决并发访问下的读一致性问题，它通过维护数据的历史版本来实现</p>
<p>几个关键点：<strong>隐藏字段</strong>、<strong>undo日志</strong>、<strong>版本链</strong>、<strong>快照读和当前读</strong>、<strong>Read View</strong></p>
</blockquote>
<h4 id="快照读和当前读"><a href="#快照读和当前读" class="headerlink" title="快照读和当前读"></a>快照读和当前读</h4><ul>
<li><strong>快照读</strong>，读取的是记录的可见版本 (有可能是历史版本)，不用加锁</li>
<li><strong>当前读</strong>，读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录</li>
</ul>
<p><a href="!%5B%E9%9A%90%E8%97%8F%E5%AD%97%E6%AE%B5%E4%BD%9C%E7%94%A8%5D(https://nruonan.github.io/2024/04/17/mysql/%E9%9A%90%E8%97%8F%E5%AD%97%E6%AE%B5.png">image-20240413172456228</a></p>
<h3 id="Read-View"><a href="#Read-View" class="headerlink" title="Read View"></a>Read View</h3><p>ReadView(读视图)是快照读SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id。</p>
<p><img src="https://nruonan.github.io/2024/04/17/mysql/%E5%AD%97%E6%AE%B5.png"></p>
<p>以上四个重要字段：（都是创建该Read View时的数据）</p>
<ol>
<li><strong>活跃且未提交</strong>的事务id列表</li>
<li>活跃且未提交事务中ID最小的事务（也就是最先的）</li>
<li>下一个应该赋的事务ID（也就是最大事务ID+1）</li>
<li>创建该Read View的事务ID</li>
</ol>
<h4 id="隐藏列"><a href="#隐藏列" class="headerlink" title="隐藏列"></a>隐藏列</h4><p>隐藏列包含两个：</p>
<ol>
<li>trx_id：操作该行数据的事务ID</li>
<li>roll_ptr：历史版本信息指针（指向旧版本记录）</li>
</ol>
<h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><p><img src="https://nruonan.github.io/2024/04/17/mysql/%E8%A7%84%E5%88%99.png"></p>
<p>一个事务去访问记录的时候，除了自己更新的总是可见之外，还有以下情况：</p>
<ul>
<li>如果该记录的事务ID，<strong>小于Read View中的活跃且未提交的最小事务ID</strong>，表示这个版本的记录是在创建Read View之前已经提交的事务生成的，则该版本记录对当前事务<strong>可见</strong></li>
<li>如果该记录的事务ID，<strong>大于Read View中的活跃且未提交的最大事务ID</strong>，表示这个版本的记录是在创建Read View之后才启动的事务生成的，所以该版本记录对当前事务<strong>不可见</strong></li>
<li>如果记录的事务ID，在<code>min_trx_id</code>和<code>max_trx_id</code>之间，需要判断该记录id是否在<strong>活跃且未提交事务列表</strong>中<ul>
<li>如果<strong>存在</strong>，那么表示生成该版本记录的活跃事务仍未提交，所以该版本记录对当前事务<strong>不可见</strong></li>
<li>如果<strong>不在</strong>，那么表示生成该版本记录的活跃事务已经提交，所以该版本记录对当前事务<strong>可见</strong></li>
</ul>
</li>
</ul>
<p><strong>这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）</strong></p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="🌟InnoDB里的行锁"><a href="#🌟InnoDB里的行锁" class="headerlink" title="🌟InnoDB里的行锁"></a>🌟InnoDB里的行锁</h3><blockquote>
<p>InnoDB是支持行级锁的，而MyISAM并不支持行级锁</p>
<p>InnoDB的<strong>行锁是基于索引</strong>的，而不是基于整个表。这意味着<strong>只有在通过索引访问数据时，InnoDB才会使用行级锁</strong>。如果没有合适的索引，InnoDB会使用表级锁</p>
<p><strong>表级锁是基于非索引字段加的锁</strong>，对当前操作的整张表加锁，实现简单，表级锁和存储引擎无关，MyISAM 和 InnoDB 引擎都支持表级锁。</p>
</blockquote>
<h4 id="行锁的类型？"><a href="#行锁的类型？" class="headerlink" title="行锁的类型？"></a>行锁的类型？</h4><blockquote>
<p>共享锁（S锁）——读读共享、读写互斥（<code>select ··· lock in share mode</code>对读取的记录加共享锁）</p>
<p>独占锁（X锁）——写写互斥、读写互斥（<code>select ··· for update</code>对读取的记录加独占锁）</p>
</blockquote>
<h5 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h5><blockquote>
<p>Record Lock，也就是仅仅锁住一条记录，有S锁和X锁之分</p>
</blockquote>
<ul>
<li>当一个事务对一条记录<strong>加了S型记录锁</strong>，其他事务<strong>可以继续加S，但不能加X</strong></li>
<li>当一个事务对一条记录<strong>加了X型记录锁</strong>，其他事务<strong>不能加S，也不能加X</strong></li>
<li>当事务commit之后，所有加的锁都会释放</li>
</ul>
<h5 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h5><blockquote>
<p>Gap Lock，<strong>只存在于可重复读隔离级别，目的是为了解决可重复读级别下幻读的现象</strong></p>
</blockquote>
<p>假设，表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id &#x3D; 4 这条记录了，这样就有效的防止幻读现象的发生</p>
<h5 id="临键锁"><a href="#临键锁" class="headerlink" title="临键锁"></a>临键锁</h5><blockquote>
<p>Next-Key Lock，是<strong>记录锁+间隙锁的组合，锁定一个范围，并且锁定记录本身</strong></p>
</blockquote>
<p>假设，表中有一个范围 id 为（3，5] 的 next-key lock，那么其他事务即不能插入 id &#x3D; 4 记录，也不能修改和删除 id &#x3D; 5 这条记录</p>
<p><strong>next-key lock 是包含间隙锁+记录锁</strong>的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的</p>
<h3 id="MySQL是怎么加行锁的？"><a href="#MySQL是怎么加行锁的？" class="headerlink" title="MySQL是怎么加行锁的？"></a>MySQL是怎么加行锁的？</h3><blockquote>
<p>总结一句，<strong>在能使用记录锁或者间隙锁就能避免幻读现象的场景下， next-key lock 就会退化成记录锁或间隙锁</strong></p>
</blockquote>
<p><strong>加锁的对象是索引，加锁的基本单位是 next-key lock</strong>，它是由记录锁和间隙锁组合而成的，<strong>next-key lock 是前开后闭区间，而间隙锁是前开后开区间</strong></p>
<h3 id="MDL表锁"><a href="#MDL表锁" class="headerlink" title="MDL表锁"></a>MDL表锁</h3><p><font style="color:rgb(59, 67, 81);">当对一个表做增删改查操作的时候，加 MDL 读锁；</font></p>
<p><font style="color:rgb(59, 67, 81);">当要对表做结构变更操作的时候，加 MDL 写锁。</font></p>
<ul>
<li><font style="color:rgb(59, 67, 81);">读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。</font></li>
<li><font style="color:rgb(59, 67, 81);">读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</font></li>
</ul>
<h3 id="MySQL死锁是怎么回事？如何避免？"><a href="#MySQL死锁是怎么回事？如何避免？" class="headerlink" title="MySQL死锁是怎么回事？如何避免？"></a>MySQL死锁是怎么回事？如何避免？</h3><blockquote>
<p> 死锁的四个经典条件：互斥、请求和保持、不可抢占、循环等待</p>
</blockquote>
<p>死锁情况有几种：</p>
<ul>
<li>记录锁：事务A锁了记录a还想锁b，事务B锁了记录b还需要a，此时死锁</li>
<li>间隙锁：两个或多个事务对同一区间加间隙锁，其中一个事务需要执行insert，此时陷入死锁</li>
</ul>
<p>如何解决？</p>
<ul>
<li>直接进入等待，直到超时释放锁</li>
<li>回滚死锁链条中的某一个事务（持有最少行锁的事务进行回滚）</li>
</ul>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="介绍一下都有哪些日志？"><a href="#介绍一下都有哪些日志？" class="headerlink" title="介绍一下都有哪些日志？"></a>介绍一下都有哪些日志？</h3><ul>
<li><strong>bin log</strong>：记录数据库的所有DDL语句（数据定义语言）和 DML语句（数据操作语言），但不包括SELECT语句，以二进制格式记录，可以用于数据恢复、主从复制以及数据变更的回放</li>
</ul>
<p>对于InnoDB存储引擎，还有以下两种特有的日志文件：</p>
<ul>
<li><strong>redo log</strong>（重做日志）：用于保证数据库的事务持久性和崩溃恢复能力。当事务提交时，相关的修改操作会首先被记录到重做日志中，然后才会写入磁盘</li>
<li><strong>undo log</strong>（回滚日志）：用于支持事务的回滚操作。在事务执行期间，对数据的修改操作会同时被记录到回滚日志中，以便在事务回滚时恢复数据到修改之前的状态</li>
</ul>
<h3 id="更新语句-UPDATE-t-user-SET-name-‘xiaolin’-WHERE-id-1-的执行过程？"><a href="#更新语句-UPDATE-t-user-SET-name-‘xiaolin’-WHERE-id-1-的执行过程？" class="headerlink" title="更新语句 UPDATE t_user SET name &#x3D; ‘xiaolin’ WHERE id &#x3D; 1; 的执行过程？"></a>更新语句 UPDATE t_user SET name &#x3D; ‘xiaolin’ WHERE id &#x3D; 1; 的执行过程？</h3><ol>
<li>执行器负责具体的执行，会调用存储引擎的接口，通过主键索引树搜索获取 id &#x3D; 1 这一行记录：<ul>
<li>如果 id&#x3D;1 这一行所在的数据页本来就在缓冲池中，就直接返回给执行器更新；</li>
<li><pre><code>如果记录不在缓冲池，就将数据页从磁盘读入到缓冲池，返回记录给执行器。
</code></pre>
</li>
</ul>
</li>
<li>执行器得到聚簇索引记录后，会检查更新前的记录和更新后的记录是否一样：<ul>
<li>如果一样，就不进行后续更新流程；</li>
<li>如果不一样，就把更新前和更新后的记录都作为参数传给 InnoDB 层，让 InnoDB 真正执行更新记录的操作；</li>
</ul>
</li>
<li>开启事务，InnoDB 层在更新记录前，首先要记录相应的 undo log，因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入缓冲池中的 Undo 页面。不过在内存修改该 Undo 页面后，需要记录对应的 redo log。</li>
<li>InnoDB 层开始更新记录时，会先更新内存（同时标记为脏页），然后将记录写到 redo log 里面，这个时候更新就算完成了。为了减少磁盘 I&#x2F;O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。这就是 <strong>WAL</strong> 技术，MySQL 的写操作并不是立刻写到磁盘上，而是先写 redo 日志，然后在合适的时间再将修改的行数据写到磁盘上。</li>
<li>至此，一条记录更新完了。</li>
<li>在一条更新语句执行完成后，开始记录该语句对应的 binlog，此时记录的 binlog 会被保存到 binlog 缓存，并没有刷新到硬盘上的 binlog 文件，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。</li>
<li>事务提交（为了方便说明，这里不说组提交的过程，只说两阶段提交）：<ul>
<li>prepare 阶段：将 redo log 对应的事务状态设置为 prepare，然后将 redo log 刷新到硬盘；</li>
<li>commit 阶段：将 binlog 刷新到磁盘，接着调用引擎的提交事务接口，将 redo log 状态设置为 commit（将事务设置为 commit 状态后，刷入到磁盘 redo log 文件）；</li>
</ul>
</li>
<li>至此，一条更新语句执行完成。</li>
</ol>
<h3 id="为什么要二阶段提交？"><a href="#为什么要二阶段提交？" class="headerlink" title="为什么要二阶段提交？"></a>为什么要二阶段提交？</h3><blockquote>
<p>简单说，redo log和bin log都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致</p>
</blockquote>
<p>如果采用“单阶段”进行提交，即要么先写 入redo log，后写入binlog；要么先写入binlog，后写入redo log。这两种方式的提交都会导致原先数据库的状态和被恢复后的数据库的状态不一致。</p>
<h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><h3 id="什么是读写分离-主从复制？"><a href="#什么是读写分离-主从复制？" class="headerlink" title="什么是读写分离  &#x2F; 主从复制？"></a>什么是读写分离  &#x2F; 主从复制？</h3><blockquote>
<p>数据库主机负责读写操作，从机只负责读操作</p>
<p>  主机通过复制将数据同步到从机，每个数据库都存储了所有的业务数据</p>
</blockquote>
<p><img src="D:\desktop\面经高频问题.assets\image-20240402002641794.png"></p>
<h3 id="主从复制原理是什么？"><a href="#主从复制原理是什么？" class="headerlink" title="主从复制原理是什么？"></a>主从复制原理是什么？</h3><p><img src="D:\desktop\面经高频问题.assets\image-20240402002325792.png"></p>
<h3 id="如何进行在线转移-在线扩容？"><a href="#如何进行在线转移-在线扩容？" class="headerlink" title="如何进行在线转移 &#x2F; 在线扩容？"></a>如何进行在线转移 &#x2F; 在线扩容？</h3><ol>
<li>在线双写，查询走老库<ul>
<li>数据写入旧库的同时，也写入新库</li>
<li>并且同时将旧库中的历史数据迁移到新库</li>
<li>新旧库数据对比 把差异补齐</li>
</ul>
</li>
<li>在线双写，查询走新库<ul>
<li>完成了历史数据的同步和校验</li>
<li>把对数据的读切换到新库</li>
</ul>
</li>
<li>旧库下线<ul>
<li>旧库不再写入新的数据</li>
<li>经过一段时间后，确定旧库没有请求，下线旧库</li>
</ul>
</li>
</ol>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h2><h3 id="Redis都有什么数据结构？"><a href="#Redis都有什么数据结构？" class="headerlink" title="Redis都有什么数据结构？"></a>Redis都有什么数据结构？</h3><ul>
<li><strong>string 字符串</strong>： 基于 SDS 动态字符串组成，通过动态调整长度节省内存。</li>
<li><strong>hash 哈希</strong>：基于数组 + 链表实现的键值对映射表，kv 都是 String 类型。</li>
<li><strong>list 列表</strong>：基于双向链表实现。</li>
<li><strong>set 集合</strong>：和 java 的 Set 一样，元素不可重复，提供交集、并集等操作。</li>
<li><strong>zset 有序集合</strong>：相比于 Set 类型，提供了权重参数，可以进行排序，还可以范围查找。</li>
<li><strong>Bitmap</strong>：存储了连续的二进制数字(01010101100)，因为8 个 bit 可以组成一个 byte，所以能节省很大的存储空间。</li>
<li><strong>HyperLoglog</strong>：数据量巨大的技术场景(百万级以上)。</li>
<li><strong>Geospatial</strong>：GEO，地理位置类型，存储了地理位置坐标，基于 Sorted Set 实现，可以完成附近的人功能。</li>
</ul>
<h3 id="Redis可以用来干什么？"><a href="#Redis可以用来干什么？" class="headerlink" title="Redis可以用来干什么？"></a>Redis可以用来干什么？</h3><ol>
<li>🌟<strong>缓存</strong>：最广泛的应用，降低数据库压力 提高响应速度</li>
<li><strong>计数器</strong>：Redis天然支持计数功能，并且性能好 项目里的<strong>固定窗口计数器</strong>限流便是基于Redis</li>
<li>排行榜：Redis提供了列表和有序集合数据结构，合理地使用这些数据结构可以很方便地构建各种排行榜系统</li>
<li>分布式锁</li>
<li><strong>存储验证码</strong>：项目里需要验证的手机 &#x2F; 邮箱 验证码 存储在Redis里 验证后删除</li>
</ol>
<h3 id="Redis为什么这么快？"><a href="#Redis为什么这么快？" class="headerlink" title="Redis为什么这么快？"></a>Redis为什么这么快？</h3><ul>
<li>完全<strong>基于内存</strong></li>
<li>🌟<strong>单线程操作</strong>：单线程方式处理客户端请求，避免多线程的上下文切换和竞争的开销</li>
<li>非阻塞的<strong>I&#x2F;O多路复用</strong>机制：一个线程监听多个客户端连接</li>
<li><strong>优化的数据结构</strong>：哈希表、跳表、压缩列表等</li>
</ul>
<h3 id="Redis为什么选择单线程？"><a href="#Redis为什么选择单线程？" class="headerlink" title="Redis为什么选择单线程？"></a>Redis为什么选择单线程？</h3><blockquote>
<p>核心原因：CPU并不是制约Redis的性能表现的瓶颈所在，更多情况下是受到内存大小和网络I&#x2F;O的限制</p>
<p>并且使用多线程，也增加了系统复杂度、线程切换的开销等</p>
</blockquote>
<h3 id="Redis6-0之后为什么又引入了多线程？"><a href="#Redis6-0之后为什么又引入了多线程？" class="headerlink" title="Redis6.0之后为什么又引入了多线程？"></a>Redis6.0之后为什么又引入了多线程？</h3><blockquote>
<p>在 Redis 6.0 版本之后，也<strong>采用了多个 I&#x2F;O 线程来处理网络请求</strong>，这是因为随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在网络 I&#x2F;O 的处理上</p>
<p><strong>但是对于命令的执行，Redis 仍然使用单线程来处理</strong></p>
</blockquote>
<h2 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="🌟🌟🌟跳跃表是如何实现的？原理？"><a href="#🌟🌟🌟跳跃表是如何实现的？原理？" class="headerlink" title="🌟🌟🌟跳跃表是如何实现的？原理？"></a>🌟🌟🌟跳跃表是如何实现的？原理？</h3><blockquote>
<p>Redis 只有 Zset 对象的底层实现用到了跳表，跳表的优势是能支持平均 O(logN) 复杂度的节点查找</p>
<p>zset 结构体里有两个数据结构：一个是跳表，一个是哈希表。这样的好处是既能进行高效的范围查询，也能进行高效单点查询</p>
</blockquote>
<h4 id="跳表结构设计"><a href="#跳表结构设计" class="headerlink" title="跳表结构设计"></a>跳表结构设计</h4><p>一个跳跃表应该有若干个层（Level）链表组成；</p>
<p>跳跃表中最底层的链表包含所有数据； 每一层链表中的数据都是有序的；</p>
<p>如果一个元素 X 出现在第i层，那么编号比 i 小的层都包含元素 X；</p>
<p>第 i 层的元素通过一个指针指向下一层拥有相同值的元素；</p>
<p>在每一层中，-∞ 和 +∞ 两个元素都出现(分别表示 INT_MIN 和 INT_MAX)；</p>
<p>头指针（head）指向最高一层的第一个元素；</p>
<h4 id="跳表节点查询过程"><a href="#跳表节点查询过程" class="headerlink" title="跳表节点查询过程"></a>跳表节点查询过程</h4><p>查找一个跳表节点的过程时，跳表会从头节点的最高层开始，逐一遍历每一层。在遍历某一层的跳表节点时，会用跳表节点中的 SDS 类型的元素和元素的权重来进行判断，共有两个判断条件：</p>
<ul>
<li>如果当前节点的权重「小于」要查找的权重时，跳表就会访问该层上的下一个节点</li>
<li>如果当前节点的权重「等于」要查找的权重时，并且当前节点的 SDS 类型数据「小于」要查找的数据时，跳表就会访问该层上的下一个节点</li>
</ul>
<p>如果上面两个条件都不满足，或者下一个节点为空时，跳表就会使用目前遍历到的节点的 level 数组里的下一层指针，然后沿着下一层指针继续查找，这就相当于跳到了下一层接着查找</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/3%E5%B1%82%E8%B7%B3%E8%A1%A8-%E8%B7%A8%E5%BA%A6.drawio.png"></p>
<h4 id="跳表节点层数设置"><a href="#跳表节点层数设置" class="headerlink" title="跳表节点层数设置"></a>跳表节点层数设置</h4><blockquote>
<p><strong>跳表的相邻两层的节点数量最理想的比例是 2:1，查找复杂度可以降低到 O(logN)</strong></p>
</blockquote>
<h4 id="为什么用跳表而不用平衡树？"><a href="#为什么用跳表而不用平衡树？" class="headerlink" title="为什么用跳表而不用平衡树？"></a>为什么用跳表而不用平衡树？</h4><ul>
<li>从内存占用上来比较，跳表比平衡树更灵活一些</li>
<li>在做范围查找的时候，跳表比平衡树操作要简单</li>
<li>从算法实现难度上来比较，跳表比平衡树要简单得多</li>
</ul>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h3 id="Redis持久化方式了解吗？"><a href="#Redis持久化方式了解吗？" class="headerlink" title="Redis持久化方式了解吗？"></a>Redis持久化方式了解吗？</h3><ul>
<li><strong>RDB快照</strong>：将某一时刻的内存数据，以二进制文件的方式写入磁盘</li>
<li><strong>AOF日志</strong>：每执行一条写操作命令，就把该命令以追加的方式写入到一个日志文件里</li>
<li><strong>混合持久化</strong>：AOF + RDB</li>
</ul>
<h3 id="RDB和AOF各自原理？"><a href="#RDB和AOF各自原理？" class="headerlink" title="RDB和AOF各自原理？"></a>RDB和AOF各自原理？</h3><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><blockquote>
<p>RDB文件是一个压缩的<strong>二进制文件</strong>，保存在硬盘上，通过它可以还原某个时刻Redis数据库的状态</p>
</blockquote>
<ul>
<li>RDB持久化是把当前进程数据生成 <strong>快照</strong> 保存到硬盘的过程，触发RDB持久化分为 手动 和 自动<ul>
<li>手动触发<br>  <img src="D:\desktop\面经高频问题.assets\image-20240410231303536.png"></li>
<li>自动触发<ul>
<li><strong>save配置</strong>：在Redis的配置文件中可以配置save命令，指定触发RDB持久化的条件如<code>save 900 1</code>表示在900s内如果有至少一个键被修改，则自动触发一次bgsave</li>
<li><strong>从节点执行全量复制</strong>：主节点自动执行bgsave命令生成RDB文件发送给从节点</li>
<li><strong>关闭Redis服务器</strong>：Redis服务器关闭时，如果没有开启AOF持久化则自动执行bgsave</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><blockquote>
<p>以独立日志的方式记录<strong>每次写命令</strong>，重启时再重新执行AOF文件中的命令达到恢复数据的目的</p>
<p>解决了Redis数据持久化的<strong>实时性</strong></p>
</blockquote>
<ul>
<li>AOF的工作流程操作</li>
</ul>
<h4 id="fsync-策略"><a href="#fsync-策略" class="headerlink" title="fsync 策略"></a>fsync 策略</h4><h4 id="为什么-AOF-是执行完命令之后再记录？"><a href="#为什么-AOF-是执行完命令之后再记录？" class="headerlink" title="为什么 AOF 是执行完命令之后再记录？"></a>为什么 AOF 是执行完命令之后再记录？</h4><h4 id="文件重写机制"><a href="#文件重写机制" class="headerlink" title="文件重写机制"></a>文件重写机制</h4><pre><code>1. **命令追加（append）**：所有的写命令会追加到 AOF 缓冲区中。
2. **文件写入（write）**：将 AOF 缓冲区的数据写入到 AOF 文件中。这一步需要调用`write`函数（系统调用），`write`将数据写入到了系统内核缓冲区之后直接返回了（延迟写）。注意！！！此时并没有同步到磁盘。
3. **文件同步（fsync）**：AOF 缓冲区根据对应的持久化方式（ `fsync` 策略）向硬盘做同步操作。这一步需要调用 `fsync` 函数（系统调用）， `fsync` 针对单个文件操作，对其进行强制硬盘同步，`fsync` 将阻塞直到写入磁盘完成后返回，保证了数据持久化。
4. **文件重写（rewrite）**：随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的。
5. **重启加载（load）**：当 Redis 重启时，可以加载 AOF 文件进行数据恢复。
- always：进行 write 操作之后，马上执行 fsync 进行刷盘。
- everysec：write 操作之后，后台线程每秒调用 fsync 同步一次。
- no：write 操作之后，由系统决定何时刷盘，通常是 30s 一次。
- 避免额外的开销，AOF 日志不会进行语法检查。
- 不会阻塞当前命令执行。
- 当 AOF 文件变得太大的时候，后台会自动重写 AOF 文件，从而产生一个新的 AOF 文件，保存的数据一致，但是体积更小。
- 重写期间，Redis 会维护一个 AOF 重写缓冲区，用于重写期间，新的写命令将会从缓冲区中获取追加到新文件末尾，以完成数据一致性。
</code></pre>
<h3 id="RDB和AOF如何选择？（各自优缺点）"><a href="#RDB和AOF如何选择？（各自优缺点）" class="headerlink" title="RDB和AOF如何选择？（各自优缺点）"></a>RDB和AOF如何选择？（各自优缺点）</h3><h4 id="RDB-1"><a href="#RDB-1" class="headerlink" title="RDB"></a>RDB</h4><ul>
<li>优点<ul>
<li>只有一个<strong>紧凑</strong>的二进制文件<code>dump.rdb</code>，非常适合<strong>备份、全量复制</strong>的场景</li>
<li><strong>容灾性好</strong>，可以把RDB文件拷贝到远端机器或者文件系统中，用于容灾恢复</li>
<li><strong>恢复速度快</strong>，RDB恢复数据的速度远远快于AOF</li>
</ul>
</li>
<li>缺点<ul>
<li><strong>实时性低</strong>，RDB是间隔一段时间进行，没法做到实时持久化，如果在间隔内发生故障，数据会丢失</li>
</ul>
</li>
</ul>
<h4 id="AOF-1"><a href="#AOF-1" class="headerlink" title="AOF"></a>AOF</h4><ul>
<li>优点<ul>
<li><strong>实时性好</strong>，AOF可以配置来设置，每进行一次命令就记录到AOF文件中一次</li>
<li><strong>通过append模式写文件</strong>，即使写文件途中服务器宕机，也可以通过截断最后不完整的命令等手段来解决问题</li>
</ul>
</li>
<li>缺点<ul>
<li>AOF文件比RDB文件大，且<strong>恢复速度慢</strong></li>
</ul>
</li>
</ul>
<h3 id="Redis的数据恢复？"><a href="#Redis的数据恢复？" class="headerlink" title="Redis的数据恢复？"></a>Redis的数据恢复？</h3><p><img src="D:\desktop\面经高频问题.assets\image-20240410234618268.png"></p>
<h2 id="高可用-1"><a href="#高可用-1" class="headerlink" title="高可用"></a>高可用</h2><blockquote>
<p>保证高可用主要有三种方式：<strong>主从</strong>、<strong>哨兵</strong>、<strong>集群</strong></p>
</blockquote>
<h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><blockquote>
<p>主节点写、从节点读、主从之间数据异步同步</p>
</blockquote>
<p><img src="D:\desktop\面经高频问题.assets\image-20240402004815472.png">允许一个 Redis 服务器（主节点）将数据复制到一个或多个 Redis 服务器（从节点）。这种方式可以实现读写分离，适合读多写少的场景。</p>
<p>主从复制主要的作用？</p>
<ul>
<li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li>
<li>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务，分担服务器负载。</li>
<li><strong>高可用的基石：</strong>主从复制还是哨兵和集群能够实施的 <strong>基础</strong>。</li>
</ul>
<p>存在问题？</p>
<ul>
<li>主节点故障后 没办法完成自动故障转移（哨兵解决）</li>
<li>主节点的写能力和存储能力也都受到单机的限制（集群解决）</li>
<li>尽量保证主从节点之间的网络连接状况良好，比如说避免在不同机房之间部署主从节点，以减少网络延迟。</li>
</ul>
<h4 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h4><ol>
<li>主从建立连接 从节点（replicaof）发现新的主节点后，会尝试和主节点建立网络连接。</li>
<li>发送 ping 命令 连接建立成功后从节点发送 ping 请求进行首次通信</li>
<li>权限验证 如果主节点要求密码验证，从节点必须正确的密码才能通过验证。</li>
<li>同步数据 主从复制连接正常通信后，主节点会把持有的数据全部发送给从节点。</li>
<li>命令持续复制 接下来主节点会持续地把写命令发送给从节点，保证主从数据一致性。</li>
</ol>
<h4 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h4><p>主从服务器第一次同步分为三个阶段：</p>
<ul>
<li>第一阶段是建立链接、协商同步；</li>
<li>第二阶段是主服务器同步数据给从服务器；</li>
<li>第三阶段是主服务器发送新写操作命令给从服务器。</li>
</ul>
<ol>
<li>从库发送 <code>psync</code> 命令，表示要进行数据同步，主库接收命令后，用 <code>FULLRESYNC</code> 作为相应命令给从库（表示采用全量复制）</li>
<li>主库通过bgsave生成 RDB 文件，发送给从库，从库接收后，清除原数据，加载RDB文件，<strong>为了保证数据一致性：主库会把新的写命令写入 replication buffer 缓冲区</strong><ul>
<li>主服务器生成 RDB 文件期间；</li>
<li>主服务器发送 RDB 文件给从服务器期间；</li>
<li>「从服务器」加载 RDB 文件期间；</li>
</ul>
</li>
<li>当从库加载完 RDB文件，回复确认消息给主库，主库会把缓冲区的写命令发送到从库，从库执行完，则保证主从数据一致</li>
</ol>
<h4 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h4><ul>
<li>从库在恢复网络后，会发送 <code>psync</code> 命令给主库，此时的 <code>psync</code> 命令里的 offset 参数不是 -1；</li>
<li>主库收到该命令后，然后用 <code>CONTINUE</code> 响应命令告诉从库接下来采用增量复制的方式同步数据；</li>
<li>然后主库将主从服务器断线期间，所执行的写命令发送给从库，然后从库执行这些命令。</li>
</ul>
<p><strong><font style="color:rgba(0, 0, 0, 0.96);">repl_backlog_buffer</font></strong><font style="color:rgba(0, 0, 0, 0.96);">，是一个「环形」缓冲区，用于主从服务器断连后，从中找到差异的数据； </font></p>
<p><strong><font style="color:rgba(0, 0, 0, 0.96);">replication offset</font></strong><font style="color:rgba(0, 0, 0, 0.96);">，标记上面那个缓冲区的同步进度，主从服务器都有各自的偏移量，主服务器使用 </font><strong><font style="color:rgba(0, 0, 0, 0.96);">master_repl_offset</font></strong><font style="color:rgba(0, 0, 0, 0.96);"> 来记录自己「写」到的位置，从服务器使用 </font><strong><font style="color:rgba(0, 0, 0, 0.96);">slave_repl_offset</font></strong><font style="color:rgba(0, 0, 0, 0.96);"> 来记录自己「读」到的位置。</font></p>
<p><font style="color:rgba(0, 0, 0, 0.96);">在主库进行命令传播时，不仅发送给从库，并且写入到</font><strong><font style="color:rgba(0, 0, 0, 0.96);">repl_backlog_buffer，</font></strong><font style="color:rgba(0, 0, 0, 0.96);">因此当网络断开后，从库发送 </font><strong><font style="color:rgba(0, 0, 0, 0.96);">slave_repl_offset </font></strong><font style="color:rgba(0, 0, 0, 0.96);">给主库，主库根据自身的 </font><strong><font style="color:rgba(0, 0, 0, 0.96);">master_repl_offset</font></strong><font style="color:rgba(0, 0, 0, 0.96);"> 判断出两位置差距，然后执行操作：</font></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.96);">如果数据在</font><strong><font style="color:rgba(0, 0, 0, 0.96);">repl_backlog_buffer </font></strong><font style="color:rgba(0, 0, 0, 0.96);">则增量</font><ul>
<li><font style="color:rgba(0, 0, 0, 0.96);">主库会把增量数据写入 replication buffer 发送给从库</font></li>
<li><font style="color:rgba(0, 0, 0, 0.96);">当如果</font><strong><font style="color:rgba(0, 0, 0, 0.96);">repl_backlog_buffer </font></strong><font style="color:rgba(0, 0, 0, 0.96);">缓冲区写满，则会采用全量，所以要调整缓冲区大小，避免全量</font></li>
</ul>
</li>
<li><font style="color:rgba(0, 0, 0, 0.96);">否则 全量</font></li>
</ul>
<h4 id="主从复制架构中，过期key怎么处理？"><a href="#主从复制架构中，过期key怎么处理？" class="headerlink" title="主从复制架构中，过期key怎么处理？"></a>主从复制架构中，过期key怎么处理？</h4><p>主节点会模拟一条del命令发送给从节点，从节点收到该命令后，就会进行删除操作。</p>
<h4 id="脑裂"><a href="#脑裂" class="headerlink" title="脑裂"></a>脑裂</h4><p><font style="color:rgb(51, 51, 51);">所谓的脑裂，就是指在主从集群中，同时有两个主节点，它们都能接收写请求。</font>  </p>
<p><font style="color:rgb(51, 51, 51);">脑裂发生的原因主要是：原主库发生了假故障，我们来总结下假故障的两个原因。</font></p>
<ol>
<li><font style="color:rgb(51, 51, 51);">和主库部署在同一台服务器上的其他程序临时占用了大量资源（例如 CPU 资源），导致主库资源使用受限，短时间内无法响应心跳。其它程序不再使用资源时，主库又恢复正常。</font></li>
<li><font style="color:rgb(51, 51, 51);">主库自身遇到了阻塞的情况，例如：处理 bigkey 或是发生内存 swap（你可以复习下第19讲中总结的导致实例阻塞的原因），短时间内无法响应心跳，等主库阻塞解除后，又恢复正常的请求处理了。</font></li>
</ol>
<p><font style="color:rgb(51, 51, 51);">为了应对脑裂，你可以在主从集群部署时，<br></font><font style="color:rgb(51, 51, 51);">通过合理地配置参数 min-slaves-to-write 和 min-slaves-max-lag，来预防脑裂的发生。</font></p>
<ul>
<li><strong>min-slaves-to-write</strong><font style="color:rgb(51, 51, 51);">：与主节点通信的从节点数量必须大于等于该值主节点，否则主节点拒绝写入。</font></li>
<li><strong>min-slaves-max-lag</strong><font style="color:rgb(51, 51, 51);">：主节点与从节点通信的 ACK 消息延迟必须小于该值，否则主节点拒绝写入</font></li>
</ul>
<p><font style="color:rgb(51, 51, 51);">假设从库有 K 个，<br></font><font style="color:rgb(51, 51, 51);">可以将 min-slaves-to-write 设置为 K&#x2F;2 + 1（如果 K 等于1，就设为1），<br></font><font style="color:rgb(51, 51, 51);">将 min-slaves-max-lag 设置为十几秒（例如 10～20s），<br></font><font style="color:rgb(51, 51, 51);">在这个配置下，如果有超过一半的从库和主库进行的 ACK 消息延迟超过十几秒，就禁止主库接收客户端写请求。</font></p>
<h3 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h3><blockquote>
<p>解决上述主从复制的<strong>自动故障转移</strong>问题</p>
</blockquote>
<ul>
<li>选主：当主库下线后，哨兵会根据特定策略选择一个主库出来</li>
<li>通知：将新的主库通知给其他从库</li>
</ul>
<h4 id="监控"><a href="#监控" class="headerlink" title="监控"></a><img src="D:\desktop\面经高频问题.assets\image-20240402010135610.png">监控</h4><p>哨兵通过 PING命令 会不断地检查主节点和从节点是否运作正常。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1732723165192-da62bc77-0251-4ebf-97cb-212be9d61960.png"></p>
<h5 id="下线类型"><a href="#下线类型" class="headerlink" title="下线类型"></a>下线类型</h5><p>如果主节点或者从节点在规定时间内没有响应哨兵的PING命令，则被哨兵标记为<strong>主观下线</strong>。</p>
<p><strong>客观下线</strong>只适用于主节点，为了减少误判，一般设置哨兵集群（3个以上）当主节点下线，<strong>通过多个哨兵进行判断，避免单个哨兵因为网络问题，误判主节点下线。</strong></p>
<p>哨兵文件文件有个 <code>quorum</code> （一般设置为哨兵的一半 +1）赞同票数，当哨兵投票达到这个值时则认为主节点 客观下线，</p>
<h5 id="选leader"><a href="#选leader" class="headerlink" title="选leader"></a>选leader</h5><p>当判断主节点 客观下线后，哨兵集群需要选出一个leader进行主从切换，哪个节点判断主节点客观下线，并且满足票数过半以及大于quorum属性，即是leader，</p>
<h5 id="主从故障转移"><a href="#主从故障转移" class="headerlink" title="主从故障转移"></a>主从故障转移</h5><ol>
<li>在已下线主节点的从节点，挑选一个从节点转换成主节点<ol>
<li>根据节点优先级排序挑选</li>
<li>上者相同，则查看谁接收的数据最完整</li>
<li>还相同，则根据节点id小的那个</li>
</ol>
</li>
<li>让已下线主节点的所有从节点修改复制目标为新主节点</li>
<li>将新主节点IP地址和信息，通过【发布者&#x2F;订阅】发送给从节点</li>
<li>继续监视旧主节点，一旦上线，变成新主节点的从节点</li>
</ol>
<p>配置哨兵命令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span><br></pre></td></tr></table></figure>

<p>哨兵集群 通过 redis的 【发布者&#x2F;订阅者】机制来相互发现的，集群中，主节点有一个sentinel：hello频道，不同的哨兵通过这个频道互相通信。<img src="https://cdn.nlark.com/yuque/0/2024/png/34596451/1732724200136-8a4d483d-4467-49f8-8731-d9e998f54920.png"></p>
<p>因为主节点知道所有从节点的信息，因此哨兵会每隔一段时间发送 info 命令给主节点来获取所有从节点的信息</p>
<h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><blockquote>
<p>集群是终极方案，一举解决高可用和分布式问题</p>
</blockquote>
<p><img src="D:\desktop\面经高频问题.assets\image-20240402010823837.png"></p>
<h4 id="集群的原理？"><a href="#集群的原理？" class="headerlink" title="集群的原理？"></a>集群的原理？</h4><blockquote>
<p>Redis集群通过<strong>数据分区</strong>来实现数据的分布式存储，通过<strong>自动故障转移</strong>实现高可用</p>
</blockquote>
<h4 id="集群创建"><a href="#集群创建" class="headerlink" title="集群创建"></a>集群创建</h4><ul>
<li><strong>数据分区</strong>是在集群创建的时候完成的<img src="D:\desktop\面经高频问题.assets\image-20240411000407969.png"></li>
</ul>
<h4 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h4><blockquote>
<p>Redis集群的故障转移和哨兵的故障转移类似，但是Redis集群中<strong>所有的节点都要承担状态维护的任务</strong></p>
</blockquote>
<ul>
<li><strong>故障发现</strong>：集群中每个节点都定期向其他节点发送ping消息，通信失败则标记主观下线，最后当半数以上持有槽的主节点都标记主观下线，则触发客观下线</li>
<li><strong>故障恢复</strong>：故障节点变为客观下线后，如果下线节点是持有槽的主节点则需要在它的从节点中选出一个替换它，从而保证集群的高可用（和哨兵模式一样）</li>
</ul>
<h2 id="缓存设计"><a href="#缓存设计" class="headerlink" title="缓存设计"></a>缓存设计</h2><h3 id="缓存三大问题？如何解决？"><a href="#缓存三大问题？如何解决？" class="headerlink" title="缓存三大问题？如何解决？"></a>缓存三大问题？如何解决？</h3><ul>
<li><strong>缓存击穿</strong>：热点数据过期（也就是<strong>热点key问题</strong>处理）<ul>
<li>互斥锁更新数据</li>
<li>热点数据永不过期</li>
</ul>
</li>
<li><strong>缓存穿透</strong>：请求数据既不在缓存，也不在数据库<ul>
<li>缓存空值或者默认值（占用内存大）</li>
<li>使用<strong>布隆过滤器</strong>快速判断数据是否存在（实现复杂）</li>
</ul>
</li>
<li><strong>缓存雪崩</strong>：大量缓存数据同时过期，或者redis故障<ul>
<li>均匀设置过期时间</li>
<li>互斥锁更新数据</li>
</ul>
</li>
<li><strong>Redis故障宕机</strong><ul>
<li>服务熔断</li>
<li>请求限流</li>
<li>构建Redis集群</li>
</ul>
</li>
</ul>
<h3 id="数据库和缓存如何保证一致性"><a href="#数据库和缓存如何保证一致性" class="headerlink" title="数据库和缓存如何保证一致性"></a>数据库和缓存如何保证一致性</h3><blockquote>
<p>根据 CAP 理论 在保证可用性A和分区容错性P的前提下，无法保证一致性C，所以缓存和数据库的绝对一致是不可能实现的，只能尽可能保存缓存和数据库的<strong>最终一致性</strong></p>
</blockquote>
<ul>
<li>选择合适的缓存更新策略（删除缓存而不是更新缓存、先更数据库再删除缓存）</li>
<li>缓存不一致后处理（原因主要有：缓存key删除失败 并发导致缓存写入了脏数据）<ul>
<li>消息队列保证缓存key删除（对业务代码有一定侵入性）</li>
<li>延时双删防止脏数据（延时的时间设置需要仔细考量）</li>
<li>设置缓存过期时间兜底（朴素但有用，缓存过期自然会恢复一致）</li>
</ul>
</li>
</ul>
<h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p><font style="color:rgb(44, 62, 80);">布隆过滤器（Bloom Filter）是一种空间效率极高的概率型数据结构，用于判断一个元素是否在一个集合中。它基于位数组和多个哈希函数的原理，可以高效地进行元素的查询，而且占用的空间相对较小，</font></p>
<p><strong><font style="color:rgb(44, 62, 80);">布隆过滤器说一个元素不在集合中，那么它一定不在这个集合中；但如果它说一个元素在集合中，则有可能是不存在的（存在误差）</font></strong></p>
<h2 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h2><h3 id="Redis报内存不足怎么处理？"><a href="#Redis报内存不足怎么处理？" class="headerlink" title="Redis报内存不足怎么处理？"></a>Redis报内存不足怎么处理？</h3><ul>
<li>纵向扩展：增加单机Redis可用内存</li>
<li>修改内存淘汰策略：如<code>lru/lfu/ttl/random</code>等</li>
<li>横向扩展：使用Redis集群模式进行横向扩容，数据分散存储在多个Redis节点上</li>
</ul>
<h3 id="大key问题了解吗？"><a href="#大key问题了解吗？" class="headerlink" title="大key问题了解吗？"></a>大key问题了解吗？</h3><blockquote>
<p>大key：单个简单的key存储的value很大、hash&#x2F;set&#x2F;zset&#x2F;list中存储过多的元素（数以万计）</p>
</blockquote>
<p>大 key 并不是指 key 的值很大，而是 key 对应的 value 很大。<br>大 key 会带来以下四种影响：</p>
<ul>
<li><strong>引发网络阻塞</strong>：每次获取大key产生的网络流量较大，如果一个key的大小是1MB，每秒访问量为1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。</li>
<li><strong>客户端超时阻塞</strong>：由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis</li>
<li><strong>阻塞工作线程</strong>：如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。</li>
<li><strong>内存分布不均</strong>：集群模型在 slot 分片均匀情况下，会出现数据和查询倾斜情况，部分有大 key 的 Redis节点占用内存多，QPS 也会比较大。</li>
</ul>
<h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><h3 id="Redisson了解吗？"><a href="#Redisson了解吗？" class="headerlink" title="Redisson了解吗？"></a>Redisson了解吗？</h3><blockquote>
<p>实现<strong>分布式锁</strong>，加锁过程中用到了<code>set</code>指令和<code>lua</code>脚本</p>
</blockquote>
<p><img src="D:\desktop\面经高频问题.assets\image-20240401132554023.png"></p>
<p>Redisson加锁大致分为以下几步：</p>
<ol>
<li>使用Lua脚本执行加锁操作</li>
<li>Watch Dog续约锁的过期时间</li>
<li>释放锁</li>
</ol>
<p>为什么要有 Watch Dog？</p>
<ul>
<li><strong>续约</strong>：Watch Dog定期发送续约命令给持有锁的客户端，确保锁在被持有过程中不会过期</li>
<li><strong>释放</strong>：如果Watch Dog发现持有锁的客户端不再存活或者发生故障，会触发锁的自动释放</li>
</ul>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="🌟内存区域"><a href="#🌟内存区域" class="headerlink" title="🌟内存区域"></a>🌟内存区域</h2><h3 id="说说JVM的内存区域？"><a href="#说说JVM的内存区域？" class="headerlink" title="说说JVM的内存区域？"></a>说说JVM的内存区域？</h3><p><img src="/%E9%9D%A2%E7%BB%8F%E9%AB%98%E9%A2%91%E9%97%AE%E9%A2%98/JVM1.PNG"></p>
<ul>
<li><strong>程序计数器</strong>：保存当前程序的执行位置</li>
<li><strong>虚拟机栈</strong>：通过<strong>栈帧</strong>（存储局部变量、方法参数、操作数栈和动态链接等信息）来维持方法调用顺序，帮助控制程序有序运行</li>
<li><strong>本地方法栈</strong>：与虚拟机栈类似，但是它为<strong>本地方法</strong>服务，本地方法是用其他语言（C&#x2F;C++）编写的，与Java进行交互，需要独立的栈来支持</li>
<li><strong>堆</strong>：线程共享，也是整个虚拟机<strong>最大的</strong>一块内存空间，而此区域的职责就是<strong>存放和管理对象和数组</strong>，垃圾回收机制也是主要作用于这一部分内存区域</li>
<li><strong>方法区</strong>：线程共享，包含<strong>类信息</strong>、<strong>运行时常量池</strong>、即时编译器的代码缓存</li>
</ul>
<h3 id="什么是内存溢出？内存泄漏？"><a href="#什么是内存溢出？内存泄漏？" class="headerlink" title="什么是内存溢出？内存泄漏？"></a>什么是内存溢出？内存泄漏？</h3><ul>
<li><strong>内存泄漏</strong>：申请的内存空间没有被正确释放，导致内存被白白占用</li>
<li>**内存溢出(OOM)**：申请的内存超过了可用内存，内存不够了<ul>
<li><strong>堆溢出</strong>：不断创建对象，并且避免垃圾回收机制清除对象，到达一定限值就会产生内存溢出异常。</li>
<li><strong>虚拟机栈溢出</strong>，本地方法栈溢出：<ul>
<li>当前线程请求的栈深度大于虚拟机栈所允许的深度时抛出<code>SOF</code>异常</li>
<li>如果扩展时无法申请到足够的内存空间会抛出<code>OOM</code>异常。</li>
</ul>
</li>
<li><strong>本地方法</strong>：申请后没有合理释放，在FullGC来临之前耗尽了分配的所有空间</li>
<li><strong>运行时常量池溢出</strong>：在运行时产生大量类字节码，从而使得元数据空间内存被耗尽，从而抛出OOM。</li>
</ul>
</li>
<li>两者关系：内存泄露  —可能会—&gt; 内存溢出</li>
</ul>
<h3 id="🌟如何快速排查OOM错误？"><a href="#🌟如何快速排查OOM错误？" class="headerlink" title="🌟如何快速排查OOM错误？"></a>🌟如何快速排查OOM错误？</h3><p>首先，<strong>OOM的原因</strong>：（对应的方法）</p>
<ul>
<li><strong>一次性资源申请的太多</strong>：更改申请对象数量</li>
<li><strong>申请的资源未正确释放</strong>：找到未释放的对象进行释放</li>
<li>本身资源分配不够：jmap -heap 查看堆信息然后进行相应调整</li>
</ul>
<p>对于前两种情况，则需要进行<strong>OOM定位</strong>：</p>
<ul>
<li><strong>导出dump文件</strong>：系统已经挂了就设置当OOM时自动导出dump文件，还在运行中就 jmap -dump导出</li>
<li><strong>借助java visualVM查看dump文件进行调试并定位</strong>：查看跟业务有关的最多的对象 -&gt; 找到GC Root -&gt; 查看线程栈</li>
</ul>
<h2 id="🌟垃圾回收"><a href="#🌟垃圾回收" class="headerlink" title="🌟垃圾回收"></a>🌟垃圾回收</h2><h3 id="🌟介绍一下垃圾回收机制？"><a href="#🌟介绍一下垃圾回收机制？" class="headerlink" title="🌟介绍一下垃圾回收机制？"></a>🌟介绍一下垃圾回收机制？</h3><p>首先，先介绍<strong>对象存活判定算法</strong>：</p>
<ul>
<li>引用计数法</li>
<li><strong>可达性分析算法</strong>：GC Roots可以是</li>
</ul>
<p><img src="/2024/12/09/hello-world/png"></p>
<pre><code>- 虚拟机栈（栈帧中的本地变量表）中引用的对象
- 方法区中类静态属性引用的对象，也就是static修饰的变量
- 方法区中常量引用的对象，final修饰变量，或者String常量池里的引用等
- 被同步锁synchronized持有的对象
- JVM内部的引用
</code></pre>
<p>其次是，<strong>分代回收机制</strong>：Java虚拟机将堆内存主要划分为<strong>新生代</strong>、<strong>老年代</strong>和<strong>永久代</strong>(JDK8之后改为<strong>元空间</strong>实现，直接在堆外的本地内存)</p>
<ul>
<li><strong>新生代</strong>：主要用来存放新生的对象。一般占据堆空间的1&#x2F;3。在新生代中，保存着大量的刚刚创建的对象，但是大部分的对象都是朝生夕死，所以在新生代中会频繁的进行MinorGC，进行垃圾回收。新生代又细分为三个区：Eden区、SurvivorFrom、ServivorTo区，三个区的默认比例为：8：1：1。<ul>
<li><strong>Eden区：</strong>Java新创建的对象绝大部分会分配在Eden区（如果对象太大，则直接分配到老年代）。当Eden区内存不够的时候，就会触发MinorGC（新生代采用的是复制算法），对新生代进行一次垃圾回收。</li>
<li><strong>SurvivorFrom区和To区：</strong>在GC开始的时候，对象只会存在于Eden区和名为From的Survivor区，To区是空的，一次MinorGc过后，Eden区和SurvivorFrom区存活的对象会移动到SurvivorTo区中，然后会清空Eden区和SurvivorFrom区，并对存活的对象的年龄+1，如果对象的年龄达到15，则直接分配到老年代。MinorGC完成后，SurvivorFrom区和SurvivorTo区的功能进行互换。下一次MinorGC时，会把SurvivorTo区和Eden区存活的对象放入SurvivorFrom区中，并计算对象存活的年龄。</li>
</ul>
</li>
<li><strong>老年代</strong>：主要存放应用中生命周期长的内存对象。老年代比较稳定，不会频繁的进行MajorGC。而在MaiorGC之前才会先进行一次MinorGc，使得新生的对象进入老年代而导致空间不够才会触发。当无法找到足够大的连续空间分配给新创建的较大对象也会提前触发一次MajorGC进行垃圾回收腾出空间。</li>
<li><strong>永久代</strong>：永久保存区域。主要存放Class和Meta（元数据）的信息。Classic在被加载的时候被放入永久区域，它和存放的实例的区域不同，在Java8中，词锋代已经被移除，取而代之的是一个称之为“元数据区”（元空间）的区域。元空间和永久代类似，都是对JVM中规范中方法的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存的限制。类的元数据放入native memory，字符串池和类的静态变量放入java堆中。这样可以加载多少类的元数据就不再由MaxPermSize控制，而由系统的实际可用空间来控制。</li>
</ul>
<p><strong>采用元空间而不用永久代的原因：</strong></p>
<ul>
<li>为了解决永久代的OOM问题，元数据和class对象存放在永久代中，容易出现性能问题和内存溢出。</li>
<li>类及方法的信息等比较难确定其大小，因此对于永久代大小指定比较困难，大小容易出现永久代溢出，太大容易导致老年代溢出（堆内存不变，此消彼长）。</li>
<li>永久代会为GC带来不必要的复杂度，并且回收效率偏低。</li>
</ul>
<p>🌟🌟🌟<strong>具体是如何运作</strong>的呢？</p>
<ul>
<li>首先，所有新创建的对象，在一开始都会进入到新生代的Eden区（如果是大对象会被直接丢进老年代），在进行新生代区域的垃圾回收时，首先会对所有新生代区域的对象进行扫描，并回收那些不再使用对象：<br><img src="https://image.itbaima.cn/markdown/2023/03/06/lENKm3CMuxk1JFI.png"></li>
<li>接着，在一次垃圾回收之后，Eden区域没有被回收的对象，会进入到Survivor区。在一开始From和To都是空的，而GC之后，所有Eden区域存活的对象都会直接被放入到From区，最后From和To会发生一次交换，也就是说目前存放我们对象的From区，变为To区，而To区变为From区：<br><img src="https://image.itbaima.cn/markdown/2023/03/06/xU6LY3nDukNg2rv.png"></li>
<li>在GC一开始To是空的，而GC之后，所有Eden区域，From存活的对象都会直接被放入到To区，然后清空Eden区域和From区，并对存活的对象的年龄+1，如果对象的年龄达到15，则直接分配到老年代。最后From和To会发生一次交换，下一次GC时，会把To区和Eden区存活的对象放入From区中，并计算对象存活的年龄。<img src="https://image.itbaima.cn/markdown/2023/03/06/NeGcYPwDOkdjVfq.png"></li>
</ul>
<h3 id="垃圾回收分为哪些？"><a href="#垃圾回收分为哪些？" class="headerlink" title="垃圾回收分为哪些？"></a>垃圾回收分为哪些？</h3><ul>
<li>**新生代收集(MinorGC)**：只针对新生代的GC，当<code>Eden</code>区满了时触发，<code>Survivor</code>满了并不会触发。</li>
<li>**年老代收集(MajorGC)**：针对年老代空间的GC，不过目前只有<code>CMS</code>存在单独回收年老代的行为。</li>
<li>**混合收集(MixedGC)**：指收集范围覆盖整个新生代空间及部分年老代空间的GC，目前只有<code>G1</code>存在该行为。</li>
<li>**全面收集(FullGC)**：覆盖新生代、年老代以及元数据空间的GC，会对于所有可发生GC的内存进行收集。</li>
</ul>
<h3 id="对象什么时候回进入老年代？"><a href="#对象什么时候回进入老年代？" class="headerlink" title="对象什么时候回进入老年代？"></a>对象什么时候回进入老年代？</h3><ul>
<li><strong>长期存活</strong>（默认GC年龄大于15）</li>
<li><strong>大对象</strong>（直接进入）</li>
<li><strong>空间分配担保</strong>：Minor GC后新生代仍有大量对象存活，那么就需要老年代进行担保，将Survivor区无法容纳的对象直接送入老年代（本身不到年龄 但新生代无法存下了）</li>
</ul>
<h3 id="垃圾回收算法了解吗？"><a href="#垃圾回收算法了解吗？" class="headerlink" title="垃圾回收算法了解吗？"></a>垃圾回收算法了解吗？</h3><ul>
<li><strong>标记-清除</strong>：标记所有需要回收的对象，然后再依次回收<img src="https://image.itbaima.cn/markdown/2023/03/06/d8anmBcLrW3iyJl.png"><ul>
<li>执行效率不稳定（标记和清除的执行效率随对象数量增长而降低）</li>
<li>标记-清除之后会产生大量不连续的内存碎片，使得内存空间利用率降低</li>
</ul>
</li>
<li><strong>标记-复制</strong>：将内存区域划分为大小相同的两块区域，每次只使用其中的一块区域，每次垃圾回收结束后，将所有存活的对象全部复制到另一块区域中，并一次性清空当前区域</li>
</ul>
<p><img src="https://image.itbaima.cn/markdown/2023/03/06/JeifGj6kmVAY2PR.png"></p>
<pre><code>- 一部分空间没有使用，存在空间浪费
</code></pre>
<ul>
<li><strong>标记-整理</strong>：标记，但先不回收，而是按顺序整理好，再按顺序一次清理<img src="https://image.itbaima.cn/markdown/2023/03/06/4UncSVvO1P2xWKL.png"></li>
</ul>
<h3 id="🌟垃圾回收器都知道哪些？"><a href="#🌟垃圾回收器都知道哪些？" class="headerlink" title="🌟垃圾回收器都知道哪些？"></a>🌟垃圾回收器都知道哪些？</h3><ul>
<li>串行回收器：Serial  Serial Old</li>
<li>并行回收器：ParNew   Parallel Scavenge  Parallel Old</li>
<li>🌟并发回收器：<strong>CMS</strong> <strong>G1</strong></li>
</ul>
<h4 id="CMS回收器"><a href="#CMS回收器" class="headerlink" title="CMS回收器"></a>CMS回收器</h4><blockquote>
<p>并发收集、停顿时间短，但是由于采用<strong>标记-清除</strong>，还是无法避免容易产生内存碎片</p>
</blockquote>
<p>采用<strong>标记-清除</strong>算法：</p>
<p><img src="https://image.itbaima.cn/markdown/2023/03/06/qhmndIQPKarvDso.png">分为4个阶段：</p>
<ul>
<li><strong>初始标记</strong>（需要暂停用户线程）：仅标记出GC Roots能直接关联的对象，速度比较快</li>
<li><strong>并发标记</strong>：从GC Roots的直接关联对象开始遍历整个对象图的过程</li>
<li><strong>重新标记</strong>（需要暂停用户线程）：并发标记阶段可能某些用户线程会导致标记产生变动，因此需要重新标记</li>
<li><strong>并发清除</strong>：最后就可以直接将所有标记好的无用对象进行删除</li>
</ul>
<h4 id="G1处理器"><a href="#G1处理器" class="headerlink" title="G1处理器"></a>G1处理器</h4><blockquote>
<p>G1<strong>相比CMS</strong>优势：<strong>内存碎片问题缓解、停顿时间更短、处理大对象的能力、并发性能优化</strong></p>
<p>开创了<strong>局部收集</strong>的设计思路和基于<strong>Region</strong>的内存布局形式</p>
</blockquote>
<p><img src="D:\desktop\面经高频问题.assets\image-20240309002100791.png"></p>
<p><img src="https://image.itbaima.cn/markdown/2023/03/06/kXRMlt5iFDvjq8y.png"></p>
<p>运行过程还是四个阶段（类似CMS）：</p>
<ul>
<li><strong>初始标记</strong>（暂停用户线程）：仅仅只是标记一下GC Roots能直接关联到的对象</li>
<li><strong>并发标记</strong>：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象</li>
<li><strong>最终标记</strong>（暂停用户线程）：对用户线程做一个短暂的暂停，用于处理并发标记阶段漏标的那部分对象</li>
<li><strong>筛选回收</strong>（暂停用户线程）：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划</li>
</ul>
<h2 id="类与类加载"><a href="#类与类加载" class="headerlink" title="类与类加载"></a>类与类加载</h2><h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p><img src="https://image.itbaima.cn/markdown/2023/03/06/UIV6fJknmM4bojP.png"></p>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ul>
<li>启动类加载器 (<strong>Bootstrap ClassLoader</strong>)：也称为根类加载器，是Java虚拟机的一部分，负责加载Java的核心类库</li>
<li>扩展类加载器 (<strong>Extensions ClassLoader</strong>)：它用来加载 Java 的扩展库</li>
<li>系统类加载器（<strong>AppClassLoader</strong> 或 SystemClassLoader：它根据 Java 应用的类路径（CLASSPATH）来加载Java 类<br><img src="https://image.itbaima.cn/markdown/2023/03/06/RFaE7s5CnmylgkT.png"></li>
</ul>
<h3 id="🌟双亲委派机制"><a href="#🌟双亲委派机制" class="headerlink" title="🌟双亲委派机制"></a>🌟双亲委派机制</h3><blockquote>
<p>一个类加载器收到加载请求时，先给父类加载，加载不出来再自己加载</p>
<p><strong>作用</strong>：避免类的重复加载、确保类的安全性和一致性、防止类的篡改、方便类加载器的扩展和自定义</p>
</blockquote>
<p><img src="D:\desktop\面经高频问题.assets\image-20240423225509481.png"></p>
<h5 id="🌟破坏双亲委派的例子（Tomcat）"><a href="#🌟破坏双亲委派的例子（Tomcat）" class="headerlink" title="🌟破坏双亲委派的例子（Tomcat）"></a>🌟破坏双亲委派的例子（Tomcat）</h5><p><img src="D:\desktop\面经高频问题.assets\image-20240423230750074.png"></p>
<p>为什么Tomcat要破坏双亲委派机制？</p>
<ul>
<li><strong>隔离不同Web应用程序的类空间</strong>： Tomcat容器中，可能会部署多个独立的Web应用程序，如果共享一个类加载器只能加载一个版本的类库，因此为每个web应用程序提供独立的<strong>WebApp类加载器</strong></li>
<li><strong>支持Web应用的动态更新</strong>：当开发者修改并重新部署某个Web应用的部分类文件时，如果不打破双亲委派，新的类定义无法被重新加载，除非重启整个Web容器，因此破坏之后可以进行热部署和热更新</li>
</ul>
<h1 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h1><h3 id="如何创建线程？"><a href="#如何创建线程？" class="headerlink" title="如何创建线程？"></a>如何创建线程？</h3><blockquote>
<p>不管哪种方法，都依赖于<code>new Thread().start()</code></p>
</blockquote>
<ul>
<li>继承<code>Thread</code>类</li>
<li>实现<code>Runnable</code>接口</li>
<li>实现<code>Callable</code>接口</li>
<li>使用线程池</li>
<li>······</li>
</ul>
<h3 id="守护线程是什么？"><a href="#守护线程是什么？" class="headerlink" title="守护线程是什么？"></a>守护线程是什么？</h3><ul>
<li>Java线程分为<strong>守护线程</strong>和<strong>用户线程</strong>（例如GC线程就是守护线程）</li>
<li>当<strong>所有用户线程</strong>执行完毕，程序终止（无论是否有守护线程还在执行）</li>
</ul>
<h3 id="ThreadLocal了解多少？用过吗？"><a href="#ThreadLocal了解多少？用过吗？" class="headerlink" title="ThreadLocal了解多少？用过吗？"></a>ThreadLocal了解多少？用过吗？</h3><p>线程本地变量，操作自己本地内存里面的变量，起到线程隔离作用</p>
<h3 id="ThreadLocal内存泄漏是怎么回事？"><a href="#ThreadLocal内存泄漏是怎么回事？" class="headerlink" title="ThreadLocal内存泄漏是怎么回事？"></a>ThreadLocal内存泄漏是怎么回事？</h3><ul>
<li>ThreadLocalMap&lt;**ThreadLocal**, value&gt;中的key 为 ThreadLocal 的弱引用，弱引用容易被GC回收，防止内存泄露</li>
<li>但是如果存在一个线程一直在运行，并且其ThreadLocalMap的Entry.value指向某个强引用对象，就不会回收，就会造成<strong>内存泄漏，</strong></li>
<li>解决办法：使用完ThreadLocal后，及时调用remove()方法释放内存空间</li>
</ul>
<h3 id="Java内存模型知道吗？"><a href="#Java内存模型知道吗？" class="headerlink" title="Java内存模型知道吗？"></a>Java内存模型知道吗？</h3><p>主内存+线程本地内存实现</p>
<h3 id="原子性、可见性、有序性？"><a href="#原子性、可见性、有序性？" class="headerlink" title="原子性、可见性、有序性？"></a>原子性、可见性、有序性？</h3><ul>
<li>原子性：要么都做、要么都不做</li>
<li>可见性：一个线程对共享变量修改，其他线程能够立即看到这个修改</li>
<li>有序性：是指程序执行的顺序与代码的顺序一致</li>
</ul>
<h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><h4 id="乐观和悲观"><a href="#乐观和悲观" class="headerlink" title="乐观和悲观"></a>乐观和悲观</h4><ul>
<li>悲观锁：访问共享资源前悲观地认为总有人也要用，所以每次先拿锁（<code>synchronized</code>和<code>ReentrantLock</code>）</li>
<li>乐观锁：乐观地认为并发修改冲突少，因此直接访问共享资源，在使用资源时再进行冲突检测决定是否加锁（实现方法：版本号 &#x2F; CAS）</li>
</ul>
<h4 id="可重入和不可重入"><a href="#可重入和不可重入" class="headerlink" title="可重入和不可重入"></a>可重入和不可重入</h4><ul>
<li>可重入锁允许同一个线程在持有锁的情况下再次获取该锁，而不会发生死锁</li>
<li>Synchronized和ReentrantLock都是可重入锁</li>
</ul>
<h4 id="公平和非公平"><a href="#公平和非公平" class="headerlink" title="公平和非公平"></a>公平和非公平</h4><ul>
<li>公平锁指 按照 等待锁的进程按顺序发放锁（也就是先来先服务），非公平就不按顺序</li>
<li>ReentrantLock可以指定</li>
<li>Synchronized只能是非公平锁</li>
</ul>
<h4 id="重量级和轻量级"><a href="#重量级和轻量级" class="headerlink" title="重量级和轻量级"></a>重量级和轻量级</h4><h3 id="🌟volatile和synchronized知道吗？原理呢？"><a href="#🌟volatile和synchronized知道吗？原理呢？" class="headerlink" title="🌟volatile和synchronized知道吗？原理呢？"></a>🌟volatile和synchronized知道吗？原理呢？</h3><blockquote>
<p><code>volatile</code>关键字主要用于解决<strong>变量在多个线程之间的可见性</strong>，而 <code>synchronized</code> 关键字解决的是<strong>多个线程之间访问资源的同步性</strong></p>
</blockquote>
<h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><ul>
<li><strong>保证可见性</strong>：一个线程操作volatile变量时，不会把值缓存而是直接刷新回主内存，并且其他线程读取时会主动获取最新值而不是使用当前线程本地内存中的值</li>
<li><strong>保证有序性</strong>：volatile会<strong>禁止指令重排</strong>。若用volatile修饰共享变量，在编译时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序</li>
</ul>
<h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><blockquote>
<p>具体原理可以<strong>类比操作系统中的信号量机制</strong>，每次只能由一个线程进入同步代码块，释放锁之后会计数器-1并唤醒处于等待队列里的下一个线程（但是不保证顺序），获取到锁之后就计数器+1</p>
</blockquote>
<ul>
<li>属于<strong>重量级锁</strong>和<strong>非公平锁</strong>，因为它的监视器锁是依赖于底层操作系统的互斥锁实现的，但是JDK6以后引入了许多优化减少了锁的开销</li>
<li>每个对象都有一个内置锁，synchronized锁住的就是<strong>基于对象的内置锁</strong>，只有获取了才能进入同步代码块或者同步方法</li>
<li><strong>保证原子性</strong>：用synchronized关键字修饰代码块的时候，会使用<code>monitorenter</code>和<code>monitorexit</code>两个指令实现同步（相当于获取锁、释放锁）</li>
<li>锁升级：无锁 –&gt;偏向锁 —&gt; 轻量级锁 —-&gt;重量级锁<img src="D:\desktop\面经高频问题.assets\image-20240328162234793.png"></li>
</ul>
<h4 id="ReentrantLock（可重入锁）"><a href="#ReentrantLock（可重入锁）" class="headerlink" title="ReentrantLock（可重入锁）"></a>ReentrantLock（可重入锁）</h4><blockquote>
<p>依赖于AQS实现，使用方面和synchronized差不多，但是有一些方面不同</p>
</blockquote>
<ul>
<li>锁的实现：synchronized基于JVM实现，而ReentrantLock基于JDK的API层面实现</li>
<li><strong>功能特点</strong>：ReentrantLock相比比synchronized有以下特点<ul>
<li>ReentrantLock可以指定是公平锁还是非公平锁，而synchronized只能是非公平</li>
<li>ReentrantLock需要手动声明加锁和释放锁，而synchronized不需要手动释放</li>
</ul>
</li>
</ul>
<h3 id="什么是CAS？"><a href="#什么是CAS？" class="headerlink" title="什么是CAS？"></a>什么是CAS？</h3><ul>
<li>全称Compare And Swap 比较与交换</li>
<li>是一种无锁算法，它并不会为对象加锁，而是<strong>在执行的时候，看看当前数据的值是不是我们预期的那样，如果是，那就正常进行替换，如果不是，那么就替换失败。</strong></li>
<li>CAS有什么问题？经典三大问题<ul>
<li>ABA问题（用版本号解决）</li>
<li>循环性能开销</li>
<li>只能保证一个变量的原子操作</li>
</ul>
</li>
</ul>
<h3 id="AQS了解多少？"><a href="#AQS了解多少？" class="headerlink" title="AQS了解多少？"></a>AQS了解多少？</h3><ul>
<li>AQS，是Java中用于实现同步器的抽象基类，它是Java并发包中许多同步工具的基础，如ReentrantLock、Semaphore、CountDownLatch等</li>
<li>AQS提供了一种基于FIFO等待队列的同步器框架，允许开发者实现自定义的同步器。它的设计思想是将同步状态抽象成一个整型变量，并通过原子操作来控制该状态的获取和释放</li>
<li>使用了<strong>模版方法模式</strong>的设计模式</li>
</ul>
<h3 id="🌟线程池知道吗？有没有用过？"><a href="#🌟线程池知道吗？有没有用过？" class="headerlink" title="🌟线程池知道吗？有没有用过？"></a>🌟线程池知道吗？有没有用过？</h3><h4 id="为什么要用线程池？"><a href="#为什么要用线程池？" class="headerlink" title="为什么要用线程池？"></a>为什么要用线程池？</h4><blockquote>
<p>简单说，就是<strong>管理线程的池子</strong></p>
</blockquote>
<ul>
<li>帮助管理线程，避免增加创建线程和销毁线程的资源损耗</li>
<li>提高响应速度，相对于创建新线程执行任务，从池子里拿线程更快</li>
<li>重复利用线程，节省资源</li>
</ul>
<h4 id="简单说一下线程池的工作流程？"><a href="#简单说一下线程池的工作流程？" class="headerlink" title="简单说一下线程池的工作流程？"></a>简单说一下线程池的工作流程？</h4><p><img src="D:\desktop\面经高频问题.assets\image-20240308200812854.png"></p>
<p>通俗的比喻：营业厅办业务：总共六个窗口 现在只开放了三个窗口可以办业务</p>
<p>小明去办业务，可能会遇到以下情况：</p>
<ol>
<li>有空着的在营业的窗口，直接办理业务</li>
<li>没有空闲窗口，但是等待区还有座，坐着等</li>
<li>没有空闲窗口，等待区也满了，经理就赶紧让没开的窗口也开放了，工作一段时间后空闲了可以休息</li>
<li>所有窗口都满了，等待区也满了，小明无法办理业务，经理怎么对待小明？（<strong>线程池拒绝策略</strong>）<ol>
<li>营业厅瘫痪：AbortPolicy（默认策略，抛出异常）</li>
<li>谁叫你来办的你找谁去：CallerRunsPolicy（由提交任务的线程来执行该任务）</li>
<li>看你比较急，你去加个塞：DiscardOldestPolicy（丢弃队列中最早的任务，然后尝试重新提交该任务）</li>
<li>今天没办法，改一天再办：DiscardPolicy：（默默地丢弃该任务，不做任何处理）</li>
<li>除此之外，还可以自定义处理策略</li>
</ol>
</li>
</ol>
<p>以上流程跟JDK线程池业务大致类似：</p>
<ul>
<li>营业厅三个开放的窗口对应 核心线程池数：<strong>corePoolSize</strong></li>
<li>总共的营业窗口对应：<strong>maximumPoolSize</strong></li>
<li>打开的临时窗口在多长时间内无人办理则自动关闭：<strong>keepAliveTime</strong></li>
<li>等待区就是等待队列：<strong>workQueue</strong></li>
<li>无法办理的时候经理给出的解决办法就是：<strong>RejectedExecutionHandler</strong></li>
<li>threadFactory在JDK中是线程工厂，用来创建线程对象，一般不动</li>
</ul>
<h4 id="🌟🌟🌟那你实际有没有用过呢？"><a href="#🌟🌟🌟那你实际有没有用过呢？" class="headerlink" title="🌟🌟🌟那你实际有没有用过呢？"></a>🌟🌟🌟那你实际有没有用过呢？</h4><p>有的，在<strong>校园论坛</strong>中，在实现<strong>定时实现将Redis中的点赞收藏数据写入MySQL</strong>功能时，利用线程池来完成这个<strong>定时任务</strong>，用的是<strong>ScheduledThreadPool</strong></p>
<ul>
<li>这样就不会每次执行定时任务都创建一个新线程，加<strong>叙述线程池的优点</strong></li>
</ul>
<h1 id="🌟计算机网络"><a href="#🌟计算机网络" class="headerlink" title="🌟计算机网络"></a>🌟计算机网络</h1><h3 id="说说各层结构"><a href="#说说各层结构" class="headerlink" title="说说各层结构"></a>说说各层结构</h3><p><img src="D:\desktop\面经高频问题.assets\image-20240326161738446.png"></p>
<h3 id="🌟从浏览器地址栏输入URL到显示页面都发生了什么？"><a href="#🌟从浏览器地址栏输入URL到显示页面都发生了什么？" class="headerlink" title="🌟从浏览器地址栏输入URL到显示页面都发生了什么？"></a>🌟从浏览器地址栏输入URL到显示页面都发生了什么？</h3><ol>
<li>DNS解析：将域名解析成对应的IP地址（可以从本地缓存中获取，如果没有再去请求）</li>
<li>TCP连接：与服务器通过三次握手，建立TCP连接</li>
<li>向服务器发送HTTP请求</li>
<li>服务器处理请求，返回HTTP响应</li>
<li>浏览器解析并渲染页面</li>
<li>断开连接：TCP四次挥手，连接结束</li>
</ol>
<h3 id="说说Socket和WebSocket有什么区别？你的项目为什么要用WebSocket？"><a href="#说说Socket和WebSocket有什么区别？你的项目为什么要用WebSocket？" class="headerlink" title="说说Socket和WebSocket有什么区别？你的项目为什么要用WebSocket？"></a>说说Socket和WebSocket有什么区别？你的项目为什么要用WebSocket？</h3><ul>
<li>🌟🌟🌟<strong>WebSocket</strong> 是一种在单个 TCP 连接上进行全双工通信的协议，它是<strong>应用层</strong>协议<ul>
<li><strong>全双工通信</strong>：客户端和服务器之间可以同时发送和接收数据，实现真正的双向通信</li>
<li><strong>低延迟</strong>： 使用单个 TCP 连接，减少了建立连接和发送数据的延迟，实现更快的数据传输速度</li>
<li><strong>持久连接</strong>：WebSocket 连接是持久性的，与 HTTP 连接不同，它不需要在每次通信时重新建立连接，可以在连接保持的情况下连续发送数据</li>
<li><strong>与HTTP兼容</strong>：WebSocket 握手过程与 HTTP 兼容，可以通过标准的 HTTP 端口（通常是 80 和 443）进行通信，并且可以在现有的基础设施上轻松部署</li>
</ul>
</li>
<li>与WebSocket不同，<strong>Socket套接字</strong>，是位于<strong>应用层和传输控制层</strong>之间的一组<strong>接口</strong>，它是为了方便使用TCP&#x2F;UDP而抽象出来的，相当于使用了设计模式中的<strong>外观模式</strong>把复杂的TCP&#x2F;IP协议族隐藏，用它即可</li>
<li>总的来说，WebSocket 是一种高层次的协议，专门用于实时通信的 Web 应用程序，而 Socket 则是一种通用的底层网络通信接口，可以用于各种网络通信场景。WebSocket 可以看作是在 Socket 的基础上实现的一种高层次的应用层协议</li>
</ul>
<h3 id="Socket通信的流程？函数？"><a href="#Socket通信的流程？函数？" class="headerlink" title="Socket通信的流程？函数？"></a>Socket通信的流程？函数？</h3><blockquote>
<p>以下是TCP Socket通信的基本流程</p>
<p>对于UDP套接字，由于它是无连接的，所以没有“连接”和“监听”步骤，客户端可以直接进行数据发送和接受</p>
</blockquote>
<h4 id="服务端流程"><a href="#服务端流程" class="headerlink" title="服务端流程"></a>服务端流程</h4><ol>
<li>创建套接字：socket，指定使用的<strong>通信协议</strong>（IPv4 &#x2F; IPv6）、<strong>传输层协议</strong>（TCP &#x2F; UDP）</li>
<li><strong>绑定</strong>：bind，将套接字与本地IP地址和一个端口号关联</li>
<li><strong>监听</strong>：listen，服务端调用<code>listen()</code>将套接字设置为监听状态，指定等待连接请求的最大队列长度（此时服务器进入被动等待状态，等待客户端的连接请求）</li>
<li><strong>接受连接</strong>：客户端发起了连接请求，服务端<code>accept()</code>被唤醒并返回一个新的套接字（称为已连接套接字，这个新的套接字专用于与该客户端的后续通信），原监听套接字继续等待其他客户端的请求连接</li>
<li><strong>数据传输</strong>：使用新套接字上的<code>send()</code>和<code>recv()</code>进行数据的发送和接受，服务端与客户端通过这个新套接字进行TCP通信</li>
<li>关闭连接：当通信结束或出现异常时，服务器调用<code>close()</code>函数关闭已连接套接字，释放相关的系统资源。监听套接字通常保持打开状态，继续接受新的连接请求</li>
</ol>
<h4 id="客户端流程"><a href="#客户端流程" class="headerlink" title="客户端流程"></a>客户端流程</h4><ol>
<li>创建套接字</li>
<li><strong>连接</strong>：客户端调用<code>connect()</code>函数，指定要连接的服务器的IP地址和端口号。该操作发起一个连接请求到服务器，直到服务器端响应并建立连接</li>
<li><strong>数据传输</strong></li>
<li>关闭连接</li>
</ol>
<h3 id="🌟HTTP"><a href="#🌟HTTP" class="headerlink" title="🌟HTTP"></a>🌟HTTP</h3><h4 id="GET-POST请求有什么区别？"><a href="#GET-POST请求有什么区别？" class="headerlink" title="GET &#x2F; POST请求有什么区别？"></a>GET &#x2F; POST请求有什么区别？</h4><blockquote>
<p>GET 的语义是从服务器获取指定的资源，POST 的语义是根据请求负荷（报文body）对指定的资源做出处理</p>
</blockquote>
<ul>
<li><strong>传参方式不同</strong>：GET 请求将信息放在 URL，POST 将请求信息放在请求体中</li>
<li><strong>幂等和安全性不同</strong>：GET 符合幂等性和安全性，而 POST 请求不符合；</li>
</ul>
<blockquote>
<ul>
<li>「安全」是指请求方法不会「破坏」服务器上的资源</li>
<li>「幂等」意思是指多次执行相同的操作，结果都是「相同」的</li>
</ul>
</blockquote>
<ul>
<li><strong>可被缓存不同</strong>：GET可被缓存（缓存在浏览器本身上或者代理上(nginx)），POST不能被缓存</li>
</ul>
<h4 id="HTTP和HTTPS有什么区别？"><a href="#HTTP和HTTPS有什么区别？" class="headerlink" title="HTTP和HTTPS有什么区别？"></a>HTTP和HTTPS有什么区别？</h4><ul>
<li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。<strong>HTTPS 则解决 HTTP 不安全的缺陷</strong>，在 TCP 和 HTTP 网络层之间加入了 SSL&#x2F;TLS 安全协议，使得报文能够加密传输</li>
<li><strong>HTTP 连接建立相对简单</strong>， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL&#x2F;TLS 的握手过程，才可进入加密报文传输</li>
<li>两者的<strong>默认端口不一样</strong>，HTTP 默认端口号是 80，HTTPS 默认端口号是 443</li>
<li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的</li>
</ul>
<h4 id="HTTPS工作流程是怎样的？"><a href="#HTTPS工作流程是怎样的？" class="headerlink" title="HTTPS工作流程是怎样的？"></a>HTTPS工作流程是怎样的？</h4><blockquote>
<p>要点：<strong>公钥私钥、数字证书、加密、对称加密、非对称加密</strong></p>
</blockquote>
<ul>
<li>非对称密钥（服务端的公钥和私钥）用于安全地交换对称密钥</li>
<li>对称密钥则用于加密和解密实际的通信数据</li>
<li><strong>先用非对称加密得到密钥保证安全  后续使用对称加密保证效率</strong><img src="D:\desktop\面经高频问题.assets\image-20240310150939574.png"></li>
</ul>
<h3 id="🌟TCP"><a href="#🌟TCP" class="headerlink" title="🌟TCP"></a>🌟TCP</h3><h4 id="🌟详细说一下TCP三次握手机制？"><a href="#🌟详细说一下TCP三次握手机制？" class="headerlink" title="🌟详细说一下TCP三次握手机制？"></a>🌟详细说一下TCP三次握手机制？</h4><p><img src="D:\desktop\面经高频问题.assets\image-20240424170904687.png"></p>
<h5 id="为什么TCP三次握手不能是两次？"><a href="#为什么TCP三次握手不能是两次？" class="headerlink" title="为什么TCP三次握手不能是两次？"></a>为什么TCP三次握手不能是两次？</h5><ul>
<li><strong>确认双方的发送和接受能力</strong>：防止第二次握手成功后，服务端这时无法接收数据了，而客户端不知道，因此客户端叽里呱啦说了一大堆，服务端都没收到，浪费资源</li>
<li><strong>防止已失效的连接请求建立</strong>：如果一个已经失效的连接请求最终到达了服务器，而服务器误认为这是一个新的连接请求，那么它可能会再次建立连接。引发不必要的连接</li>
</ul>
<h4 id="🌟说说TCP四次挥手的过程？"><a href="#🌟说说TCP四次挥手的过程？" class="headerlink" title="🌟说说TCP四次挥手的过程？"></a>🌟说说TCP四次挥手的过程？</h4><p><img src="D:\desktop\面经高频问题.assets\image-20240310165132979.png"></p>
<h5 id="为什么TCP挥手需要四次呢？（重点在FIN）"><a href="#为什么TCP挥手需要四次呢？（重点在FIN）" class="headerlink" title="为什么TCP挥手需要四次呢？（重点在FIN）"></a>为什么TCP挥手需要四次呢？（重点在<strong>FIN</strong>）</h5><ul>
<li>关闭连接时，客户端向服务端发送<strong>FIN</strong>，表示客户端没数据要发了，但是还能接收数据</li>
<li>服务端收到FIN后，先回一个ACK，但服务端可能还有数据要发送，等服务端不再发送数据再给客户端发FIN表示同意现在关闭连接（因为服务端通常都需要有数据还要发送，所以服务端第二次挥手和第三次挥手的<strong>ACK和FIN分开发送</strong>，导致比三次握手多了一次）</li>
</ul>
<h5 id="TCP四次挥手的最后一次挥手后-为什么客户端需要等待2MSL才关闭？"><a href="#TCP四次挥手的最后一次挥手后-为什么客户端需要等待2MSL才关闭？" class="headerlink" title="TCP四次挥手的最后一次挥手后 为什么客户端需要等待2MSL才关闭？"></a>TCP四次挥手的最后一次挥手后 为什么客户端需要等待2MSL才关闭？</h5><blockquote>
<p>MSL：报文最大生存时间 它是任何报⽂在⽹络上存 在的最⻓时间，超过这个时间报⽂将被丢弃</p>
</blockquote>
<ol>
<li>保证客户端发送的最后一个ACK报文能够到达服务端</li>
<li>防止已经失效的连接请求报文出现在本连接中</li>
</ol>
<h5 id="🌟close-wait-和-time-wait-状态有什么意义？"><a href="#🌟close-wait-和-time-wait-状态有什么意义？" class="headerlink" title="🌟close-wait 和 time-wait 状态有什么意义？"></a>🌟close-wait 和 time-wait 状态有什么意义？</h5><ul>
<li>close_wait<ul>
<li>服务端收到客户端的关闭连接请求并确认之后就进入该状态</li>
<li>此时，服务端可能还有一些数据没有传输完毕，因此不能立即关闭连接</li>
<li>close_wait就是为了保证服务端在关闭连接之前将待发送的数据处理完</li>
</ul>
</li>
<li>time_wait（也就是为什么为什么需要等待2MSL后才关闭）<ul>
<li>发生在第四次挥手，当客户端向服务端发送最后一次ACK确认报文后进入time_wait状态</li>
<li>防止旧连接的数据包</li>
<li>保证连接正确关闭</li>
</ul>
</li>
</ul>
<h4 id="TCP如何保证连接可靠？"><a href="#TCP如何保证连接可靠？" class="headerlink" title="TCP如何保证连接可靠？"></a>TCP如何保证连接可靠？</h4><p><img src="D:\desktop\面经高频问题.assets\image-20240310171647231.png"></p>
<h4 id="🌟详细说说流量控制（滑动窗口）？"><a href="#🌟详细说说流量控制（滑动窗口）？" class="headerlink" title="🌟详细说说流量控制（滑动窗口）？"></a>🌟详细说说流量控制（滑动窗口）？</h4><p><img src="D:\desktop\面经高频问题.assets\image-20240402161930529.png"></p>
<p><img src="D:\desktop\面经高频问题.assets\image-20240402162056129.png"></p>
<h4 id="🌟详细说说拥塞控制？"><a href="#🌟详细说说拥塞控制？" class="headerlink" title="🌟详细说说拥塞控制？"></a>🌟详细说说拥塞控制？</h4><blockquote>
<p>拥塞控制是相对于整个网络拥堵状况来说的，避免整个网络水管接的太慢发的太快</p>
</blockquote>
<p>几个核心概念：</p>
<ul>
<li><strong>ssthresh</strong>：慢开始门限</li>
<li><strong>cwnd</strong>：拥塞窗口</li>
</ul>
<p><img src="D:\desktop\面经高频问题.assets\image-20240328233505085.png"></p>
<p>拥塞控制分为几个阶段：</p>
<ul>
<li><strong>慢开始</strong>：每轮cwnd翻倍，直到 <code>cwnd &gt;= ssthresh</code>就结束慢开始</li>
<li><strong>拥塞避免</strong>：慢开始结束后，开始执行拥塞避免，每轮<code>cwnd + 1</code></li>
<li><strong>拥塞发生</strong>：发生<strong>超时重传</strong>情况，则执行<strong>拥塞发生</strong>，设<code>cwnd = 1, ssthresh = 超时时的cwnd / 2</code></li>
<li><strong>快重传 &#x2F; 快恢复</strong>：发生收到（3-ACK）<strong>重复确认</strong>情况，则执行<strong>快重传&#x2F;快恢复</strong>，设<code>cwnd /= 2, ssthresh = cwnd</code>（也就是立刻开始拥塞避免）</li>
</ul>
<h4 id="TCP-UDP-区别？"><a href="#TCP-UDP-区别？" class="headerlink" title="TCP &#x2F; UDP 区别？"></a>TCP &#x2F; UDP 区别？</h4><p>最根本区别：<strong>TCP面向连接、可靠，而UDP是无连接、不可靠</strong></p>
<ul>
<li>UDP<strong>效率高、速度快、占用资源少、但是不保证可靠</strong>（适用即时性强但准确要求低的场景，如即时通讯）</li>
<li>TCP<strong>效率慢、占用资源多、但是保证可靠性</strong>（适用于准确率要求高但是速度可以相对慢，如收发邮件、文件传输）</li>
</ul>
<h1 id="计算机操作系统"><a href="#计算机操作系统" class="headerlink" title="计算机操作系统"></a>计算机操作系统</h1><h2 id="基础-2"><a href="#基础-2" class="headerlink" title="基础"></a>基础</h2><h3 id="操作系统的功能？"><a href="#操作系统的功能？" class="headerlink" title="操作系统的功能？"></a>操作系统的功能？</h3><blockquote>
<p>四大管理+用户接口</p>
</blockquote>
<ul>
<li>处理机管理</li>
<li>存储器管理</li>
<li>设备管理</li>
<li>文件管理</li>
<li>用户接口</li>
</ul>
<h3 id="操作系统的主要特性？"><a href="#操作系统的主要特性？" class="headerlink" title="操作系统的主要特性？"></a>操作系统的主要特性？</h3><ul>
<li>并发（不是并行，注意区分）</li>
<li>共享<ul>
<li>互斥共享（如打印机 不可同时 必须互斥）</li>
<li>同时访问（如磁盘可以同时读取）</li>
</ul>
</li>
<li>虚拟<ul>
<li>时分复用</li>
<li>空分复用</li>
</ul>
</li>
<li>异步<ul>
<li>并发环境下，程序的执行顺序、开始&#x2F;执行时间 不确定</li>
</ul>
</li>
</ul>
<h2 id="🌟🌟🌟进程与线程"><a href="#🌟🌟🌟进程与线程" class="headerlink" title="🌟🌟🌟进程与线程"></a>🌟🌟🌟进程与线程</h2><h4 id="🌟什么是进程和线程、协程？"><a href="#🌟什么是进程和线程、协程？" class="headerlink" title="🌟什么是进程和线程、协程？"></a>🌟什么是进程和线程、协程？</h4><p><img src="D:\desktop\面经高频问题.assets\image-20240329160821958.png"></p>
<ul>
<li><strong>进程</strong>：计算机中正在运行的一个程序实例。（如：打开的微信就是一个进程）</li>
<li><strong>线程</strong>：多个线程可以在同一个进程中同时执行，并且共享进程的资源（如：打开的微信里有个线程专门监控别人发给你的消息）</li>
<li><strong>协程</strong>：是一种用户态的轻量级线程，协程的调度<strong>完全由用户控制</strong>（也就是在用户态执行）</li>
</ul>
<h4 id="进程和线程的区别？"><a href="#进程和线程的区别？" class="headerlink" title="进程和线程的区别？"></a>进程和线程的区别？</h4><ul>
<li>线程是进程划分成的更小的运行单位,一个进程在其执行的过程中可以产生多个线程。</li>
<li>线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。</li>
<li>线程执行开销小，但不利于资源的管理和保护；而进程正相反。</li>
</ul>
<h4 id="🌟为什么有进程还要线程？"><a href="#🌟为什么有进程还要线程？" class="headerlink" title="🌟为什么有进程还要线程？"></a>🌟为什么有进程还要线程？</h4><ul>
<li>进程切换开销太大，线程切换成本低</li>
<li>多线程利于高并发性能高</li>
<li>线程之间可以共享进程的内存和文件，无需像进程之间通信需要调用内核</li>
</ul>
<h4 id="进程有哪些状态？"><a href="#进程有哪些状态？" class="headerlink" title="进程有哪些状态？"></a>进程有哪些状态？</h4><ul>
<li>创建</li>
<li><strong>就绪</strong></li>
<li><strong>运行</strong></li>
<li><strong>阻塞</strong></li>
<li>结束</li>
</ul>
<h4 id="什么是互斥和同步？"><a href="#什么是互斥和同步？" class="headerlink" title="什么是互斥和同步？"></a>什么是互斥和同步？</h4><ul>
<li>互斥：间接制约关系，源于<strong>资源共享</strong>，如：打印机资源，不可同时使用</li>
<li>同步：直接制约关系，源于<strong>进程&#x2F;线程间的合作</strong>，如：A、B合作完成一件事，A做完了B才能接着做</li>
<li><strong>同步机制应该遵循的原则</strong>：<ul>
<li>空闲让进</li>
<li>忙则等待</li>
<li>有限等待</li>
<li><strong>让权等待</strong>：当进程&#x2F;线程无法获取自己所需资源时，应立即释放处理机，以免进程陷入“忙等”</li>
</ul>
</li>
</ul>
<h4 id="🌟🌟🌟进程-线程间如何同步？"><a href="#🌟🌟🌟进程-线程间如何同步？" class="headerlink" title="🌟🌟🌟进程&#x2F;线程间如何同步？"></a>🌟🌟🌟进程&#x2F;线程间如何同步？</h4><blockquote>
<p>同步的主要任务是对多个相关进程<strong>在执行次序上</strong>进行协调，以使并发执行的诸进程之间能有效的共享资源和相互合作，从而使程序的执行具有可再现性</p>
</blockquote>
<ul>
<li>互斥锁：加锁解锁，挨个访问共享资源。例如Java中的<code>synchronized</code></li>
<li>🌟<strong>信号量</strong><ul>
<li>整型信号量（和CAS自旋锁思想相同）<img src="D:\desktop\面经高频问题.assets\image-20240413134641737.png"></li>
<li><strong>记录型信号量</strong><img src="D:\desktop\面经高频问题.assets\image-20240413134854358.png"></li>
</ul>
</li>
</ul>
<h4 id="🌟进程通信方式有哪些？"><a href="#🌟进程通信方式有哪些？" class="headerlink" title="🌟进程通信方式有哪些？"></a>🌟进程通信方式有哪些？</h4><blockquote>
<p>每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以<strong>进程之间要通信必须通过内核</strong></p>
</blockquote>
<h5 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h5><ul>
<li>匿名管道：用完即销毁（只能用于存在父子关系的进程）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps auxf | grep mysql</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Linux命令里的 “|”就是一个匿名管道，功能是将前一个命令的输出作为后一个命令的输入</span></span><br></pre></td></tr></table></figure>

<ul>
<li>命名管道：FIFO，需要使用前通过<code>mkfifo</code>命令创建并指定名字（可以在不相关之间的进程）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkfifo</span> myPipe <span class="comment"># myPipe就是管道的的名字</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> &gt; myPipe  <span class="comment"># 将数据写进管道</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> &lt; myPipe  <span class="comment"># 读取管道里的数据</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>好处：简单、同时很容易得知管道里的数据已经被另一个进程读取了</li>
<li>坏处：效率低、只能单向通信、不适合进程间频繁交换数据</li>
</ul>
<h5 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h5><blockquote>
<p><strong>消息队列是保存在内核中的消息链表</strong></p>
</blockquote>
<ul>
<li>好处：解决管道不适合频繁交换数据的问题</li>
<li>坏处：通信不及时、消息附件也有大小限制、不适合比较大数据的传输、通信过程中存在用户态与内核态之间的数据拷贝开销</li>
</ul>
<h5 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h5><blockquote>
<p><strong>共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中</strong></p>
</blockquote>
<p><img src="D:\desktop\面经高频问题.assets\image-20240413124858816.png"></p>
<ul>
<li>好处：解决了（消息队列中的）用户态与内核态之间的数据拷贝开销、<strong>大大提高了进程间通信的速度</strong></li>
<li>坏处：多进程同时访问共享内存时候，需要进行<strong>同步</strong>，造成额外开销</li>
</ul>
<h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><blockquote>
<p>为了<strong>解决多进程竞争共享资源</strong>的问题，信号量就实现了这个<strong>同步机制</strong></p>
<p>信号量的主要目的是<strong>确保进程同步和互斥</strong>，但在某些情况下，它也可以作为一种基本的通信机制</p>
</blockquote>
<h5 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h5><blockquote>
<p>前面提提到的都是在同一台主机上进行进程间通信，</p>
<p>跨网络与不同主机上的进程之间通信，就需要Socket了</p>
</blockquote>
<h4 id="进程调度算法有哪些？"><a href="#进程调度算法有哪些？" class="headerlink" title="进程调度算法有哪些？"></a>进程调度算法有哪些？</h4><ul>
<li>先来先服务</li>
<li>短作业优先</li>
<li>时间片轮转</li>
<li>多级反馈队列（目前公认较好的一种）</li>
<li>高响应比优先</li>
</ul>
<h4 id="什么是僵尸进程和孤儿进程？"><a href="#什么是僵尸进程和孤儿进程？" class="headerlink" title="什么是僵尸进程和孤儿进程？"></a>什么是僵尸进程和孤儿进程？</h4><ul>
<li>僵尸进程：一个进程已经完成执行，但是其父进程尚未对其进行善后处理，仍在继续占用系统资源</li>
<li>孤儿进程：一个进程，它的父进程已经退出或被终止，但它仍在系统中运行</li>
</ul>
<h4 id="如何查看是否有僵尸进程？"><a href="#如何查看是否有僵尸进程？" class="headerlink" title="如何查看是否有僵尸进程？"></a>如何查看是否有僵尸进程？</h4><ul>
<li><strong>top命令</strong>查看是否有僵尸进程<img src="D:\desktop\面经高频问题.assets\image-20240329165716710.png"></li>
<li>zombie数量不为0时，<strong>ps命令和grep</strong>定位僵尸进程（查询状态为Zz的进程）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -A -ostat,ppid,pid,cmd | grep -e &#x27;^[Zz]&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>kill命令</strong>杀死僵尸进程或者父进程即可</li>
</ul>
<h4 id="🌟🌟🌟死锁"><a href="#🌟🌟🌟死锁" class="headerlink" title="🌟🌟🌟死锁"></a>🌟🌟🌟死锁</h4><h5 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h5><ul>
<li>多个进程&#x2F;线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于进程&#x2F;线程被无限期地阻塞，因此程序不可能正常终止</li>
</ul>
<h5 id="产生死锁的必要条件？"><a href="#产生死锁的必要条件？" class="headerlink" title="产生死锁的必要条件？"></a>产生死锁的必要条件？</h5><ul>
<li>互斥</li>
<li>请求和保持</li>
<li>不可抢占</li>
<li>循环等待</li>
</ul>
<h5 id="如何解决死锁？"><a href="#如何解决死锁？" class="headerlink" title="如何解决死锁？"></a>如何解决死锁？</h5><blockquote>
<p>解决死锁从多个角度分析：预防、避免、检测和解除</p>
</blockquote>
<ul>
<li><strong>预防</strong>：<strong>限制并发进程对资源的请求</strong>，使得任何时候都不可能满足死锁的必要条件</li>
<li><strong>避免</strong>：系统在分配资源时，根据资源的使用情况<strong>提前做出预测</strong>，从而<strong>避免死锁的发生</strong></li>
<li><strong>检测</strong>：系统内有<strong>专门的机构</strong>，死锁发生时该机构能检测到，并确定死锁相关的进程和资源</li>
<li><strong>解除</strong>：是与检测相配套的一种措施，用于<strong>将进程从死锁状态下解脱出来</strong>。</li>
</ul>
<h5 id="如何避免死锁？"><a href="#如何避免死锁？" class="headerlink" title="如何避免死锁？"></a>如何避免死锁？</h5><blockquote>
<p>预防死锁，本质上就是破坏四个必要条件之一（<strong>互斥</strong>不能破坏）</p>
</blockquote>
<ul>
<li>破坏<strong>不可抢占</strong>：也就是采用 <strong>剥夺式调度算法</strong>（不适用所有类型的资源，且导致资源利用率下降）</li>
<li>所以一般考虑破坏 <strong>请求和保持</strong> 和 <strong>循环等待</strong></li>
<li>🌟🌟🌟大名鼎鼎的<strong>银行家算法</strong>（安全分配资源）（避免死锁算法而非解除！）</li>
</ul>
<blockquote>
<p>当一个进程申请使用资源的时候，银行家算法通过先 <strong>试探</strong> 分配给该进程资源，然后通过安全性算法判断分配后的系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待</p>
</blockquote>
<p><img src="D:\desktop\面经高频问题.assets\image-20240329173611258.png"></p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h4 id="内存管理主要做了什么？"><a href="#内存管理主要做了什么？" class="headerlink" title="内存管理主要做了什么？"></a>内存管理主要做了什么？</h4><ul>
<li><strong>内存分配</strong></li>
<li><strong>内存保护</strong>：硬件检查越界，软件中断处理</li>
<li><strong>地址映射</strong>：逻辑地址 -&gt; 物理地址</li>
<li><strong>内存扩充</strong>：虚拟存储技术</li>
</ul>
<h4 id="有哪些内存分配方式？"><a href="#有哪些内存分配方式？" class="headerlink" title="有哪些内存分配方式？"></a>有哪些内存分配方式？</h4><ul>
<li>连续</li>
</ul>
<blockquote>
<p>连续分配会形成“碎片”，尽管有算法“紧凑&#x2F;拼接”也会有浪费，因此产生离散分配</p>
</blockquote>
<pre><code>- 单一（只分系统区和用户区）
- 固定（内存可用区分为若干个大小固定的，一个分区就装一道作业）
- 动态（事先不划分，待需要时再按需分配）（因此需要如下的算法决定如何分配）
    * 首次适应
    * 循环首次适应
    * 最佳适应
    * 最坏适应
</code></pre>
<ul>
<li>离散</li>
</ul>
<blockquote>
<p><strong>页</strong>是信息的<strong>物理单位</strong>，<strong>段</strong>是信息的<strong>逻辑单位</strong></p>
</blockquote>
<pre><code>- 分页：内存分为固定大小的物理页（按物理大小分）
- 分段：内存分为若干个段（一个段是相同逻辑的信息，如主程序、子程序等）（按逻辑分）
- 段页式：段和页各取所长，内存先分为若干段，再把每段分为若干页
</code></pre>
<h4 id="虚拟内存？"><a href="#虚拟内存？" class="headerlink" title="虚拟内存？"></a>虚拟内存？</h4><blockquote>
<p>是指具有<strong>请求调入功能和置换功能</strong>，能<strong>从逻辑上</strong>对内存容量加以扩充的一种存储系统</p>
</blockquote>
<ul>
<li>基本原理<ul>
<li>部分装入</li>
<li>请求调页</li>
<li>页面置换</li>
</ul>
</li>
<li>存储管理方式<ul>
<li>请求分页（相比普通分页多了<strong>缺页中断机构</strong>，下同理）</li>
<li>请求分段</li>
</ul>
</li>
<li>🌟页面置换算法<ul>
<li>最佳置换算法OPT<ul>
<li>一种理论上的算法，实际不可能实现</li>
<li>选择以后永不使用的或者未来最长时间内不再使用的页面淘汰</li>
</ul>
</li>
<li>先进先出FIFO<ul>
<li>选择在内存中驻留时间最长的页面淘汰</li>
</ul>
</li>
<li>最近最久未使用LRU<ul>
<li>选择最近最久未使用的页面进行淘汰——用“最近的过去”作为“最近的将来”的类似</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h4 id="文件管理做了什么？"><a href="#文件管理做了什么？" class="headerlink" title="文件管理做了什么？"></a>文件管理做了什么？</h4><ul>
<li>存储管理</li>
<li>文件管理</li>
<li>目录管理</li>
<li>文件访问控制</li>
</ul>
<h4 id="磁盘调度算法？"><a href="#磁盘调度算法？" class="headerlink" title="磁盘调度算法？"></a>磁盘调度算法？</h4><ul>
<li>先来先服务</li>
<li>最短寻道时间优先</li>
<li>扫描算法</li>
<li>循环扫描算法</li>
</ul>
<h2 id="🌟🌟🌟I-O多路复用"><a href="#🌟🌟🌟I-O多路复用" class="headerlink" title="🌟🌟🌟I&#x2F;O多路复用"></a>🌟🌟🌟I&#x2F;O多路复用</h2><h4 id="简单说说什么是I-O多路复用？"><a href="#简单说说什么是I-O多路复用？" class="headerlink" title="简单说说什么是I&#x2F;O多路复用？"></a>简单说说什么是I&#x2F;O多路复用？</h4><blockquote>
<p>一个单独的线程或进程可以同时处理多个I&#x2F;O操作，不必耗费时间和资源创建多个线程或进程，提高了程序的并发性和效率</p>
</blockquote>
<p><strong>概念</strong>：I&#x2F;O多路复用通过使用特定的<strong>系统调用</strong>（如select、poll、epoll等）可以同时监视多个I&#x2F;O事件，一旦其中任何一个I&#x2F;O事件就绪（例如，可以读取数据或写入数据），程序就会得到通知，然后可以针对这个就绪的事件进行相应的处理。</p>
<p>可以先举例说明：<br>假设你是一个老师，让30个 学生解答一道题目，然后检查学生做的是否正确，你有下面几个选择</p>
<ol>
<li>按顺序逐个检查，这中间如果有一个学生卡住，全班都会被耽误（<strong>同步阻塞</strong>）</li>
<li>按顺序逐个检查，这中间如果有一个学生卡住，直接跳过，去看后面的（<strong>同步非阻塞</strong>）</li>
<li>你站在讲台上等，谁解答完谁举手，谁举手你下去检查谁的答案，然后再回讲台等着（<strong>多路复用</strong>）</li>
</ol>
<h4 id="有哪些实现方式？"><a href="#有哪些实现方式？" class="headerlink" title="有哪些实现方式？"></a>有哪些实现方式？</h4><blockquote>
<p>原理比较难，不详细叙述，就用上面 老师-学生 的模型来看</p>
</blockquote>
<ul>
<li><strong>select &#x2F; poll</strong>：学生写完了作业会举手，但是你不知道是谁举手，需要一个个的去询问二者区别在于（没有本质区别，但是有小区别）<ul>
<li>select 的 文件描述符（也就是所有学生） 用<strong>long[1024]数组</strong>存储，而poll是基于<strong>链表</strong></li>
<li>select 对 学生个数作了限制（内核限制为1024个），而 poll无限制</li>
</ul>
</li>
<li>🌟<strong>epoll</strong>：学生写完了作业会举手，你知道是谁举手，你直接去收作业<strong>简单原理</strong>在于：epoll 用<strong>红黑树</strong>来跟踪存储所有待检测的文件描述符（所有学生），并维护了一个链表来记录就绪事件（也就是举手的学生）epoll的<strong>巨大优点</strong>在于：<ul>
<li>没有最大并发连接的限制</li>
<li>🌟不采取轮询所有连接的方式，效率高，只会处理活跃的连接，与连接总数无关</li>
</ul>
</li>
</ul>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h2><ol>
<li>单一职责原则：一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中</li>
<li>开闭原则：软件实体（如类&#x2F;模块&#x2F;函数等）应当对扩展开放，对修改关闭</li>
<li>里式替换原则：所有使用父类的地方都必须能够无缝地替换为子类，而不会引发任何错误或异常</li>
<li>依赖倒转原则：高层模块不应依赖于底层模块，它们都应该依赖抽象。抽象不应依赖于具体实现，具体实现应该依赖于抽象。</li>
<li>接口隔离原则：客户端不应该依赖于它们不需要的接口。接口应该尽可能地小，精确地满足客户端的需求。</li>
<li>合成复用原则：实现代码复用应该优先使用对象组合，而不是通过继承来达到复用的目的。</li>
<li><strong>迪米特法则</strong>（最少知识原则）：一个类&#x2F;模块对其他的类&#x2F;模块有越少的交互越好</li>
</ol>
<h2 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h2><p>关注的是如何更有效地<strong>创建对象，封装对象</strong>的创建过程，以及降低系统中对象之间的耦合度</p>
<ol>
<li>🌟<strong>工厂方法模式</strong>：定义一个用于创建对象的接口，但由子类决定实例化哪个类。工厂方法模式将对象的实例化延迟到其子类（相当于生产XX手机的工厂）</li>
<li>抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们的具体类。（相当于生产手机的工厂，不特定生产的是什么手机）</li>
<li>建造者模式：相比直接去new一个新的对象，建造者模式的重心更加关注在如何完成每一步的配置。适用于需要构建多个步骤的对象，例如构建复杂的产品对象</li>
<li>单例模式：确保一个类只有一个实例，并提供全局访问点。单例模式通常用于管理共享资源，例如数据库连接、线程池等</li>
<li>原型模式：用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象</li>
</ol>
<h2 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h2><p>结构型设计模式关注如何<strong>将现有的类或对象组织在一起形成更加强大的结构</strong></p>
<ol>
<li>类&#x2F;对象适配器模式：将一个类的接口转换成客户端所期望的另一个接口，以解决接口不兼容的问题（就像USB-typec等转接头）</li>
<li>桥接模式：将抽象部分与它的实现部分分离，以便它们可以独立地变化（例如点奶茶先问你要大杯小杯、加不加芋泥啵啵等条件）</li>
<li>组合模式：将对象组合成树形结构以表示“部分-整体”的层次结构。通过组合模式，客户端可以统一对待单个对象和组合对象（例如电脑的文件夹和文件系统）</li>
<li><strong>装饰模式</strong>：动态地给对象添加额外的功能，而不需要通过继承来实现。装饰模式通过将对象包装在装饰器对象中来实现功能的动态添加。（装饰器模式）</li>
<li>代理模式：为其它对象提供一个代理或占位符，以控制对这个对象的访问。与装饰模式区别是，A代理了B，访问B就是访问A，A装饰了B，访问B还是访问B本身。</li>
<li><strong>外观模式</strong>：为复杂的子系统提供一个简化的接口，以方便客户端使用。（相当于加一个代办处，不用去各个部门自行办理不同的业务）</li>
<li>享元模式：通过共享对象来减少系统中对象的数量，从而节省内存和提高性能。</li>
</ol>
<h2 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h2><p>行为型设计模式是一类解决<strong>对象之间交互、协作和责任分配</strong>的设计模式。它们关注的是<strong>对象之间的行为和职责分配</strong>，以及如何<strong>有效地管理和组织对象之间的交互</strong></p>
<ol>
<li>模版方法模式：定义一个算法的骨架，将具体步骤的实现延迟到子类中。模板方法模式使得子类可以重新定义算法的某些步骤，而不需要改变算法的结构</li>
<li>🌟<strong>责任链模式</strong>：为了解耦请求发送者和接收者之间的关系，将多个处理器组成一个链，每个处理器都有机会处理请求，直到请求被处理完成（例如Security的过滤器链）</li>
<li>命令模式：将一个请求封装成一个对象，从而使得请求的发送者和接收者之间解耦。（相当于有一个遥控器给各个模块发请求）</li>
<li>中介者模式：（相当于搞一个中介，想找别人先找它，将原本的复杂多对多简化为一对多）</li>
<li>备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以后可以将该对象恢复到之前保存的状态（相当于写了个备忘录记录当前的状态，以后可以恢复）</li>
<li>观察者模式：定义了一种一对多的依赖关系，使得当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并自动更新（监听的事件触发，就通知订阅的人）</li>
<li>状态模式：允许对象在其内部状态发生改变时改变其行为，使得对象看起来像是修改了其类</li>
<li><strong>策略模式</strong>：定义一系列算法，将每个算法封装起来，并使它们可以相互替换。策略模式使得算法可以独立于客户端而变化，提高了系统的灵活性（例如线程池拒绝策略）</li>
<li>访问者模式：用于在不改变已有类的前提下，为类增加新的操作（访问者不能修改被访问元素，只能访问）</li>
</ol>
<h1 id="栢码项目面经"><a href="#栢码项目面经" class="headerlink" title="栢码项目面经#"></a>栢码项目面经<a href="https://flapypan.netlify.app/posts/%E6%A0%A2%E7%A0%81%E9%A1%B9%E7%9B%AE%E9%9D%A2%E7%BB%8F/#%E6%A0%A2%E7%A0%81%E9%A1%B9%E7%9B%AE%E9%9D%A2%E7%BB%8F">#</a></h1><p>收集了栢码群里面用栢码项目相关的面经。</p>
<h2 id="介绍一下-Jwt，为什么用-jwt，对比-session-方案的好处和坏处"><a href="#介绍一下-Jwt，为什么用-jwt，对比-session-方案的好处和坏处" class="headerlink" title="介绍一下 Jwt，为什么用 jwt，对比 session 方案的好处和坏处#"></a>介绍一下 Jwt，为什么用 jwt，对比 session 方案的好处和坏处<a href="https://flapypan.netlify.app/posts/%E6%A0%A2%E7%A0%81%E9%A1%B9%E7%9B%AE%E9%9D%A2%E7%BB%8F/#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-jwt%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8-jwt%E5%AF%B9%E6%AF%94-session-%E6%96%B9%E6%A1%88%E7%9A%84%E5%A5%BD%E5%A4%84%E5%92%8C%E5%9D%8F%E5%A4%84">#</a></h2><p>jwt 的优点：</p>
<ul>
<li>可扩展性好。应用程序分布式部署的情况下，session 需要做多机数据共享，通常可以存在数据库或者 redis 里面。而 jwt 不需要。</li>
<li>无状态。jwt 不在服务端存储任何状态。jwt 的载荷中可以存储一些常用信息，用于交换信息，有效地使用 JWT，可以降低服务器查询数据库的次数。</li>
</ul>
<p>jwt 的缺点：</p>
<ul>
<li>安全性。由于 jwt 的 payload 是使用 base64 编码的，并没有加密，因此 jwt 中不能存储敏感数据。而 session 的信息是存在服务端的，相对来说更安全。</li>
<li>性能。由于是无状态使用 JWT，所有的数据都被放到 JWT 里，如果还要进行一些数据交换，那载荷会更大，经过编码之后导致 jwt 非常长，cookie 的限制大小一般是 4k，cookie 很可能放不下，所以 jwt 一般放在 local storage 里面。并且用户在系统中的每一次 http 请求都会把 jwt 携带在 Header 里面，http 请求的 Header 可能比 Body 还要大。而 sessionId 只是很短的一个字符串，因此使用 jwt 的 http 请求比使用 session 的开销大得多。</li>
<li>一次性。无状态是 jwt 的特点，但也导致了这个问题，jwt 是一次性的。想修改里面的内容，就必须签发一个新的 jwt。</li>
<li>无法废弃。一旦签发一个 jwt，在到期之前就会始终有效，无法中途废弃。例如你在 payload 中存储了一些信息，当信息需要更新时，则重新签发一个 jwt，但是由于旧的 jwt 还没过期，拿着这个旧的 jwt 依旧可以登录，那登录后服务端从 jwt 中拿到的信息就是过时的。为了解决这个问题，我们就需要在服务端部署额外的逻辑，例如设置一个黑名单，一旦签发了新的 jwt，那么旧的就加入黑名单（比如存到 redis 里面），避免被再次使用。</li>
<li>续签。传统的 cookie 续签方案一般都是框架自带的，session 有效期 30 分钟，30 分钟内如果有访问，有效期被刷新至 30 分钟。一样的道理，要改变 jwt 的有效时间，就要签发新的 jwt。最简单的一种方式是每次请求刷新 jwt，即每个 http 请求都返回一个新的 jwt。这个方法不仅暴力不优雅，而且每次请求都要做 jwt 的加密解密，会带来性能问题。另一种方法是在 redis 中单独为每个 jwt 设置过期时间，每次访问时刷新 jwt 的过期时间。</li>
</ul>
<blockquote>
<p>JWT 参考：<a href="https://www.itbaima.cn/document/wci9lb9tgea866jt">https://www.itbaima.cn/document/wci9lb9tgea866jt</a></p>
</blockquote>
<h2 id="你的项目用了-spring-boot-3，相对-2-有什么不同-提到了-swagger-不适配"><a href="#你的项目用了-spring-boot-3，相对-2-有什么不同-提到了-swagger-不适配" class="headerlink" title="你的项目用了 spring boot 3，相对 2 有什么不同 (提到了 swagger 不适配?)#"></a>你的项目用了 spring boot 3，相对 2 有什么不同 (提到了 swagger 不适配?)<a href="https://flapypan.netlify.app/posts/%E6%A0%A2%E7%A0%81%E9%A1%B9%E7%9B%AE%E9%9D%A2%E7%BB%8F/#%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%94%A8%E4%BA%86-spring-boot-3%E7%9B%B8%E5%AF%B9-2-%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C-%E6%8F%90%E5%88%B0%E4%BA%86-swagger-%E4%B8%8D%E9%80%82%E9%85%8D">#</a></h2><p>spring boot 3 和 spring boot 2 的部分区别：</p>
<ol>
<li>最低环境。SpringBoot2 的最低版本要求为 Java8，支持 Java9；而 SpringBoot3 决定使用 Java17 作为最低版本，并支持 Java19。Spring Boot2 基于 Spring Framework5 开发；而 SpringBoot3 构建基于 Spring Framework6 之上，需要使用 Spring Framework6。</li>
<li>GraalVM 支持。相比 SpringBoot2，SpringBoot3 的 Spring Native 也是升级的一个重大特性，支持使用 GraalVM 将 Spring 的应用程序编译成本地可执行的镜像文件，可以显著提升启动速度、峰值性能以及减少内存使用。</li>
</ol>
<blockquote>
<p>GraalVm 配置参考：<a href="https://www.itbaima.cn/space/project/deploy/8">https://www.itbaima.cn/space/project/deploy/8</a></p>
</blockquote>
<ol start="3">
<li>图片 Banner。在 SpringBoot2 中，自定义 Banner 支持图片类型；而现在 Spring Boot3 自定义 Banner 只支持文本类型（banner.txt），不再支持图片类型。</li>
<li>依赖项。删除了对一些附加依赖项的支持，包括 Apache ActiveMQ、Atomikos、EhCache2 和 HazelCast3。</li>
<li>Java EE 已经变更为 Jakarta EE（javax.servlet.Filter 要改为 jakarta.servlet.Filter）。</li>
</ol>
<p>swagger 问题：</p>
<ul>
<li>使用 springdoc (<a href="https://springdoc.org/">https://springdoc.org/)。</a>。)</li>
<li>使用 springfox (<a href="http://springfox.io/">http://springfox.io/</a>)</li>
</ul>
<h2 id="Spring-security-你是如何配置的，filter-是怎么编写的"><a href="#Spring-security-你是如何配置的，filter-是怎么编写的" class="headerlink" title="Spring security 你是如何配置的，filter 是怎么编写的#"></a>Spring security 你是如何配置的，filter 是怎么编写的<a href="https://flapypan.netlify.app/posts/%E6%A0%A2%E7%A0%81%E9%A1%B9%E7%9B%AE%E9%9D%A2%E7%BB%8F/#spring-security-%E4%BD%A0%E6%98%AF%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E7%9A%84filter-%E6%98%AF%E6%80%8E%E4%B9%88%E7%BC%96%E5%86%99%E7%9A%84">#</a></h2><p>新版 security 配置全面采用了 lambda 表达式来配置，例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception &#123;</span><br><span class="line">        http.csrf(AbstractHttpConfigurer::disable);</span><br><span class="line">        http.formLogin(formLogin -&gt; formLogin</span><br><span class="line">                .loginProcessingUrl(&quot;/auth/login&quot;)</span><br><span class="line">                .successHandler((request, response, authentication) -&gt; &#123;&#125;)</span><br><span class="line">                .failureHandler((request, response, authentication) -&gt; &#123;&#125;));</span><br><span class="line">        http.logout(logout -&gt; logout</span><br><span class="line">                .logoutUrl(&quot;/auth/logout&quot;)</span><br><span class="line">                .logoutSuccessHandler((request, response, authentication) -&gt; &#123;&#125;));</span><br><span class="line">        http.authorizeHttpRequests(request -&gt; request</span><br><span class="line">                .requestMatchers(&quot;/auth/**&quot;)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .anyRequest()</span><br><span class="line">                .authenticated()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        return http.build();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>可参考：<a href="https://www.itbaima.cn/document/wci9lb9tgea866jt">https://www.itbaima.cn/document/wci9lb9tgea866jt</a></p>
</blockquote>
<h2 id="为什么用-RabbitMQ-而不创建多个线程"><a href="#为什么用-RabbitMQ-而不创建多个线程" class="headerlink" title="为什么用 RabbitMQ 而不创建多个线程#"></a>为什么用 RabbitMQ 而不创建多个线程<a href="https://flapypan.netlify.app/posts/%E6%A0%A2%E7%A0%81%E9%A1%B9%E7%9B%AE%E9%9D%A2%E7%BB%8F/#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8-rabbitmq-%E8%80%8C%E4%B8%8D%E5%88%9B%E5%BB%BA%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B">#</a></h2><p>任何 MQ 相关的问题，优先想到“异步”、“解耦”。</p>
<ol>
<li>提高系统稳定性，系统 down 了，消息是在外部的不会丢失。</li>
<li>线程会占用资源，消息队列就可以把发短信的操作放到其他机器。</li>
<li>架构思想，应用服务尽量只做逻辑，数据放外部。</li>
</ol>
<blockquote>
<p>可参考：<a href="https://www.itbaima.cn/document/a782u84512tyuo1m">https://www.itbaima.cn/document/a782u84512tyuo1m</a></p>
</blockquote>
<h2 id="为什么要编写工具转换-DTO-和-VO，相比-BeanUtils-copyProperties-有优势吗，运用反射是不是效率比较低"><a href="#为什么要编写工具转换-DTO-和-VO，相比-BeanUtils-copyProperties-有优势吗，运用反射是不是效率比较低" class="headerlink" title="为什么要编写工具转换 DTO 和 VO，相比 BeanUtils.copyProperties 有优势吗，运用反射是不是效率比较低#"></a>为什么要编写工具转换 DTO 和 VO，相比 BeanUtils.copyProperties 有优势吗，运用反射是不是效率比较低<a href="https://flapypan.netlify.app/posts/%E6%A0%A2%E7%A0%81%E9%A1%B9%E7%9B%AE%E9%9D%A2%E7%BB%8F/#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%BC%96%E5%86%99%E5%B7%A5%E5%85%B7%E8%BD%AC%E6%8D%A2-dto-%E5%92%8C-vo%E7%9B%B8%E6%AF%94-beanutilscopyproperties-%E6%9C%89%E4%BC%98%E5%8A%BF%E5%90%97%E8%BF%90%E7%94%A8%E5%8F%8D%E5%B0%84%E6%98%AF%E4%B8%8D%E6%98%AF%E6%95%88%E7%8E%87%E6%AF%94%E8%BE%83%E4%BD%8E">#</a></h2><p>（表达意思：我会玩反射）</p>
<p>BeanUtils.copyProperties 底层也是反射，但 spring 做了大量逻辑优化和缓存优化，性能不会很低。</p>
<blockquote>
<p>反射参考：<a href="https://www.itbaima.cn/document/lfqtvxr7azumcwja">https://www.itbaima.cn/document/lfqtvxr7azumcwja</a></p>
</blockquote>
<h2 id="介绍一下限流工具类的功能，redis-的键值分别是什么，redis-中用什么数据结构储存黑名单，假如有几十万个-ip-请求，都要记录在-redis-吗，是不是太消耗资源"><a href="#介绍一下限流工具类的功能，redis-的键值分别是什么，redis-中用什么数据结构储存黑名单，假如有几十万个-ip-请求，都要记录在-redis-吗，是不是太消耗资源" class="headerlink" title="介绍一下限流工具类的功能，redis 的键值分别是什么，redis 中用什么数据结构储存黑名单，假如有几十万个 ip 请求，都要记录在 redis 吗，是不是太消耗资源#"></a>介绍一下限流工具类的功能，redis 的键值分别是什么，redis 中用什么数据结构储存黑名单，假如有几十万个 ip 请求，都要记录在 redis 吗，是不是太消耗资源<a href="https://flapypan.netlify.app/posts/%E6%A0%A2%E7%A0%81%E9%A1%B9%E7%9B%AE%E9%9D%A2%E7%BB%8F/#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E9%99%90%E6%B5%81%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E5%8A%9F%E8%83%BDredis-%E7%9A%84%E9%94%AE%E5%80%BC%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88redis-%E4%B8%AD%E7%94%A8%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%82%A8%E5%AD%98%E9%BB%91%E5%90%8D%E5%8D%95%E5%81%87%E5%A6%82%E6%9C%89%E5%87%A0%E5%8D%81%E4%B8%87%E4%B8%AA-ip-%E8%AF%B7%E6%B1%82%E9%83%BD%E8%A6%81%E8%AE%B0%E5%BD%95%E5%9C%A8-redis-%E5%90%97%E6%98%AF%E4%B8%8D%E6%98%AF%E5%A4%AA%E6%B6%88%E8%80%97%E8%B5%84%E6%BA%90">#</a></h2><p>限流工具类的功能：限流（难道还有其他功能？）</p>
<p>限流工具类 的 redis 的键值分别是什么：key 是 ip 地址，value 是访问次数</p>
<p>ip 黑名单存储结构：字符串（简单高效！）</p>
<p>几十万个 ip 请求：这个量 redis 完全存的下，如果占用太高可以考虑转为无符号整型</p>
<blockquote>
<p>栢码视频：<a href="https://www.bilibili.com/video/BV1Pz4y1W7TN/?p=21">https://www.bilibili.com/video/BV1Pz4y1W7TN/?p=21</a></p>
<p>redis 参考：<a href="https://www.itbaima.cn/document/35v1hbsfcdgagdnw">https://www.itbaima.cn/document/35v1hbsfcdgagdnw</a></p>
</blockquote>
<h2 id="Redis-集群有搭建过吗"><a href="#Redis-集群有搭建过吗" class="headerlink" title="Redis 集群有搭建过吗#"></a>Redis 集群有搭建过吗<a href="https://flapypan.netlify.app/posts/%E6%A0%A2%E7%A0%81%E9%A1%B9%E7%9B%AE%E9%9D%A2%E7%BB%8F/#redis-%E9%9B%86%E7%BE%A4%E6%9C%89%E6%90%AD%E5%BB%BA%E8%BF%87%E5%90%97">#</a></h2><blockquote>
<p>栢码视频：<a href="https://www.bilibili.com/video/BV1AL4y1j7RY?p=46">https://www.bilibili.com/video/BV1AL4y1j7RY?p=46</a></p>
</blockquote>
<h2 id="Minio-如何实现文件的存取"><a href="#Minio-如何实现文件的存取" class="headerlink" title="Minio 如何实现文件的存取#"></a>Minio 如何实现文件的存取<a href="https://flapypan.netlify.app/posts/%E6%A0%A2%E7%A0%81%E9%A1%B9%E7%9B%AE%E9%9D%A2%E7%BB%8F/#minio-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E7%9A%84%E5%AD%98%E5%8F%96">#</a></h2><p>Minio 的主要特点：</p>
<ul>
<li>简单易用：Minio 的安装和配置非常简单，只需要下载并运行相应的二进制文件即可。它提供- 了一个 Web UI,可以通过界面管理存储桶和对象。</li>
<li>可扩展性：Minio 可以轻松地扩展到多个节点，以提供高可用性和容错能力。它支持多种部署- 模式，包括单节点、主从复制和集群等。</li>
<li>高可用性：Minio 提供了多种机制来保证数据的可靠性和可用性，包括冗余备份、数据复制和- 故障转移等。</li>
<li>安全性：Minio 提供了多种安全机制来保护数据的机密性和完整性，包括 SSL&#x2F;TLS 加密、- 访问控制和数据加密等。</li>
<li>多语言支持：Minio 支持多种编程语言，包括 Java、Python、Ruby 和 Go 等。</li>
<li>社区支持：Minio 是一个开源项目，拥有庞大的社区支持和贡献者。它的源代码可以在 - GitHub 上获得，并且有一个活跃的邮件列表和论坛。</li>
<li>对象存储：Minio 的核心功能是对象存储。它允许用户上传和下载任意数量和大小的对象，并- 提供了多种 API 和 SDK 来访问这些对象。</li>
<li>块存储：Minio 还支持块存储，允许用户上传和下载大型文件(例如图像或视频)。块存储是一- 种快速、高效的方式来处理大型文件。</li>
<li>文件存储：Minio 还支持文件存储，允许用户上传和下载单个文件。文件存储是一种简单、快速的方式来处理小型文件。</li>
</ul>
<p>使用 minio 官方提供的 Java SDK 进行操作。</p>
<blockquote>
<p>Minio 官方文档：<a href="https://min.io/docs/minio/linux/developers/java/minio-java.html">https://min.io/docs/minio/linux/developers/java/minio-java.html</a></p>
</blockquote>
<h2 id="介绍一下雪花-ID-的算法，假如要你实现一个全球唯一的-id-你会怎么做"><a href="#介绍一下雪花-ID-的算法，假如要你实现一个全球唯一的-id-你会怎么做" class="headerlink" title="介绍一下雪花 ID 的算法，假如要你实现一个全球唯一的 id 你会怎么做#"></a>介绍一下雪花 ID 的算法，假如要你实现一个全球唯一的 id 你会怎么做<a href="https://flapypan.netlify.app/posts/%E6%A0%A2%E7%A0%81%E9%A1%B9%E7%9B%AE%E9%9D%A2%E7%BB%8F/#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E9%9B%AA%E8%8A%B1-id-%E7%9A%84%E7%AE%97%E6%B3%95%E5%81%87%E5%A6%82%E8%A6%81%E4%BD%A0%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%85%A8%E7%90%83%E5%94%AF%E4%B8%80%E7%9A%84-id-%E4%BD%A0%E4%BC%9A%E6%80%8E%E4%B9%88%E5%81%9A">#</a></h2><p>雪花算法是一种分布式 ID 生成方案，它可以生成一个长度为 64 位的唯一 ID，其中包含了时间戳、数据中心 ID 和机器 ID 等信息。</p>
<p>雪花算法的核心思想是利用时间戳和机器 ID 生成一个唯一的序列号，从而保证生成的 ID 的唯一性。</p>
<p>雪花算法的优点包括唯一性、时间戳有序和高性能，缺点包括依赖时钟和数据中心 ID 和机器 ID 需要手动分配。</p>
<p>全球唯一 ID 目前有两种方案：</p>
<ol>
<li>基于时间的：能基本保证全球唯一性，但是使用了 Mac 地址，会暴露 Mac 地址和生成时间。</li>
<li>分布式的：能保证全球唯一性，但是常用库基本没有实现。</li>
</ol>
<p>具体可参考 <a href="https://www.developers.pub/article/606">https://www.developers.pub/article/606</a></p>
<h2 id="项目里“楼中楼”评论是如何做的？"><a href="#项目里“楼中楼”评论是如何做的？" class="headerlink" title="项目里“楼中楼”评论是如何做的？#"></a>项目里“楼中楼”评论是如何做的？<a href="https://flapypan.netlify.app/posts/%E6%A0%A2%E7%A0%81%E9%A1%B9%E7%9B%AE%E9%9D%A2%E7%BB%8F/#%E9%A1%B9%E7%9B%AE%E9%87%8C%E6%A5%BC%E4%B8%AD%E6%A5%BC%E8%AF%84%E8%AE%BA%E6%98%AF%E5%A6%82%E4%BD%95%E5%81%9A%E7%9A%84">#</a></h2><p>每条评论加一个类似<code>parentId</code>和<code>replyId</code>字段。</p>
<ol>
<li>直接发表评论，则<code>parentId</code>和<code>replyId</code>都为空</li>
<li>对一级评论回复，则<code>parentId</code>和<code>replyId</code>都为一级评论的<code>id</code></li>
<li>楼中楼进行回复，<code>parentId</code>为一级评论的<code>id</code>，<code>replyId</code>为回复的评论的<code>id</code></li>
</ol>
<h2 id="如何统计一天之内登录过的人数？"><a href="#如何统计一天之内登录过的人数？" class="headerlink" title="如何统计一天之内登录过的人数？#"></a>如何统计一天之内登录过的人数？<a href="https://flapypan.netlify.app/posts/%E6%A0%A2%E7%A0%81%E9%A1%B9%E7%9B%AE%E9%9D%A2%E7%BB%8F/#%E5%A6%82%E4%BD%95%E7%BB%9F%E8%AE%A1%E4%B8%80%E5%A4%A9%E4%B9%8B%E5%86%85%E7%99%BB%E5%BD%95%E8%BF%87%E7%9A%84%E4%BA%BA%E6%95%B0">#</a></h2><p>两种基于 Redis 的方案：</p>
<h3 id="基于-BitSet"><a href="#基于-BitSet" class="headerlink" title="基于 BitSet#"></a>基于 BitSet<a href="https://flapypan.netlify.app/posts/%E6%A0%A2%E7%A0%81%E9%A1%B9%E7%9B%AE%E9%9D%A2%E7%BB%8F/#%E5%9F%BA%E4%BA%8E-bitset">#</a></h3><p>用户登录时，使用<code>setbit</code>命令记录用户已登录。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setbit login:&lt;日期&gt; &lt;用户id&gt; 1</span><br></pre></td></tr></table></figure>



<p>然后使用<code>bitcount</code>统计今日的数量。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bitcount login:&lt;日期&gt;</span><br></pre></td></tr></table></figure>



<p><strong>注意点：</strong> 统计的时间复杂度为 O(N) ，当进行大数据量的统计时，最好将任务指派到附属节点(slave)进行，避免阻塞主节点。</p>
<p><strong>优点：</strong> 精准统计，基本上是秒出结果，能方便地获取统计对象的状态。</p>
<p><strong>缺点：</strong> 数量十分巨大时，空间占用会比较，可以通过分片，或者压缩等手段去解决。</p>
<h3 id="基于-HyperLogLog"><a href="#基于-HyperLogLog" class="headerlink" title="基于 HyperLogLog#"></a>基于 HyperLogLog<a href="https://flapypan.netlify.app/posts/%E6%A0%A2%E7%A0%81%E9%A1%B9%E7%9B%AE%E9%9D%A2%E7%BB%8F/#%E5%9F%BA%E4%BA%8E-hyperloglog">#</a></h3><p>用户登录时，使用<code>pfadd</code>命令记录用户已登录。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pffadd login_&lt;日期&gt; &lt;用户id&gt;</span><br></pre></td></tr></table></figure>



<p>然后使用<code>pfcount</code>统计今日的数量。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pfcount login_&lt;日期&gt;</span><br></pre></td></tr></table></figure>



<p><strong>注意点：</strong> key 不能用:分隔，可使用_代替</p>
<p><strong>优点：</strong> 可以统计海量数量，并且占用内存很小。</p>
<p><strong>缺点：</strong> 牺牲了准确率，而且无法得到每个统计对象的状态。</p>
<blockquote>
<p>Bitmap 存储一亿数据需要 12M，而 HyperLogLog 只需要 14K。</p>
</blockquote>
<h2 id="说一说-MySQL-索引"><a href="#说一说-MySQL-索引" class="headerlink" title="说一说 MySQL 索引#"></a>说一说 MySQL 索引<a href="https://flapypan.netlify.app/posts/%E6%A0%A2%E7%A0%81%E9%A1%B9%E7%9B%AE%E9%9D%A2%E7%BB%8F/#%E8%AF%B4%E4%B8%80%E8%AF%B4-mysql-%E7%B4%A2%E5%BC%95">#</a></h2><blockquote>
<p>栢码视频：<a href="https://www.bilibili.com/video/BV19d4y147Df/?p=20">https://www.bilibili.com/video/BV19d4y147Df/?p=20</a></p>
</blockquote>
<h2 id="java-内存模型了解过吗"><a href="#java-内存模型了解过吗" class="headerlink" title="java 内存模型了解过吗#"></a>java 内存模型了解过吗<a href="https://flapypan.netlify.app/posts/%E6%A0%A2%E7%A0%81%E9%A1%B9%E7%9B%AE%E9%9D%A2%E7%BB%8F/#java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%BA%86%E8%A7%A3%E8%BF%87%E5%90%97">#</a></h2><blockquote>
<p>参考：<a href="https://pdai.tech/md/java/jvm/java-jvm-jmm.html">https://pdai.tech/md/java/jvm/java-jvm-jmm.html</a></p>
</blockquote>
<h2 id="JVM-堆栈内存（什么是虚拟机栈）"><a href="#JVM-堆栈内存（什么是虚拟机栈）" class="headerlink" title="JVM 堆栈内存（什么是虚拟机栈）#"></a>JVM 堆栈内存（什么是虚拟机栈）<a href="https://flapypan.netlify.app/posts/%E6%A0%A2%E7%A0%81%E9%A1%B9%E7%9B%AE%E9%9D%A2%E7%BB%8F/#jvm-%E5%A0%86%E6%A0%88%E5%86%85%E5%AD%98%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88">#</a></h2><p>每个线程都有自己的一个虚拟机栈，虚拟机栈保存着方法的局部变量、部分结果，并参与方法的调用和返回，生命周期和所属的线程一致。每个虚拟机栈中都有一个个的栈帧(Stack Frame)，每个栈帧对应一次方法调用。</p>
<p>栢码视频：<a href="https://www.bilibili.com/video/BV1Er4y1r7as?p=8">https://www.bilibili.com/video/BV1Er4y1r7as?p=8</a></p>
<h2 id="堆栈内存相关的异常"><a href="#堆栈内存相关的异常" class="headerlink" title="堆栈内存相关的异常#"></a>堆栈内存相关的异常<a href="https://flapypan.netlify.app/posts/%E6%A0%A2%E7%A0%81%E9%A1%B9%E7%9B%AE%E9%9D%A2%E7%BB%8F/#%E5%A0%86%E6%A0%88%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3%E7%9A%84%E5%BC%82%E5%B8%B8">#</a></h2><p>如果线程请求分配的栈容量超过允许的最大容量，将会抛出<code>StackOverflowError</code>异常。</p>
<p>如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，将会抛出一个<code>OutOfMemoryError</code>异常。</p>
<blockquote>
<p>栢码视频：<a href="https://www.bilibili.com/video/BV1Er4y1r7as?p=10">https://www.bilibili.com/video/BV1Er4y1r7as?p=10</a></p>
</blockquote>
<h2 id="Java-并发，多线程知道吗？"><a href="#Java-并发，多线程知道吗？" class="headerlink" title="Java 并发，多线程知道吗？#"></a>Java 并发，多线程知道吗？<a href="https://flapypan.netlify.app/posts/%E6%A0%A2%E7%A0%81%E9%A1%B9%E7%9B%AE%E9%9D%A2%E7%BB%8F/#java-%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9F%A5%E9%81%93%E5%90%97">#</a></h2><blockquote>
<p>栢码视频：<a href="https://www.bilibili.com/video/BV1YP4y1o75f?p=118">https://www.bilibili.com/video/BV1YP4y1o75f?p=118</a></p>
</blockquote>
<h2 id="synchronized-实现原理了解吗？锁升级？乐观锁？"><a href="#synchronized-实现原理了解吗？锁升级？乐观锁？" class="headerlink" title="synchronized 实现原理了解吗？锁升级？乐观锁？#"></a>synchronized 实现原理了解吗？锁升级？乐观锁？<a href="https://flapypan.netlify.app/posts/%E6%A0%A2%E7%A0%81%E9%A1%B9%E7%9B%AE%E9%9D%A2%E7%BB%8F/#synchronized-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%BA%86%E8%A7%A3%E5%90%97%E9%94%81%E5%8D%87%E7%BA%A7%E4%B9%90%E8%A7%82%E9%94%81">#</a></h2><blockquote>
<p>栢码视频：<a href="https://www.bilibili.com/video/BV1JT4y1S7K8?p=3">https://www.bilibili.com/video/BV1JT4y1S7K8?p=3</a></p>
</blockquote>
<h2 id="线程池的拒绝策略都有什么？"><a href="#线程池的拒绝策略都有什么？" class="headerlink" title="线程池的拒绝策略都有什么？#"></a>线程池的拒绝策略都有什么？<a href="https://flapypan.netlify.app/posts/%E6%A0%A2%E7%A0%81%E9%A1%B9%E7%9B%AE%E9%9D%A2%E7%BB%8F/#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%E9%83%BD%E6%9C%89%E4%BB%80%E4%B9%88">#</a></h2><blockquote>
<p>栢码视频：<a href="https://www.bilibili.com/video/BV1JT4y1S7K8?p=26">https://www.bilibili.com/video/BV1JT4y1S7K8?p=26</a></p>
</blockquote>
<h2 id="Spring-的扩展你有了解过吗？有没有自己编写过-starter？"><a href="#Spring-的扩展你有了解过吗？有没有自己编写过-starter？" class="headerlink" title="Spring 的扩展你有了解过吗？有没有自己编写过 starter？#"></a>Spring 的扩展你有了解过吗？有没有自己编写过 starter？<a href="https://flapypan.netlify.app/posts/%E6%A0%A2%E7%A0%81%E9%A1%B9%E7%9B%AE%E9%9D%A2%E7%BB%8F/#spring-%E7%9A%84%E6%89%A9%E5%B1%95%E4%BD%A0%E6%9C%89%E4%BA%86%E8%A7%A3%E8%BF%87%E5%90%97%E6%9C%89%E6%B2%A1%E6%9C%89%E8%87%AA%E5%B7%B1%E7%BC%96%E5%86%99%E8%BF%87-starter">#</a></h2><blockquote>
<p>栢码视频：<a href="https://www.bilibili.com/video/BV1xu4y1m7UP?p=20">https://www.bilibili.com/video/BV1xu4y1m7UP?p=20</a></p>
</blockquote>
<h2 id="Spring的事务传播特性"><a href="#Spring的事务传播特性" class="headerlink" title="Spring的事务传播特性#"></a>Spring的事务传播特性<a href="https://flapypan.netlify.app/posts/%E6%A0%A2%E7%A0%81%E9%A1%B9%E7%9B%AE%E9%9D%A2%E7%BB%8F/#spring%E7%9A%84%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E7%89%B9%E6%80%A7">#</a></h2><blockquote>
<p>栢码视频：<a href="https://www.bilibili.com/video/BV1Kv4y1x7is?p=24">https://www.bilibili.com/video/BV1Kv4y1x7is?p=24</a></p>
</blockquote>
<hr>
<p><strong>以下内容施工中</strong></p>
<hr>
<h2 id="Redis过期了任务还没执行完怎么办？"><a href="#Redis过期了任务还没执行完怎么办？" class="headerlink" title="Redis过期了任务还没执行完怎么办？#"></a>Redis过期了任务还没执行完怎么办？<a href="https://flapypan.netlify.app/posts/%E6%A0%A2%E7%A0%81%E9%A1%B9%E7%9B%AE%E9%9D%A2%E7%BB%8F/#redis%E8%BF%87%E6%9C%9F%E4%BA%86%E4%BB%BB%E5%8A%A1%E8%BF%98%E6%B2%A1%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%80%8E%E4%B9%88%E5%8A%9E">#</a></h2><p>写在消息队列里面异步更新redis</p>
<h2 id="查询一个不是主键的索引，需要回表几次？"><a href="#查询一个不是主键的索引，需要回表几次？" class="headerlink" title="查询一个不是主键的索引，需要回表几次？#"></a>查询一个不是主键的索引，需要回表几次？<a href="https://flapypan.netlify.app/posts/%E6%A0%A2%E7%A0%81%E9%A1%B9%E7%9B%AE%E9%9D%A2%E7%BB%8F/#%E6%9F%A5%E8%AF%A2%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%98%AF%E4%B8%BB%E9%94%AE%E7%9A%84%E7%B4%A2%E5%BC%95%E9%9C%80%E8%A6%81%E5%9B%9E%E8%A1%A8%E5%87%A0%E6%AC%A1">#</a></h2><h2 id="慢查询是什么？如何查询？"><a href="#慢查询是什么？如何查询？" class="headerlink" title="慢查询是什么？如何查询？#"></a>慢查询是什么？如何查询？<a href="https://flapypan.netlify.app/posts/%E6%A0%A2%E7%A0%81%E9%A1%B9%E7%9B%AE%E9%9D%A2%E7%BB%8F/#%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%98%AF%E4%BB%80%E4%B9%88%E5%A6%82%E4%BD%95%E6%9F%A5%E8%AF%A2">#</a></h2><p>开启MySQL慢查询日志、explain关键字</p>
<h2 id="主从复制原理知道吗？"><a href="#主从复制原理知道吗？" class="headerlink" title="主从复制原理知道吗？#"></a>主从复制原理知道吗？<a href="https://flapypan.netlify.app/posts/%E6%A0%A2%E7%A0%81%E9%A1%B9%E7%9B%AE%E9%9D%A2%E7%BB%8F/#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86%E7%9F%A5%E9%81%93%E5%90%97">#</a></h2><h2 id="项目里的客户端都采集服务器的什么信息了？"><a href="#项目里的客户端都采集服务器的什么信息了？" class="headerlink" title="项目里的客户端都采集服务器的什么信息了？#"></a>项目里的客户端都采集服务器的什么信息了？<a href="https://flapypan.netlify.app/posts/%E6%A0%A2%E7%A0%81%E9%A1%B9%E7%9B%AE%E9%9D%A2%E7%BB%8F/#%E9%A1%B9%E7%9B%AE%E9%87%8C%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%83%BD%E9%87%87%E9%9B%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BB%80%E4%B9%88%E4%BF%A1%E6%81%AF%E4%BA%86">#</a></h2><h2 id="Spring的事务传播特性-1"><a href="#Spring的事务传播特性-1" class="headerlink" title="Spring的事务传播特性?#"></a>Spring的事务传播特性?<a href="https://flapypan.netlify.app/posts/%E6%A0%A2%E7%A0%81%E9%A1%B9%E7%9B%AE%E9%9D%A2%E7%BB%8F/#spring%E7%9A%84%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E7%89%B9%E6%80%A7-1">#</a></h2><h2 id="Spring的事务你用过吗？"><a href="#Spring的事务你用过吗？" class="headerlink" title="Spring的事务你用过吗？#"></a>Spring的事务你用过吗？<a href="https://flapypan.netlify.app/posts/%E6%A0%A2%E7%A0%81%E9%A1%B9%E7%9B%AE%E9%9D%A2%E7%BB%8F/#spring%E7%9A%84%E4%BA%8B%E5%8A%A1%E4%BD%A0%E7%94%A8%E8%BF%87%E5%90%97">#</a></h2><h2 id="那-Transactional的原理呢？"><a href="#那-Transactional的原理呢？" class="headerlink" title="那@Transactional的原理呢？#"></a>那@Transactional的原理呢？<a href="https://flapypan.netlify.app/posts/%E6%A0%A2%E7%A0%81%E9%A1%B9%E7%9B%AE%E9%9D%A2%E7%BB%8F/#%E9%82%A3transactional%E7%9A%84%E5%8E%9F%E7%90%86%E5%91%A2">#</a></h2><h2 id="什么情况会导致事务的失效？"><a href="#什么情况会导致事务的失效？" class="headerlink" title="什么情况会导致事务的失效？#"></a>什么情况会导致事务的失效？<a href="https://flapypan.netlify.app/posts/%E6%A0%A2%E7%A0%81%E9%A1%B9%E7%9B%AE%E9%9D%A2%E7%BB%8F/#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%BC%9A%E5%AF%BC%E8%87%B4%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%A4%B1%E6%95%88">#</a></h2><h2 id="你项目里是如何保证Redis和数据库的最终一致性的？"><a href="#你项目里是如何保证Redis和数据库的最终一致性的？" class="headerlink" title="你项目里是如何保证Redis和数据库的最终一致性的？#"></a>你项目里是如何保证Redis和数据库的最终一致性的？<a href="https://flapypan.netlify.app/posts/%E6%A0%A2%E7%A0%81%E9%A1%B9%E7%9B%AE%E9%9D%A2%E7%BB%8F/#%E4%BD%A0%E9%A1%B9%E7%9B%AE%E9%87%8C%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81redis%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84">#</a></h2><h2 id="Redis持久化你项目里用了吗？"><a href="#Redis持久化你项目里用了吗？" class="headerlink" title="Redis持久化你项目里用了吗？#"></a>Redis持久化你项目里用了吗？<a href="https://flapypan.netlify.app/posts/%E6%A0%A2%E7%A0%81%E9%A1%B9%E7%9B%AE%E9%9D%A2%E7%BB%8F/#redis%E6%8C%81%E4%B9%85%E5%8C%96%E4%BD%A0%E9%A1%B9%E7%9B%AE%E9%87%8C%E7%94%A8%E4%BA%86%E5%90%97">#</a></h2><h2 id="说一下RabbitMQ里面的角色吧？"><a href="#说一下RabbitMQ里面的角色吧？" class="headerlink" title="说一下RabbitMQ里面的角色吧？#"></a>说一下RabbitMQ里面的角色吧？<a href="https://flapypan.netlify.app/posts/%E6%A0%A2%E7%A0%81%E9%A1%B9%E7%9B%AE%E9%9D%A2%E7%BB%8F/#%E8%AF%B4%E4%B8%80%E4%B8%8Brabbitmq%E9%87%8C%E9%9D%A2%E7%9A%84%E8%A7%92%E8%89%B2%E5%90%A7">#</a></h2><h2 id="如何保证消息不丢失？"><a href="#如何保证消息不丢失？" class="headerlink" title="如何保证消息不丢失？#"></a>如何保证消息不丢失？<a href="https://flapypan.netlify.app/posts/%E6%A0%A2%E7%A0%81%E9%A1%B9%E7%9B%AE%E9%9D%A2%E7%BB%8F/#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1">#</a></h2><h2 id="消息积压怎么办？"><a href="#消息积压怎么办？" class="headerlink" title="消息积压怎么办？#"></a>消息积压怎么办？<a href="https://flapypan.netlify.app/posts/%E6%A0%A2%E7%A0%81%E9%A1%B9%E7%9B%AE%E9%9D%A2%E7%BB%8F/#%E6%B6%88%E6%81%AF%E7%A7%AF%E5%8E%8B%E6%80%8E%E4%B9%88%E5%8A%9E">#</a></h2><h2 id="你简历里项目是怎么部署到服务器的？（docker镜像）"><a href="#你简历里项目是怎么部署到服务器的？（docker镜像）" class="headerlink" title="你简历里项目是怎么部署到服务器的？（docker镜像）"></a>你简历里项目是怎么部署到服务器的？（docker镜像）</h2>]]></content>
  </entry>
</search>
